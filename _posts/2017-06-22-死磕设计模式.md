---
layout: post
title:  "死磕设计模式"
date:   2017-06-22
desc: "死磕设计模式"
keywords: "java,设计模式"
categories: [Java]
tags: [java,设计模式]
icon: icon-html
---

最近看spring源码的时候会看到很多经典的设计模式，索性就把几个常用的经典的设计模式再复习总结遍，这是常更新帖。

**一、观察者模式**

**是什么：**

观察者模式是在维护多个对象之间的一对多的依赖关系，也就是说，当一个对象的状态发生了改变时会通知所有依赖于它的对象，好让这些对象对新的变化做出反应。观察者模式既可以有效的维护对象的一致性，又能最大限度的降低对象之间的耦合度。

**长什么样：**

<img title="死磕设计模式" src="http://img.mukewang.com/597098400001ecc520880750.png" style="width:100%" alt="死磕设计模式">

从上面的UML类图可以看出：有两个接口，一个是主体对象接口，一个是观察者接口。主体对象接口定义了通知的方法，实现它的类Boss中有新增/删除观察者的方法；观察者接口定义了更新的方法，当boss的状态改变后，boss会notify所有的观察者来执行update方法做相应的更新操作。这么说可能还有点抽象，下面直接上代码demo。

**怎么做：**


	public interface BossInterface
	{
	    void notify();
	}
	
	public interface Observer
	{
	    void update();
	}
	
	public class Boss implements BossInterface
	{
	    private String bossSay;
	
	    private List<Observer> observers = new ArrayList<Observer>();
	
	    // 增加观察者
	    public void addObserver(Observer observer)
	    {
	        this.observers.add(observer);
	    }
	
	    // 移除观察者
	    public void deleteObserver(Observer observer)
	    {
	        this.observers.remove(observer);
	    }
	
	    //获取Boss状态
	    public String getBossSay()
	    {
	        return bossSay;
	    }
	
	    //设置Boss状态
	    public void setBossSay(String bossSay)
	    {
	        this.bossSay = bossSay;
	    }
	
	    //通知所有的观察者工作
	    public void notify()
	    {
	        foreach (Observer observer in observers)
	        {
	            observer.update();
	        }
	    }
	}
	
	public class Coder implements Observer
	{
	    private Boss boss;
	
	    public Coder(Boss boss)
	    {
	        this.boss = boss;
	    }
	
	    // 更新状态
	    public void update()
	    {
	        if (boss.getBossSay() == "兄弟们，为了世界和平，一起Hello,world吧！")
	        {
	            //开始写代码
	        }
	    }
	}
	
	public class UI extends Observer
	{
	    private Boss boss;
	
	    public UI(Boss boss)
	    {
	        this.boss = boss;
	    }
	
	    // 更新状态
	    public void update()
	    {
	        if (boss.getBossSay() == "兄弟们，为了世界和平，一起Hello,world吧！")
	        {
	            //开始写UI
	        }
	    }
	}
	
	public class PM extends Observer
	{
	    private Boss boss;
	
	    public PM(Boss boss)
	    {
	        this.boss = boss;
	    }
	
	    // 更新状态
	    public void update()
	    {
	        if (boss.getBossSay() == "兄弟们，为了世界和平，一起Hello,world吧！")
	        {
	            //开始写项目的各种文档，请程序员、测试、运维、美工吃饭
	        }
	    }
	}

**二、适配器模式**

**是什么：**

适配器模式就是将那些原本由于接口不兼容而不能一起工作的类适配成可以在一起工作的类，适配器是一种增强或转换的工具，将那些不符合我们的需求但已经存在的类的接口，在不修改这类接口本身的情况下适配成我们想要的类。

**长什么样：**

<img title="死磕设计模式" src="http://img.mukewang.com/5970988f000189c215220838.png" style="width:100%" alt="死磕设计模式">

**怎么做：**

	// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
	class ExistingClass {
	    public void enhanceMethod() {
	        System.out.println("被适配类具有 特殊功能...");
	    }
	}
	
	// 目标接口，或称为标准接口
	interface RequiredInterface {
	    public void requiredMethod();
	}
	
	// 原本存在的类，只提供普通功能
	class OriginalClass implements RequiredInterface {
	    public void requiredMethod() {
	        System.out.println("普通类 具有 普通功能...");
	    }
	}
	
	// 适配器类，继承了被适配类，同时实现标准接口
	class Adapter extends RequiredInterface implements RequiredInterface{
	    public void requiredMethod() {
	        super.enhanceMethod();
	    }
	}