<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>周明的技术博客</title>
    <description>Jack's blog,use Jekyll and github pages.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 23 Jul 2017 19:21:38 +0800</pubDate>
    <lastBuildDate>Sun, 23 Jul 2017 19:21:38 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>死磕Spring源码-IoC</title>
        <description>&lt;p&gt;我们都知道IoC（Inversion of control）是控制反转，控制反转的核心是依赖反转，那到底什么是“依赖反转”，“哪些方面的控制被反转了？”－－依赖对象的获得被反转了。通过依赖注入的方式获取类对象实例而不是传统的在类自身通过新建（new）类对象来获取。所以这种反转是“责任”的反转，传统的这种对对象的管理是由java类自身来管理，而Spring通过IoC容器来管理，这种对对象的依赖关系的管理被反转了，转到IoC容器来了。对象之间的相互依赖关系由IoC容器进行管理，并由IoC容器完成对象的注入。这种做法降低了类之间的耦合度，同时提高了代码的可测试性。&lt;/p&gt;

&lt;p&gt;IoC容器主要有两个容器系列：BeanFactory和ApplicationContext。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC容器主要的接口设计图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59744b1b0001c33d17101006.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、BeanFactory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接口类BeanFactory提供了Spring中所有IOC容器的最基本的功能规范，来看看&lt;strong&gt;BeanFactory的组织结构图&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/597444f50001bb0106261194.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface BeanFactory {
    //如果我们加了这个转义字符，则得到的是这个IOC容器本身，否则得到的是IOC容器的实例
     String FACTORY_BEAN_PREFIX = “&amp;amp;”;
     Object getBean(String name) throws BeansException;
     &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
     &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
     Object getBean(String name, Object... args) throws BeansException;
     &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;
     boolean containsBean(String name);
     boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
     boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
     boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
     boolean isTypeMatch(String name, Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;
     Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;
     String[] getAliases(String name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的IoC容器都需要满足BeanFactory这个基本的接口定义，Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系。对IoC容器来说，BeanDefinition抽象了对Bean的定义的一种数据类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BeanDefinition的组织结构如下图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/59744544000144cd06161220.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BeanFactory是一个接口类，我们来看看一个BeanFactory的具体实现类XmlBeanFactory，从名字上就能看出来这是一个与xml相关的BeanFactory，它是一个可以读取以XML文件方式定义的BeanDefinition的IoC容器。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/597445bc000120d818280524.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class XmlBeanFactory extends DefaultListableBeanFactory {

     private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);

     public XmlBeanFactory(Resource resource) throws BeansException {
          this(resource, null);
     }

     public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
          super(parentBeanFactory);
          this.reader.loadBeanDefinitions(resource);
     }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在XmlBeanFactory这个IOC容器中，初始化了一个XmlBeanDefinitionReader，用这个XmlBeanDefinitionReader来处理XML中的BeanDefinition对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;手工创建IOC容器&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class XmlIOCTest {

     public static void main(String[] args) {
//定义BeanDefinition的信息来源，在XmlBeanFactory中作为构造函数的参数传给XmlBeanFactory     
		  ClassPathResource resource = new ClassPathResource(&quot;config\\beans.xml”);
//创建一个BeanFactory的IoC容器
          DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
//创建一个加载BeanDefinition的读取器，通过一个回调配置给BeanFactory
          XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
//从信息来源中加载BeanDefinition
          reader.loadBeanDefinitions(resource);
          Admin admin = (Admin)factory.getBean(&quot;admin&quot;);
          admin.setName(&quot;ming.zhou&quot;);
          admin.setPassword(&quot;123&quot;);
          admin.setStatus(1);
          System.out.println(admin);
     }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输入结果：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Admin{id=null, name='ming.zhou', password='123', status=1}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由上我们可以总结IoC容器的初始化过程（refresh()方法来启动）：（源码查看可以通过loadBeanDefinitions逐步查看）
Resource定位过程－－BeanDefinition的载入－－向IoC容器注册BeanDefinition（调用BeanDefinitionRegistry接口来实现，每个bean放在hashMap中存储）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、ApplicationContext&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接口类ApplicationContext是高级形态意义的IOC容器。&lt;/p&gt;

&lt;p&gt;IoC容器的初始化是由refresh()方法来启动的，它标志这IoC容器的正式启动，启动过程包含BeanDefinition的Resource定位、载入和注册三个基本过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 Resource定位&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resource接口设计图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片5=&quot;&quot; src=&quot;http://img.mukewang.com/597450100001ace507340894.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FileSystemApplicationContext，支持XML定义的BeanDefinition的ApplicationContext，可指定以文件形式的BeanDefinition的读入，文件放在本地文件系统中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FileSystemApplicationContext的继承关系图:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片6=&quot;&quot; src=&quot;http://img.mukewang.com/597447b90001efaa07380916.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getResourceByPath()的调用栈：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片7=&quot;&quot; src=&quot;http://img.mukewang.com/597447e10001335817380988.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过查看FileSystemApplicationContext中的getResourceByPath()的方法调用栈可以发现这个&lt;strong&gt;IOC容器资源定位的实现过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片8=&quot;&quot; src=&quot;http://img.mukewang.com/597447fa0001cf1e17800904.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;类AbstractRefreshableApplicationContext对容器初始化源码分析:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected final void refreshBeanFactory() throws BeansException {
//如果已经建立了BeanFactory，则销毁并关闭该BeanFactory，保证refresh以后使用的是新建立起来的IoC容器
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory);
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
    }
}

@Override
public Resource getResource(String location) {
    Assert.notNull(location, &quot;Location must not be null&quot;);

    for (ProtocolResolver protocolResolver : this.protocolResolvers) {
        Resource resource = protocolResolver.resolve(location, this);
        if (resource != null) {
            return resource;
        }
    }

    if (location.startsWith(&quot;/&quot;)) {
        return getResourceByPath(location);
    }
    //处理带有classpath标识的Resource
    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
    }
    else {
        try {
            // 处理URL标识的Resource
            URL url = new URL(location);
            return new UrlResource(url);
        }
        catch (MalformedURLException ex) {
            // No URL -&amp;gt; resolve as resource path.
            return getResourceByPath(location);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整个过程起源于FileSystemApplicationContext的构造函数的初始化，通过构造函数中的refresh()方法来启动整个应用，在AbstractRefreshableApplicationContext中的refreshBeanFactory()方法中我们可以看到使用了createBeanFactory构建了一个DefaultListableBeanFactory的IOC容器，同时启动资源载入（AbstractRefreshableApplicationContext中的loadBeanDefinitions()方法是抽象方法，因为载入的方式有很多种，具体的载入操作交由其子类去具体实现，这里的子类就是
XmlWebApplicationContext
）；具体的资源载入在XmlWebApplicationContext的loadBeanDefinitions()中读入BeanDefinition时完成（loadBeanDefinitions方法在方法调用栈中第一次出现是在XmlWebApplicationContext中的），载入的具体实现在XmlWebApplicationContext的基类AbstractBeanDefinitionReader中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 BeanDefinition的载入与解析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;loadBeanDefinitions的调用方法栈:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片9=&quot;&quot; src=&quot;http://img.mukewang.com/597449790001262916520684.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了Resource定位对象后，开始BeanDefinition的载入与解析的工作，按照Spring的Bean定义规则来对这个XML的文档树进行解析了，解析工作是交给BeanDefinitionParserDelegate来完成的。BeanDefinition的载入分为两部分：首先是通过调用XML的解析器得到document对象，但这些document对象并没有按照Spring的Bean规则进行解析；然后在完成通用的XML解析后，才开始按照Spring的Bean规则进行解析。按照Spring的Bean规则进行解析过程是在documentReader中实现的，把Bean的id、name、aliase等属性元素读取出来后设置到生成的BeanDefinitionHolder中去。BeanDefinitionHolder是BeanDefinition的封装类，封装了BeanDefinition，Bean的名字和别名，用它来完成向IoC容器注册。&lt;/p&gt;

&lt;p&gt;BeanDefinition的载入与解析过程源码解析如下，有点长，但不难，耐心看下去思路还是很清晰的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
//调用入口
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(new EncodedResource(resource));
}
//载入XML形式的BeanDefinition
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
    }

    Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
    if (currentResources == null) {
        currentResources = new HashSet&amp;lt;EncodedResource&amp;gt;(4);
        this.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    if (!currentResources.add(encodedResource)) {
        throw new BeanDefinitionStoreException(
                &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
    }
    //得到XML文件，并获取IO的InputSource准备进行读取
    try {
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(
                &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
    }
    finally {
        currentResources.remove(encodedResource);
        if (currentResources.isEmpty()) {
            this.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}
//具体的读取过程
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {
    try {
        //调用XML的解析器得到document对象
        Document doc = doLoadDocument(inputSource, resource);
        //启动对BeanDefinition解析过程
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;IOException parsing XML document from &quot; + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
    }
}
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    //得到BeanDefinitionDocumentReader来对XML的BeanDefinition进行解析
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    int countBefore = getRegistry().getBeanDefinitionCount();
    //调用BeanDefinitionDocumentReader的registerBeanDefinitions完成具体的解析过程
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    return getRegistry().getBeanDefinitionCount() - countBefore;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;BeanDefinitionDocumentReader类的registerBeanDefinitions方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug(&quot;Loading bean definitions&quot;);
    Element root = doc.getDocumentElement();
    doRegisterBeanDefinitions(root);
}
protected void doRegisterBeanDefinitions(Element root) {
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
                            &quot;] not matching: &quot; + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    parseBeanDefinitions(root, this.delegate);
    postProcessXml(root);

    this.delegate = parent;
}
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    //BeanDefinitionHolder是BeanDefinition的封装类，封装了BeanDefinition，Bean的名字和别名，用它来完成向IoC容器注册
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            //向IoC容器注册解析得到的BeanDefinition
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
                    bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
//BeanDefinitionParserDelegate类方法，具体的解析过程，把Bean的id、name、aliase等属性元素读取出来后设置到生成的BeanDefinitionHolder中去
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
    //取得&amp;lt;Bean&amp;gt;元素中的id、name、aliase属性的值
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;String&amp;gt;();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {
        beanName = aliases.remove(0);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName +
                    &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
        }
    }

    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }
    //对Bean元素的详细解析，比如class、parent、init-method、destroy-method等
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    // Register an alias for the plain bean class name, if still possible,
                    // if the generator returned the class name plus a suffix.
                    // This is expected for Spring 1.2/2.0 backwards compatibility.
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &amp;amp;&amp;amp;
                            beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; +
                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;载入与解析的方法调用流程图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片10=&quot;&quot; src=&quot;http://img.mukewang.com/59744a180001978917380986.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过以上的载入过程，我们大致完成了IoC容器的Bean对象的数据准备工作或初始化工作，但现在IoC容器BeanDefinition中还只是存在些静态的配置信息，还不能供IoC容器直接使用，要想让IoC容器发挥作用还需要进行BeanDefinition的注册。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 BeanDefinition的注册&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注册过程相对简单，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的，这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册，通过源码分析，我们可以看到在IoC容器中是持有一个HashMap来装BeanDefinition数据的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;registerBeanDefinition的调用方法栈:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片11=&quot;&quot; src=&quot;http://img.mukewang.com/59744a4700014e0a17340788.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt;(256);
public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}

@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {

    Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
    Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

    if (beanDefinition instanceof AbstractBeanDefinition) {
        try {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    &quot;Validation of bean definition failed&quot;, ex);
        }
    }

    BeanDefinition oldBeanDefinition;

    //检查是不是有同名字的BeanDefinition已经在IoC容器中注册了，如果存在且不允许覆盖则抛出异常
    oldBeanDefinition = this.beanDefinitionMap.get(beanName);
    if (oldBeanDefinition != null) {
        if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean '&quot; + beanName +
                    &quot;': There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);
        }
        else if (oldBeanDefinition.getRole() &amp;lt; beanDefinition.getRole()) {
            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
            if (this.logger.isWarnEnabled()) {
                this.logger.warn(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
                        &quot;' with a framework-generated bean definition: replacing [&quot; +
                        oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
            }
        }
        else if (!beanDefinition.equals(oldBeanDefinition)) {
            if (this.logger.isInfoEnabled()) {
                this.logger.info(&quot;Overriding bean definition for bean '&quot; + beanName +
                        &quot;' with a different definition: replacing [&quot; + oldBeanDefinition +
                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
            }
        }
        else {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
                        &quot;' with an equivalent definition: replacing [&quot; + oldBeanDefinition +
                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
            }
        }
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            //注册过程需要synchronized，保证数据的一致性
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;String&amp;gt;(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                if (this.manualSingletonNames.contains(beanName)) {
                    Set&amp;lt;String&amp;gt; updatedSingletons = new LinkedHashSet&amp;lt;String&amp;gt;(this.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    this.manualSingletonNames = updatedSingletons;
                }
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            this.manualSingletonNames.remove(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (oldBeanDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注册过程会检查是不是有同名字的BeanDefinition已经在IoC容器中注册了，如果存在且不允许覆盖则抛出异常，注册过程需要synchronized，保证数据的一致性。&lt;/p&gt;

&lt;p&gt;完成了BeanDefinition的注册，IOC容器的初始化过程就结束了，在这个IOC容器中已经有了整个Bean的配置信息。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;1、Spring 4.3.3源码&lt;/p&gt;

&lt;p&gt;2、Spring 技术内幕（深入解析Spring架构与设计原理）&lt;/p&gt;

</description>
        <pubDate>Sun, 02 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/07/02/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BIoC.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/07/02/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BIoC.html</guid>
        
        <category>java</category>
        
        <category>Spring</category>
        
        <category>源码</category>
        
        <category>IoC</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕设计模式</title>
        <description>&lt;p&gt;最近看spring源码的时候会看到很多经典的设计模式，索性就把几个常用的经典的设计模式再复习总结遍，这是常更新帖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、观察者模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;观察者模式是在维护多个对象之间的一对多的依赖关系，也就是说，当一个对象的状态发生了改变时会通知所有依赖于它的对象，好让这些对象对新的变化做出反应。观察者模式既可以有效的维护对象的一致性，又能最大限度的降低对象之间的耦合度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;长什么样：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式&quot; src=&quot;http://img.mukewang.com/597098400001ecc520880750.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕设计模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的UML类图可以看出：有两个接口，一个是主体对象接口，一个是观察者接口。主体对象接口定义了通知的方法，实现它的类Boss中有新增/删除观察者的方法；观察者接口定义了更新的方法，当boss的状态改变后，boss会notify所有的观察者来执行update方法做相应的更新操作。这么说可能还有点抽象，下面直接上代码demo。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么做：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface BossInterface
{
    void notify();
}

public interface Observer
{
    void update();
}

public class Boss implements BossInterface
{
    private String bossSay;

    private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;Observer&amp;gt;();

    // 增加观察者
    public void addObserver(Observer observer)
    {
        this.observers.add(observer);
    }

    // 移除观察者
    public void deleteObserver(Observer observer)
    {
        this.observers.remove(observer);
    }

    //获取Boss状态
    public String getBossSay()
    {
        return bossSay;
    }

    //设置Boss状态
    public void setBossSay(String bossSay)
    {
        this.bossSay = bossSay;
    }

    //通知所有的观察者工作
    public void notify()
    {
        foreach (Observer observer in observers)
        {
            observer.update();
        }
    }
}

public class Coder implements Observer
{
    private Boss boss;

    public Coder(Boss boss)
    {
        this.boss = boss;
    }

    // 更新状态
    public void update()
    {
        if (boss.getBossSay() == &quot;兄弟们，为了世界和平，一起Hello,world吧！&quot;)
        {
            //开始写代码
        }
    }
}

public class UI extends Observer
{
    private Boss boss;

    public UI(Boss boss)
    {
        this.boss = boss;
    }

    // 更新状态
    public void update()
    {
        if (boss.getBossSay() == &quot;兄弟们，为了世界和平，一起Hello,world吧！&quot;)
        {
            //开始写UI
        }
    }
}

public class PM extends Observer
{
    private Boss boss;

    public PM(Boss boss)
    {
        this.boss = boss;
    }

    // 更新状态
    public void update()
    {
        if (boss.getBossSay() == &quot;兄弟们，为了世界和平，一起Hello,world吧！&quot;)
        {
            //开始写项目的各种文档，请程序员、测试、运维、美工吃饭
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;二、适配器模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;适配器模式就是将那些原本由于接口不兼容而不能一起工作的类适配成可以在一起工作的类，适配器是一种增强或转换的工具，将那些不符合我们的需求但已经存在的类的接口，在不修改这类接口本身的情况下适配成我们想要的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;长什么样：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式&quot; src=&quot;http://img.mukewang.com/5970988f000189c215220838.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕设计模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么做：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class ExistingClass {
    public void enhanceMethod() {
        System.out.println(&quot;被适配类具有 特殊功能...&quot;);
    }
}

// 目标接口，或称为标准接口
interface RequiredInterface {
    public void requiredMethod();
}

// 原本存在的类，只提供普通功能
class OriginalClass implements RequiredInterface {
    public void requiredMethod() {
        System.out.println(&quot;普通类 具有 普通功能...&quot;);
    }
}

// 适配器类，继承了被适配类，同时实现标准接口
class Adapter extends ExistingClass implements RequiredInterface{
    public void requiredMethod() {
        super.enhanceMethod();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、代理模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代理模式顾名思义就是使用了一个代理人，有代理就有在代理背后的目标对象，代理模式的意义在你不直接对目标对象进行操作，而是通过代理对象来操作目标对象，那么在代理对象这一层你就可以对目标对象进行很多增强的工作并且不用改变目标对象的代码。在实际工作中也很有指导意义，就是永远别去改别人已经写好的上线测试过了的代码，你可以利用代理模式来扩展目标对象的功能。&lt;/p&gt;

&lt;p&gt;举个栗子：你购买了一个第三方的工具，当你在使用上问题的时候，你可能不能直接找到写这个工具的程序猿/媛，但你可以找到售后服务人员或技术支持人员，这个角色充当的就是代理对象，程序猿/媛就是目标对象，你找售后人员反映问题，售后把问题总结后集中反馈给程序猿/媛，他们去修改代码，给出个解决方案，具体的流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/5971caec0001d6c913360472.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕设计模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出，用户先去调售后服务（代理对象），她是我们的程序猿/媛（目标对象）的代理，代理对象是对目标对象的扩展，同时代理对象会调用目标对象的方法来完成目的。&lt;/p&gt;

&lt;p&gt;代理模式根据其代理的方式分为三种：静态代理，动态代理和Cglib代理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 静态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代理方式：代理对象和目标对象必须实现同一个接口或继承同一个父类，通过调用代理对象的相同的方法来调用目标对象的方法。&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 制定好的行业标准
*/
public interface OperationStandard {

    void operate();
}

/**
* 目标对象，实现相同的行业标准
*/
public class Coder implements OperationStandard {
    public void operate() {
        //调整代码，提出解决方案
    }
}

/**
* 代理对象，实现相同的行业标准
*/
public class Service implements OperationStandard{
    //接收保存目标对象
    private Coder target;
    public Service(Coder target){
        this.target=target;
    }

    public void operate() {
        System.out.println(“增强功能1...&quot;);
        target.operate();//执行目标对象的方法
        System.out.println(“增强功能2...&quot;);
    }
}

/**
* 用户
*/
public class Customer {
    public static void main(String[] args) {
        //目标对象
        Coder target = new Coder();

        //代理对象,把目标对象传给代理对象,建立代理关系
        Service proxy = new Service(target);

        proxy.save();//执行的是代理的方法
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;静态代理虽然简单，但缺点也很明显：目标对象和代理对象都要实现相同的接口，一旦接口需要变动，目标类和代理类都需要维护。这很好理解，售后人员和程序猿/媛之间对项目都有明确的标准的需求或功能文档，程序猿/媛按照标准文档开发，售后人员按照标准文档对外提供服务，一旦公司的这些标准文档变化了，那么需要组织售后人员和程序猿/媛一起进行培训，这样无疑很耗时耗力。&lt;/p&gt;

&lt;p&gt;动态代理可以很好的解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;动态代理利用JDK的API动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)&lt;/p&gt;

&lt;p&gt;JDK中生成代理对象的API：
java.lang.reflect.Proxy.newProxyInstance
static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces,InvocationHandler h )&lt;/p&gt;

&lt;p&gt;注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:&lt;/p&gt;

&lt;p&gt;ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的&lt;/p&gt;

&lt;p&gt;Class&amp;lt;?&amp;gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型&lt;/p&gt;

&lt;p&gt;InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入&lt;/p&gt;

&lt;p&gt;行业标准和目标类和静态代理是一样的，下面只写代理类的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 创建动态代理对象
* 动态代理不需要实现接口,但是需要指定接口类型
*/
public class Service{

    //维护一个目标对象
    private Object target;
    public Service(Object target){
        this.target=target;
    }

   //给目标对象生成代理对象
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(&quot;增强功能1&quot;);
                        //执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        System.out.println(&quot;增强功能2&quot;);
                        return returnValue;
                    }
                }
        );
    }

}
/**
* 用户
*/
public class Customer {
    public static void main(String[] args) {
        // 目标对象
        OperationStandard target = new Coder();
        // 【原始的类型 class com.intelligentler.Controller.Coder】
        System.out.println(target.getClass());

        // 给目标对象，创建代理对象
        OperationStandard proxy = (OperationStandard) new Service(target).getProxyInstance();
        // class $Proxy0   内存中动态生成的代理对象
        System.out.println(proxy.getClass());

        // 执行代理对象的方法
        proxy.operate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候售后人员就厉害了，她不需要依赖标准文档就可以对接不同类型的程序猿/媛，你想让她去代理哪个程序猿/媛都可以，因为她会动态的去调用不同目标对象的执行方法。但动态代理中的目标对象还是要实现标准接口，否则无法使用动态代理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 Cglib代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理。&lt;/p&gt;

&lt;p&gt;Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)&lt;/p&gt;

&lt;p&gt;Cglib子类代理实现方法:&lt;/p&gt;

&lt;p&gt;1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可.&lt;/p&gt;

&lt;p&gt;2.引入功能包后,就可以在内存中动态构建子类&lt;/p&gt;

&lt;p&gt;3.代理的类不能为final,否则报错&lt;/p&gt;

&lt;p&gt;4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 目标对象,没有实现任何接口
*/
public class Coder {

    public void operate() {
        //调整代码，提出解决方案
    }
}
Cglib代理工厂:ServiceProxyFactory.java
/**
* Cglib子类代理工厂
* 对Coder在内存中动态构建一个子类对象
*/
public class ServiceProxyFactory implements MethodInterceptor{
    //维护目标对象
    private Object target;

    public ServiceProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象创建一个代理对象
    public Object getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return en.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(&quot;增强功能1&quot;);

        //执行目标对象的方法
        Object returnValue = method.invoke(target, args);

        System.out.println(&quot;增强功能1&quot;);

        return returnValue;
    }
}

/**
* 用户
*/
public class Customer {
    @Test
    public void test(){
        //目标对象
        Coder target = new Coder();
        //代理对象
        Coder proxy = (Coder)new ServiceProxyFactory(target).getProxyInstance();
        //执行代理对象的方法
        proxy.save();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Cglib代理中售后人员和程序猿/媛有着无比的默契，沟通不再需要标准文档。&lt;/p&gt;

&lt;p&gt;在Spring的AOP编程中:&lt;/p&gt;

&lt;p&gt;如果加入容器的目标对象有实现接口,用JDK代理&lt;/p&gt;

&lt;p&gt;如果目标对象没有实现接口,用Cglib代理&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;http://www.cnblogs.com/cenyu/p/6289209.html&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/06/22/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/06/22/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
        
        <category>java</category>
        
        <category>设计模式</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Java知识点大扫盲</title>
        <description>&lt;p&gt;在Java的学习过程中，多多少少会遗漏掉一些基本的知识点，而这些基本的知识点往往是奠定Java基础很重要的部分，里面的很多知识点我们编程中往往用不到，但理解它们能帮助我们更好地掌握Java，本文是一个长期贴，会不定时更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、函数的形参到底获取的是实参的值还是实参的引用地址？&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main17{     
     String str = &quot;start&quot;;
     char ch[] = {'a','b','c'};
     Integer a = 1;
     float f = 1.0f;
     double d = 1.0;     
     public void change(String str,char[] ch){
          str = &quot;end&quot;;
          ch[0] = 'e';
     }     
     public void change(Integer a){
          a = 2;
     }     
     public void change(float f){
          f = 2.0f;
     }
     public void change(double d){
          d = 2.0;
     }     
     public static void main(String[] args) {
          Main17 m17 = new Main17();
          m17.change(m17.str, m17.ch);
          System.out.print(m17.str + &quot; and &quot;);
          System.out.println(m17.ch);
          m17.change(m17.a);
          System.out.println(m17.a);
          m17.change(m17.f);
          System.out.println(m17.f);
          m17.change(m17.d);
          System.out.println(m17.d);
     }
}
result：
start and ebc
1
1.0
1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以发现String，float，double，这些值changea后都没变，但是char的值改变了，也就是说String，float，double给形参传入的是实参的值，因为这些类都是final类（还有：Integer，Long，Short）；而char给形参传入的是实参的引用地址，所以change中改变了char的值会反映到类的全局变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Java中&amp;amp;&amp;amp;和&amp;amp;以及||和|的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;amp;&amp;amp;和&amp;amp;都是表示与，区别是&amp;amp;&amp;amp;只要第一个条件为false，后面条件就不再判断。而&amp;amp;要对所有的条件都进行判断。&lt;/p&gt;

&lt;p&gt;但是||和|都是表示“或”，区别是||只要第一个条件为true，后面的条件就不再判断，而|要对所有的条件进行判断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、==与equals&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String s = &quot;hello&quot;；
String t = “hello”；
char c [] = {'h','e','l','l','o'}；

s == t //true
s.equals(c)//false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先==与equals是有明显区别的。&lt;/p&gt;

&lt;p&gt;==强调栈中的比较，可以理解为地址比较&lt;/p&gt;

&lt;p&gt;equals强调对象的内容比较&lt;/p&gt;

&lt;p&gt;String s=“hello”；会在栈中生成hello字符串，并存入字符串常量池中。&lt;/p&gt;

&lt;p&gt;String t=“hello” ；创建时，会在字符串常量池中寻找，当找到需要的hello时，不进行字符串的创建，引用已有的。 所以，s==t返回true，s.equals(t)也是true。&lt;/p&gt;

&lt;p&gt;char c[]={‘h’,’e’,’l’,’l’,’o’}; c==s这个是不存在的，==两边类型不同，t.equals(c)这个语句在anObject instanceof String这步判断不会通过，也就是cha[] 压根不能与String相比较，类型不是相同的。返回false。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、静态成员变量或静态代码块&amp;gt;mian方法&amp;gt;非静态成员变量或非静态代码块&amp;gt;构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;静态方法或静态块会比构造方法（包括父类的构造函数）先加载，且只加载一次。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test{
     public Test(){
          System.out.println(&quot;I'm 构造器&quot;);
     }
     static{
          System.out.println(&quot;I'm static&quot;);
     }
}
result：
I'm static
I'm 构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、String的replaceAll方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) 
	+ &quot;MyClass.class&quot;;
System.out.println(classFile);
result：
/////////MyClass.class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/”。如果想替换的只是”.”，那么要写成”\.”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、ry-catch-finally&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int func (){
    try{
        return 1;
    }catch (Exception e){
        return 2;
    }finally{
        return 3;
    }
}
result：
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Try catch finally获取异常错误的结构，try中没有异常时，但是有return等跳转语句，这样会引发程序控制流离开当前的try，即在return语句执行之后返回之前去完成finally中资源的释放。 由于代码中的finally中有return语句，将try中的return语句覆盖，程序直接跳出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、匿名内部类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;匿名内部类也就是没有名字的内部类。&lt;/p&gt;

&lt;p&gt;正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写
但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。&lt;/p&gt;

&lt;p&gt;实例1:不使用匿名内部类来实现抽象方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Person {
    public abstract void eat();
}
class Child extends Person {
    public void eat() {
        System.out.println(&quot;eat something&quot;);
    }
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}
运行结果：eat something
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用。&lt;/p&gt;

&lt;p&gt;但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？&lt;/p&gt;

&lt;p&gt;这个时候就引入了匿名内部类。&lt;/p&gt;

&lt;p&gt;实例2：匿名内部类的基本实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Person {
    public abstract void eat();
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}
运行结果：eat something
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，我们直接将抽象类Person中的方法在大括号中实现了。&lt;/p&gt;

&lt;p&gt;这样便可以省略一个类的书写。&lt;/p&gt;

&lt;p&gt;并且，匿名内部类还能用于接口上。&lt;/p&gt;

&lt;p&gt;实例3：在接口上使用匿名内部类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Person {
    public void eat();
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}
运行结果：eat something
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现。&lt;/p&gt;

&lt;p&gt;最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口。&lt;/p&gt;

&lt;p&gt;实例4：Thread类的匿名内部类实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i &amp;lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        t.start();
    }
}
运行结果：1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实例5：Runnable接口的匿名内部类实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i &amp;lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}
运行结果：1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;8、Integer等的比较&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer i01 = 59;
int i02 = 59;
Integer i03 = Integer.valueof(59);
Integer i04 = new Integer(59);

i01 == i02//true
i01 == i03//true
i03 == i04//false
i03 == i04//true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Byte,Short,Integer,Long,Character这5种整型的包装类在对应值小于等于127并且大于等于-128时会使用常量池，因为他们至占用一个字节(-128~127);超出这个范围将会返回一个新的包装类对象。&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

public static Long valueOf(long l) {
    final int offset = 128;
    if (l &amp;gt;= -128 &amp;amp;&amp;amp; l &amp;lt;= 127) { // will cache
        return LongCache.cache[(int)l + offset];
    }
    return new Long(l);
}

public static Short valueOf(short s) {
    final int offset = 128;
    int sAsInt = s;
    if (sAsInt &amp;gt;= -128 &amp;amp;&amp;amp; sAsInt &amp;lt;= 127) { // must cache
        return ShortCache.cache[sAsInt + offset];
    }
    return new Short(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {

    Integer a = 127;
    Integer b = 127;

    Integer c = 128;
    Integer d = 128;

    System.out.println(a == b);//true
    System.out.println(c == d);//false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：int和Integer(只要值相等，无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、Spring的事务传播特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PROPAGATION_required–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;/p&gt;

&lt;p&gt;PROPAGATION_supports–支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;/p&gt;

&lt;p&gt;PROPAGATION_mandatory–支持当前事务，如果当前没有事务，就抛出异常。&lt;/p&gt;

&lt;p&gt;PROPAGATION_requires _new–新建事务，如果当前存在事务，把当前事务挂起。&lt;/p&gt;

&lt;p&gt;PROPAGATION_not _supported–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/p&gt;

&lt;p&gt;PROPAGATION_never–以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10、i++与++i&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Inc {
    public static void main(String[] args) {
       Inc inc = new Inc();
       int i = 0;
       inc.fermin(i); //查看知识点1
       i= i ++;
       System.out.println(i);  //0，这个结果是不是很意外
    }
    void fermin(int i){
       i++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Java使用了中间缓存变量机制：&lt;/p&gt;

&lt;p&gt;i=i++;等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;temp=i； (等号右边的i)
i=i+1;      (等号右边的i)
i=temp;   (等号左边的i)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而i=++i;则等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i=i+1;
temp=i;
i=temp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但如果把“i= i ++; ”改为“i++”，结果会是1。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Spike
{
    public static void main(String[] args)
    {
        Counter a = new Counter();
        System.out.println(a.increment());
        System.out.println(a.anotherIncrement());
        Counter b = new Counter();
        System.out.println(b.increment());
    }
}
class Counter
{
    private static int count = 0;
    public int increment()
    {
        return count++;
    }
    public int anotherIncrement()
    {
        return ++count;
    }
}
result：
0 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;increment()方法返回当前count值，然后count增加1&lt;/p&gt;

&lt;p&gt;antoherIncrement()方法让count增加1，然后返回count值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11、null&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main17{
  private static void testMethod(){
        System.out.println(&quot;testMethod&quot;);
   }
    public static void main(String args[]) {
      ((Main17)null).testMethod();
    }
}
result：
testMethod
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Java中，null是一个关键字，不是对象，也不是Objcet的实例，它用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。&lt;/p&gt;

&lt;p&gt;比如：int a = null;是错误的。Ojbect o = null是正确的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12、类方法、类变量和实例方法、实例变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用static修饰的方法和变量是类方法、类变量，可以直接用类名.的方法来调用；&lt;/p&gt;

&lt;p&gt;没有用static修饰的方法和变量就属于实例方法、实例变量，必须实例化类之后用实例化对象才能调用。在类方法中调用实例变量会报错，在实例方法中调用实例变量则没有问题。&lt;/p&gt;

&lt;p&gt;由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;类方法中不能引用对象变量；&lt;/li&gt;
  &lt;li&gt;类方法中不能调用类的对象方法；&lt;/li&gt;
  &lt;li&gt;在类方法中不能使用super、this关键字。&lt;/li&gt;
  &lt;li&gt;类方法不能被覆盖。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果违反这些限制，就会导致程序编译错误。&lt;/p&gt;

&lt;p&gt;与类方法相比，对象方法几乎没有什么限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象方法中可以引用对象变量，也可以引用类变量；&lt;/li&gt;
  &lt;li&gt;对象方法中可以调用类方法；&lt;/li&gt;
  &lt;li&gt;对象方法中可以使用super、this关键字。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;13、Collection与Collections的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。&lt;/p&gt;

&lt;p&gt;Collection &lt;br /&gt;
├List &lt;br /&gt;
│├LinkedList &lt;br /&gt;
│├ArrayList &lt;br /&gt;
│└Vector &lt;br /&gt;
│　└Stack &lt;br /&gt;
└Set&lt;br /&gt;
│　└HashSet&lt;/p&gt;

&lt;p&gt;└Queue&lt;/p&gt;

&lt;p&gt;java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，因为内部的构造函数被私有化了就像一个工具类，服务于Java的Collection框架。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14、super()与this()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。&lt;/p&gt;

&lt;p&gt;2）super()和this()类似,区别是，super从子类中调用父类的构造方法，this()在同一类内调用其它方法。&lt;/p&gt;

&lt;p&gt;3）super()和this()均需放在构造方法内第一行，既然两个都要放在第一行，那么两个就不可能同时存在一个构造函数里。&lt;/p&gt;

&lt;p&gt;4）尽管可以用this调用一个构造器，但却不能调用两个。&lt;/p&gt;

&lt;p&gt;5）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。&lt;/p&gt;

&lt;p&gt;6）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main17{
    public Main17(){
        super();
        System.out.println(&quot;1&quot;);
    }
    public Main17(int a){
        this();
        System.out.println(a);
    }
    public Main17(int a, String s){
        this(a);
        System.out.println(s+a);
    }
    public static void main(String[] args) {
        Main17 main17 = new Main17(2,&quot;end:&quot;);
    }
}
result：
1
2
end:2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 11 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/06/11/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E6%89%AB%E7%9B%B2.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/06/11/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E6%89%AB%E7%9B%B2.html</guid>
        
        <category>java</category>
        
        <category>知识点</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JVM-垃圾收集器机制</title>
        <description>&lt;h2 id=&quot;引文&quot;&gt;&lt;strong&gt;引文&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Java GC主要可以由三个问题展开来讲&lt;/p&gt;

&lt;p&gt;1、哪些内存需要回收&lt;/p&gt;

&lt;p&gt;2、什么时候回收&lt;/p&gt;

&lt;p&gt;3、怎样回收&lt;/p&gt;

&lt;p&gt;这三个问题讲清楚后，至少在脑海里对Java GC有了一个比较清晰的理解，那接下来我们就一个个攻克这三个问题。&lt;/p&gt;

&lt;h2 id=&quot;1哪些内存需要回收&quot;&gt;&lt;strong&gt;1、哪些内存需要回收&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;就Java内存运行时区域来说，线程私有的程序计数器、虚拟机栈和本地方法栈随线程生而生，随线程亡而亡，因此这几个区域的内存分配和回收具备确定性，也就不需要过多考虑回收的问题，因为方法体结束或线程结束时，内存自然就跟着回收了。我们需要考虑的是线程共享的方法区和Java堆。&lt;/p&gt;

&lt;h2 id=&quot;2什么时候回收&quot;&gt;&lt;strong&gt;2、什么时候回收&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;下图是这一节的简介图
&lt;img title=&quot;死磕JVM-垃圾收集器机制_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/5922a76900018eae14500956.png&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“什么时候回收”这个问题对于&lt;strong&gt;Java堆&lt;/strong&gt;的直接的回答就是当对象死亡的时候，那对象什么死亡或者如何来标记一个对象是死是活呢？Java GC中有两种标志算法：引用计数算法和可达性分析算法。&lt;/p&gt;

&lt;h3 id=&quot;21-引用计数算法&quot;&gt;&lt;strong&gt;2.1 引用计数算法&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;算法思想：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减1。但触发一次GC的时候，对象的计数器的值为0的对象就说明该对象不可以再使用，可以被回收。&lt;/p&gt;

&lt;p&gt;这种标记的算法很简单高效，但就像&lt;a href=&quot;https://zhoum1118.github.io/javascript/2017/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.html&quot;&gt;《死磕JavaScript-垃圾收集机制》&lt;/a&gt;中引用计数算法存在同样的弊端：相互循环引用。简单说就是对象A保有对象B的引用，同时对象B也保有对象A的引用，那么这两个对象的引用计数在任何时候都不会为0，也就是不会被GC回收。&lt;/p&gt;

&lt;h3 id=&quot;22-可达性分析算法&quot;&gt;&lt;strong&gt;2.2 可达性分析算法&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;算法思想：通过一系列的“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径为引用链，如果一个对象到每个GC Roots都不存在引用链，也即是说从GC Roots到这个对象不可达，那么就说明这个对象是死亡的，可以被GC回收的对象。&lt;/p&gt;

&lt;p&gt;在Java语言中，可以被当做GC Roots的对象有：&lt;/p&gt;

&lt;p&gt;1）虚拟机栈的本地变量表中的引用对象&lt;/p&gt;

&lt;p&gt;2）本地方法栈中引用的对象&lt;/p&gt;

&lt;p&gt;3）方法区中类静态属性引用对象&lt;/p&gt;

&lt;p&gt;4）方法区中常量引用对象&lt;/p&gt;

&lt;h3 id=&quot;23-引用的分类&quot;&gt;&lt;strong&gt;2.3 引用的分类&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在Java1.2之前，对象只有被引用和未被引用两种状态，对象在未被引用的情况下就会在下一次触发GC的时候被GC回收，但我们有些对象当前可能没有被引用，但它可能经常被引用，那么在这个时刻由于它没有被引用则被GC回收了，在下次被重新引用的时候又需要加载进来，多次这样的操作后效率肯定是不高的，那么为了避免这种情况，在Java1.2之后，我们将引用分为4种。&lt;/p&gt;

&lt;h4 id=&quot;231-强引用&quot;&gt;&lt;strong&gt;2.3.1 强引用&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这是普遍存在的一种引用，比如“Object obj = new Object()”，只要强引用存在，GC就不会回收这类引用的对象。&lt;/p&gt;

&lt;h4 id=&quot;232-软引用-softreference&quot;&gt;&lt;strong&gt;2.3.2 软引用 SoftReference&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这是一种有用但非必需的对象，只有当内存不够用的时候，在抛出内存溢出之前才会将它列入GC回收的范围中（也就是说如果内存够用，这种引用的对象不会被列入GC回收的范围），只有在GC回收掉这些引用对象后内存还是不够用的情况下才会抛出内存溢出异常。&lt;/p&gt;

&lt;h4 id=&quot;233-弱引用-weakreference&quot;&gt;&lt;strong&gt;2.3.3 弱引用 WeakReference&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;弱引用关联的对象只能生存到下一次GC之前，当GC工作时，不管内存是否够用都会回收掉这部分对象&lt;/p&gt;

&lt;h4 id=&quot;234-虚引用-phantomreference&quot;&gt;&lt;strong&gt;2.3.4 虚引用 PhantomReference&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这是最弱的一种引用关系，我们无法通过虚引用得到一个对象实例，为一个对象设置虚引用关联的唯一目的是在这个对象被GC的时候收到一个系统通知。&lt;/p&gt;

&lt;p&gt;上面讲的是Java堆的对象的回收，现在来讲下&lt;strong&gt;方法区中的回收&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;方法区（永久代）中的回收主要有两部分内容：废弃常量和无用的类。废弃常量指的是没有任何对象引用了这个常量；无用的类必需满足以下三个条件：&lt;/p&gt;

&lt;p&gt;1）这个类的所有实例都被回收&lt;/p&gt;

&lt;p&gt;2）该类的ClassLoader也被回收&lt;/p&gt;

&lt;p&gt;3）该类对应的java.lang.Class对象没有被引用，即无法通过反射来访问这个类的方法&lt;/p&gt;

&lt;h2 id=&quot;3怎样回收&quot;&gt;&lt;strong&gt;3、怎样回收&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;死磕JVM-垃圾收集器机制_&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/5922a7d80001891c14420992.png&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/22/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%BA%E5%88%B6.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/22/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%BA%E5%88%B6.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>GC</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JVM-如何构造JVM内存溢出和栈溢出</title>
        <description>&lt;p&gt;为什么要写这个题目？我记得我在面试阿里的时候面试官问了我这个问题，当时没能答得很好，只说了些概念的东西，很是心虚，于是下定决心要把这个问题搞懂，现在终于把这个问题怼清楚了，分享给大家，希望你们以后面试问到这种问题能有所准备。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java虚拟机中描述了两种异常：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；&lt;/p&gt;

&lt;p&gt;2、如果在虚拟机中无法申请到足够多的内存空间，将抛出OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;我们都知道Java虚拟机各个内存区域（除了程序计数器）都有发生内存溢出的可能，但到底什么样的操作或程序才会导致内存溢出或栈溢出的异常呢？&lt;/p&gt;

&lt;p&gt;我们分不同的内存区域来解释这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、对于Java堆内存区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java堆中只会产生OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;先搞清楚Java堆内存放的是什么，还不清楚的可以回顾下这篇文章&lt;a href=&quot;https://zhoum1118.github.io/java/2017/05/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html&quot;&gt;《死磕JVM-Java内存模型》&lt;/a&gt;，从这篇文章里我们知道Java堆内存存放的是对象实例，所以原理上只要我们不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，也就是说当Eden区满的时候，GC被触发时，让GC误以为内存中的对象还存活着，那么在对象数量达到最大堆容量限制的时候就会产生内存溢出的异常。如下代码就会产生内存溢出的异常：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;堆溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; args&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; list &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               list&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Exception in thread “main” java.lang.OutOfMemoryError: Java heap space&lt;/p&gt;

  &lt;p&gt;at java.util.Arrays.copyOf(Arrays.java:3210)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.Arrays.copyOf(Arrays.java:3181)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.grow(ArrayList.java:261)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.add(ArrayList.java:458)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at com.intelligentler.jvm.堆溢出.main(堆溢出.java:13)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“Java heap space”提示着产生OutOfMemoryError异常的Java虚拟机的内存区域，也就是Java堆内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何解决发生在Java堆内存的OutOfMemoryError异常呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们要分清楚产生OutOfMemoryError异常的原因是内存泄露还是内存溢出，如果内存中的对象确实都必须存活着而不像上面那样不断地创建对象实例却不使用该对象，则是内存溢出，而像上面代码中的情况则是内存泄露。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果是内存泄露&lt;/strong&gt;，我们可以通过一些内存查看工具来查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的路径与GC Roots相关联并导致GC无法自动回收这些泄露对象，掌握了这些信息，我们就能比较准确地定位出泄露代码的位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果不是内存泄露&lt;/strong&gt;，也就是说内存中的对象确实都还必须存活，那么应该检查虚拟机的堆参数，看看是否还可以将机器物理内存调大，同时在代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、对于虚拟机栈和本地方法栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这一部分内存区域，可能产生OutOfMemoryError异常和StackOverflowError异常。&lt;/p&gt;

&lt;p&gt;如果定义大量的本地变量，增大此方法帧中本地变量表的长度或者设置-Xss参数减少栈内存容量，这两种操作都会抛出StackOverflowError异常。&lt;/p&gt;

&lt;p&gt;如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;栈溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; stackLength &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; addStackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          stackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;++;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          addStackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; args&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;throws&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;栈溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; oom &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;栈溢出();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               oom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;addStackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; e&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;stack length:&quot;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; oom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;stackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; e&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;stack length:18388&lt;/p&gt;

  &lt;p&gt;Exception in thread “main” java.lang.StackOverflowError&lt;/p&gt;

  &lt;p&gt;at com.intelligentler.jvm.栈溢出.addStackLength(栈溢出.java:9)&lt;/p&gt;

  &lt;p&gt;at com.intelligentler.jvm.栈溢出.addStackLength(栈溢出.java:9)&lt;/p&gt;

  &lt;p&gt;at com.intelligentler.jvm.栈溢出.addStackLength(栈溢出.java:9)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，如果在单线程的情况下，无论是栈帧太大还是虚拟机栈容量太小，当内存无法再分配的时候，虚拟机抛出的是StackOverflowError异常。&lt;/p&gt;

&lt;p&gt;如果在多线程下，不断地建立线程可能会产生OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、对于方法区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;方法区中只会产生OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;由于运行时常量池是方法区的一部分，我们可以通过String.intern()方法来构建一个运行时常量池的OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含了一个等于该String对象的字符串，则返回这个String对象，否则，将此String对象包含的字符串添加到常量池中，并返回这个字符串的String对象的引用。如下面代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;方法区溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; args&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; list &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; i &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               list&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;++).&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Exception in thread “main” java.lang.OutOfMemoryError: PermGen space&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.lang.String.intern(Native Method)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PermGen space的全称是Permanent Generation space，是指内存的永久保存区域，也就是说运行时常量池属于方法区（也就是虚拟机永久代）中的一部分。&lt;/p&gt;

&lt;p&gt;另外，方法区是存放Class的相关信息的，运行时如果有大量的类来填满方法区，就会产生OutOfMemoryError异常。&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/19/%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E6%A0%88%E6%BA%A2%E5%87%BA.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/19/%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E6%A0%88%E6%BA%A2%E5%87%BA.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>溢出</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JavaScript-垃圾收集机制</title>
        <description>&lt;p&gt;JavaScript和Java一样具有自动垃圾收集机制。JavaScript的垃圾收集你机制的原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;标记清除：&lt;/strong&gt;这是最常用的垃圾收集方式。原理是：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记—&amp;gt;然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记—&amp;gt;在此之后再被加上标记的变量将被视为准备删除的变量—&amp;gt;最后，垃圾收集器完成内存清除工作，销毁那些带标记的变量并回收它们所占用的内存空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引用计数：&lt;/strong&gt;这是一种不太常见的垃圾收集方式，IE用的就是这种。引用计数是指追踪记录每个值被引用的次数，原理是：当声明一个变量并将一个引用类型值赋给该变量时，则这个值得引用次数初始化为1—&amp;gt;如果同一个值又被赋值给另一个变量，则该值的引用次数加1—&amp;gt;相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值得引用次数减1—&amp;gt;当这个值得引用次数变为0时，说明无需再访问这个变量，可以被垃圾回收机制回收。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/591d135e0001701703930115.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但引用计数存在循环引用的风险，循环引用指的是对象A包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。比如：&lt;/p&gt;

&lt;p&gt;这里例子中，objectA和objectB通过各自的属性相互引用，也就是说，两个对象的引用次数都是2，尽管函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远都不为0。&lt;/p&gt;

&lt;p&gt;IE因为采用了引用计数的垃圾收集而性能低下。&lt;/p&gt;

&lt;p&gt;当然，我们也可以通过解除变量的引用（解除引用）来消除循环引用现象，比如：objectA = null;和objectB = null。&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/javascript/2017/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.html</link>
        <guid isPermaLink="true">http://localhost:4000/javascript/2017/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.html</guid>
        
        <category>JavaScript</category>
        
        <category>垃圾收集</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>死磕JVM-Java虚拟机对象</title>
        <description>&lt;p&gt;上篇文章我们了解了Java虚拟机的内存模型，也知道不同区域的内存都存储的是什么，现在我们进一步来探究内存上存储的数据是怎么创建的，内存大小又是怎么分配的，数据创建成功后怎么被访问的。我们以Java虚拟机中最大的内存块Java堆为例子来探究上面的三个问题。&lt;/p&gt;

&lt;h2 id=&quot;java堆上对象的创建&quot;&gt;&lt;strong&gt;Java堆上对象的创建&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Java虚拟机遇到一条new指令后，首先会去检查要创建的对象能否在常量池中定位到其对应类的符号引用，并且检查这个引用代表的类是否已经被加载、解析和初始化过，如果没有则先进行类加载过程。&lt;/p&gt;

&lt;p&gt;然后就是为这个对象分配内存，最后执行init方法，这样一个可用的对象创建完毕。&lt;/p&gt;
&lt;h2 id=&quot;java堆对象的内存分配&quot;&gt;&lt;strong&gt;Java堆对象的内存分配&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在类加载检查通过之后，虚拟机就会为新生对象分配内存，分配方式因取决于Java堆中内存是否规整而分为“指针碰撞”和“空闲列表”。在Java堆中的内存是规整的情况下，内存分配方式采用“指针碰撞”，反之采用“空闲列表”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;假设Java堆中的内存是绝对规整的&lt;/strong&gt;，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存的方式就是将这个指针往指向空闲空间那边挪动一段与对象大小相等的距离。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;假设Java堆中的内存不是规整的&lt;/strong&gt;，已使用的内存和空闲的内存相互交错，这样就无法进行简单地指针碰撞了，这时候虚拟机会维护一张列表，列表中记录哪些内存块是可用的，在分配内存的时候就从列表中找到一块足够大的空间划分给对象实例，同时更新列表上的记录，这种内存分配的方式叫做“空闲列表”。&lt;/p&gt;

&lt;p&gt;由此我们知道Java堆对象的内存分配策略是由Java堆内存是否规整来决定的，那么Java堆内存是否规整则由GC是否带有压缩整理功能决定的，所以一般在使用Serial、ParNew等带有压缩整理过程的收集器时，系统采用的是“指针碰撞”的分配策略，在使用CMS这种基于Mark-Sweep算法的收集器时，采用的是“空闲列表”的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于Java堆是线程共享的，那么内存的分配在线程并发的情况下如何保证线程安全呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管采用哪种内存分配策略，在多线程下进行Java堆内存分配的时候，可能存在正在给A对象分配内存，但指针还没来得及修改而对象B又使用了原来的指针来分配内存的这种情况。&lt;/p&gt;

&lt;p&gt;有两种解决方案：第一是对分配内存空间的动作进行同步处理以保证操作的原子性，也就是说同一时刻只有一个线程能进行分配内存的操作；第二是把内存分配的操作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）,线程在自己的TLAB中分配内存，只有在TLAB用完了，在分配新的TLAB时才需要同步锁定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;讲完了Java堆对象的内存分配策略，那存储的对象到底存储的是什么呢？对象中都包含哪些内容呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对象在内存中主要存储这三个信息：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;

&lt;p&gt;对象头，存储对象自身的运行时数据：哈希码，GC分代年龄，锁状态标志等。&lt;/p&gt;

&lt;p&gt;实例数据，存储对象真正有效的信息。&lt;/p&gt;

&lt;p&gt;对齐填充，起到占位符的作用，当实例数据部分没有对齐时，就需要对齐填充来补全。&lt;/p&gt;

&lt;h2 id=&quot;java堆对象的访问定位&quot;&gt;&lt;strong&gt;Java堆对象的访问定位&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对象创建并分配好了内存，那么接下来就可以访问对象了，Java程序是通过栈中的reference数据来操作堆上的具体对象，虚拟机提供了两种机制来访问堆中的实例对象：句柄和直接指针。
使用句柄：Java堆中会划分一块区域作为句柄池，Java栈中的本地变量表中的reference数据存储的就是对象的句柄地址，而句柄中则包含的是到对象实例数据的指针和对象类型数据的指针。
&lt;img title=&quot;死磕JVM-Java虚拟机对象_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/591d078d0001d19915940584.png&quot; style=&quot;width:100%&quot; alt=&quot;图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接指针：reference数据存储是的对象的实例数据的引用地址和到对象类型数据的指针。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕JVM-Java虚拟机对象_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/591d079d0001210016240586.png&quot; style=&quot;width:100%&quot; alt=&quot;图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用句柄的好处是Java栈中的本地变量表中的reference数据是相对稳定的，不需要经常变动，比如在执行GC操作时移动对象，这个时候需要改变对象在堆中的地址，在句柄机制中，只需要改动句柄池中的实例数据的指针，而不需要修改reference数据。但缺点是增加了一次指针定位的开销，对于对象访问比较频繁的时候，这种开销累计起来也是很大的，所以对于HotSpot而言，使用的是直接指针的方式。&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/18/Java%E5%A0%86%E4%B8%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/18/Java%E5%A0%86%E4%B8%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>虚拟机对象</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JVM-Java内存模型</title>
        <description>&lt;p&gt;Java虚拟机是Java工程师必学的进阶功课，这段时间开始死磕JVM。今天把JVM的基础知识点Java的内存模型怼清楚，废话不多说，干货走起！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/591a5ed500016f8704170268.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;程序计数器&quot;&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么&lt;/strong&gt;：程序计数器是很小的一块内存空间，它是当前线程所执行的字节码的行号指示器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有什么用：&lt;/strong&gt;解释器通过这个计数器来选取下一条需要执行的字节码指令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;如果线程执行的是Java方法，存储的是正在执行的虚拟机字节码指令的地址；如果是native方法，计数器值为空（undefined）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程私有的：&lt;/strong&gt;多线程是线程轮流切换并分配处理器执行时间片的方式来实现的，在任何确定的时刻，一个处理器（对于多核处理器来说就是一个内核）都只会执行一条线程，所以，为了线程在切换后能恢复到正确的执行位置，每个线程应该独立拥有一个程序计数器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;唯一一个无内存溢出异常的区域。&lt;/p&gt;
&lt;h2 id=&quot;java虚拟机栈&quot;&gt;&lt;strong&gt;Java虚拟机栈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;虚拟机栈是Java方法的内存模型，每一个Java方法从调用到执行完成就对应着一个栈帧在虚拟机栈中的入栈和出栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;每个方法的执行就会创建一个栈帧，这个栈帧会存储这个Java方法的局部变量表，操作数栈，动态链接，方法出口等信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程私有的：&lt;/strong&gt;每个线程所执行的方法可能是不一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;如果线程请求的栈深度&amp;gt;虚拟机允许的深度，抛出栈溢出异常；如果扩展时无法申请到足够的内存，抛出内存溢出异常。&lt;/p&gt;
&lt;h2 id=&quot;本地方法栈&quot;&gt;&lt;strong&gt;本地方法栈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;本地方法栈的作用和虚拟机栈非常像是，只不过本地方法栈是native方法的内存模型，每一个native方法从调用到执行完成就对应着一个栈帧在本地方法栈中的入栈和出栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;同虚拟机栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程私有的：&lt;/strong&gt;同虚拟机栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;同虚拟机栈。&lt;/p&gt;
&lt;h2 id=&quot;java堆&quot;&gt;&lt;strong&gt;Java堆&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：J&lt;/strong&gt;ava堆是Java虚拟机管理的内存中最大的一块，Java堆是在虚拟机启动的时候创建的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;存放对象实例，几乎所有的对象实例都在这个内存区域分配内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程共享的：&lt;/strong&gt;所有的线程都可以访问不同的对象。其实从内存分配的角度来看，线程共享的Java堆可能其实是多个线程私有的分配缓冲区，不同的线程将各自的对象实例放在看似共享的Java堆的各自的缓冲区上，这样划分可以更好的回收内存，也可以更好点分配内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;Java堆可以处于物理上不连续的内存空间上，但逻辑上一定是连续的，在堆中没有内存可以完成对象实例的分配，且无法再扩展时，会抛出内存溢出异常。&lt;/p&gt;
&lt;h2 id=&quot;方法区&quot;&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;和堆一样，是各个线程共享的内存区域。很多人把方法区称为永久代，但是本质上这两个不等价，Java虚拟机将GC分代收集扩展至方法区，使用永久代来实现方法区，这样GC收集器就能像管理Java堆一样管理方法区而不需要再写一套GC收集来管理方法区。当然在方法区里也可以设置不进行GC收集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;已被虚拟机加载的类信息，类常量，类的静态变量，即时编译器编译后的代码等。运行时常量池也是方法区的一部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程共享的：&lt;/strong&gt;各个线程都可以访问虚拟机加载的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;内存溢出异常。&lt;/p&gt;
&lt;h2 id=&quot;直接内存&quot;&gt;&lt;strong&gt;直接内存&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机定义的内存区域，但也经常被使用。JDK1.4加入了NIO类，一种基于通道与缓冲区的新I/O方式，NIO可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为直接内存的引用来操作直接内存，这样可以避免在Java堆和native堆来回复制数据，从而提高了性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;受机器总内存的影响，会出现内存溢出异常。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>内存模型</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JavaScript-函数按值传递参数</title>
        <description>&lt;p&gt;早起打卡，今天死磕函数按值传递参数，干货走起……&lt;/p&gt;

&lt;p&gt;基本类型的变量传递是将值A复制一份给被传递的变量B，两个变量值得变化是互不干扰的；而引用类型的变量传递是将引用类型变量A的引用传递给被传递的变量B，这个B的变化会反映到A上。例如：&lt;/p&gt;

&lt;p&gt;例1：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; addTen&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     num &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; num&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; count &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; result &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; addTen&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//20&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//30&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;javaScript&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; language &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//javaScript&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两种函数的值传递是比较好理解的，在例1中，num其实是addTen的局部变量，在调用addTen函数的时候，count将值复制给了局部变量num，虽然函数内部num的值加了10，但是这一变化不会影响给函数外部的count变量。复制前后栈的变化图如下：
&lt;img title=&quot;死磕JavaScript-函数按值传递参数_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59165ced00011b7f19201338.jpg&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;
在例2中你可能有所疑惑，因为这看起来就像是引用传递啊，不像是标题所说的函数按值传递，这里language的引用复制传递给了obj局部变量，所以是引用传递呀。那我们来看下一个例子：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;javaScript&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;new JavaScript&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; language &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//javaScript&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果说language是按引用传递的，那么language就会自动被修改为指向其name属性值为“new JavaScript”的新对象，但结果确实“javaScript”，我们看下复制前后的栈和堆的变化图就能更清楚了。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕JavaScript-函数按值传递参数_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59165d240001d2e019201756.jpg&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这下应该能明白了，也就是说这里的函数按值传递中的“值”指的是栈中的值，所以对于引用类型，是将栈中的language的值复制到obj中，也就是说这两个值对应的堆地址是一样的，其在堆中对应的对象是一样的，对obj中的改变对反映到language中，但如果改变了obj的堆地址那么obj和language就没什么关系了。&lt;/p&gt;

</description>
        <pubDate>Sun, 14 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/javascript/2017/05/14/%E5%87%BD%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.html</link>
        <guid isPermaLink="true">http://localhost:4000/javascript/2017/05/14/%E5%87%BD%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.html</guid>
        
        <category>JavaScript</category>
        
        <category>函数</category>
        
        <category>传递参数</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>死磕JavaScript-松散类型、js变量存储模型、变量提升</title>
        <description>&lt;p&gt;好久没来慕课网学习了，上研究生之后，发现突然又变回学生后对自己的要求也松很多，开始到处旅游，做些没计划的事情，也很少写技术博客了，最近静下心来开始研究底层的东西，以后就在这写了，希望能死磕自己，坚持下去。好了，干货走起……&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;什么是松散类型&lt;/li&gt;
  &lt;li&gt;JavaScript两种变量类型的内存模型&lt;/li&gt;
  &lt;li&gt;预加载&lt;/li&gt;
  &lt;li&gt;变量提升&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;javascript里的变量和其他语言有很大的不同，javascript的变量是一个松散的类型，松散类型变量的特点是变量定义时候不需要指定变量的类型，变量在运行时候可以随便改变数据的类型，但是这种特性并不代表javascript变量没有类型，当变量类型被确定后javascript的变量也是有类型的。&lt;/p&gt;

&lt;p&gt;但是在现实中，很多程序员把javascript松散类型理解为了javascript变量是可以随意定义即你可以不用var定义，也可以使用var定义，其实在javascript语言里变量定义没有使用var，变量必须有赋值操作，只有赋值操作的变量是赋予给window，这其实是javascript语言设计者提升javascript安全性的一个做法。&lt;/p&gt;

&lt;p&gt;此外javascript语言的松散类型的特点以及运行时候随时更改变量类型的特点，很多程序员会认为javascript变量的定义是在运行期进行的，更有甚者有些人认为javascript代码只有运行期，其实这种理解是错误的，javascript代码在运行前还有一个过程就是：预加载，预加载的目的是要事先构造运行环境例如全局环境，函数运行环境，还要构造作用域链，而环境和作用域的构造的核心内容就是指定好变量属于哪个范畴，因此在javascript语言里变量的定义是在预加载完成而非在运行时期。&lt;/p&gt;

&lt;p&gt;讲一个例子来讲解：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; a &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; test&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
    console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//undefined&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; a &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
    console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//2&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
test&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个令人诧异的结果，为什么第一个弹出框显示的是undefined，而不是1呢？这种疑惑的原理我描述如下：&lt;/p&gt;

&lt;p&gt;一个页面里直接定义在script标签下的变量是全局变量即属于window对象的变量，按照javascript作用域链的原理，当一个变量在当前作用域下找不到该变量的定义，那么javascript引擎就会沿着作用域链往上找直到在全局作用域里查找，按上面的代码所示，虽然函数内部重新定义了变量的值，但是内部定义之前函数使用了该变量，那么按照作用域链的原理在函数内部变量定义之前使用该变量，javascript引擎应该会在全局作用域里找到变量定义，而实际情况却是变量未定义，这到底是怎么回事呢？&lt;/p&gt;

&lt;p&gt;这里我要先讲一个知识点，就是&lt;strong&gt;JavaScript的变量存储模型&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;javascript语言和java语言一样变量是分为两种类型：基本数据类型和引用类型。基本类型是指：Undefined、Null、Boolean、Number和String；而引用类型是指对象，所以javascript的对象指的是引用类型。但是实际开发里如果我们对基本类型和引用类型的区别不是很清晰，就会碰到我们很多不能理解的问题，下面我们来看看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; str &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Sharpxiajun&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;;
 var num = 1;
 var xxx;
 console.log(str);//运行结果：sharpxiajun
 console.log(num);//运行结果：1
 console.log(xxx);//运行结果：undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们使用引用类型时候，结果就和上面完全不同了，大家请看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; obj1 &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
obj1&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;obj1 name”;
console.log(obj1.name);// 运行结果：obj1 name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Javascript里的基本变量是存放在栈区的（栈区指内存里的栈内存），它的存储结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/591552cf0001746703950149.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;javascript里引用变量的存储就比基本类型存储要复杂多，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，如下图所示：
&lt;img src=&quot;http://img.mukewang.com/591552f20001700e05650292.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;理解基本类型变量和引用类型变量的存储结构后，结合上面开始讲的预加载的知识点，我们就能分析出开始那个例子的深层原因了。&lt;/p&gt;

&lt;p&gt;引子里的代码在函数的局部作用域下变量a被重新定义了，在预加载时候a的作用域范围也就被框定了，a变量不再属于全局变量，而是属于函数作用域，只不过赋值操作是在运行期执行（这就是为什么javascript语言在运行时候会改变变量的类型，因为赋值操作是在运行期进行的），所以第一次使用a变量时候，a变量在局部作用域里没有被赋值，只有栈区的标示名称，因此结果就是undefined了。（这也就是js里的变量提升的原理）&lt;/p&gt;

&lt;p&gt;不过赋值操作也不是完全不对预加载产生影响，预加载时候javascript引擎会扫描所有代码，但不会运行它，当预加载扫描到了赋值操作，但是赋值操作的变量有没有被var定义，那么该变量就会被赋予全局变量即window对象。&lt;/p&gt;
</description>
        <pubDate>Fri, 12 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/javascript/2017/05/12/%E6%9D%BE%E6%95%A3%E7%B1%BB%E5%9E%8B-js%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html</link>
        <guid isPermaLink="true">http://localhost:4000/javascript/2017/05/12/%E6%9D%BE%E6%95%A3%E7%B1%BB%E5%9E%8B-js%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html</guid>
        
        <category>JavaScript</category>
        
        <category>松散类型</category>
        
        <category>变量存储模型</category>
        
        <category>变量提升</category>
        
        
        <category>Javascript</category>
        
      </item>
    
  </channel>
</rss>
