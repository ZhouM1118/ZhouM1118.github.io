<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>周明的技术博客</title>
    <description>Jack's blog,use Jekyll and github pages.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 25 Oct 2017 18:00:17 +0800</pubDate>
    <lastBuildDate>Wed, 25 Oct 2017 18:00:17 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>论文笔记-识别议论文中论证性篇章结构</title>
        <description>&lt;p&gt;现在看这种类型的英文论文开始有点感觉了，大部分术语积累的差不多之后看论文确实相对刚开始看要快一些，一遍过下来也掌握的信息也比较多，如果你和我一样都在看英文论文的道路上挣扎，建议你看下这篇帖子的内容，&lt;a href=&quot;https://www.zhihu.com/question/27375221&quot;&gt;如何看懂英文文献？&lt;/a&gt; 还是有些帮助的，也欢迎你留言，我们一起交流，共同进步。&lt;/p&gt;

&lt;p&gt;本文主要研究的是议论文中论证部分的篇章结构分析，研究工作分两部分，第一部分为议论文中论证性篇章结构类别识别，第二部分为在第一部分的论证类别识别的基础上对论证关系进行研究。论文将数据集中的文章句子的类别分为：主论点（major claim）、分论点（claim）、论据（premise）以及非论证部分（none），在主论点、分论点以及论据之间有两种论证关系：支持（support）与反对（attack）。数据集来自Stab和Gurevych在2014年编译的议论文语料库。表1表示的是语料库中各种类别的分布情况，语料库包含90个主论点（基本上是每篇文章包含一个主论点），429个分论点和1033个论据。&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表1 数据集中类别分布情况&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59ef275700017f2b07600078.png&quot; alt=&quot;数据集中类别分布情况&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-篇章结构类别识别&quot;&gt;&lt;strong&gt;1 篇章结构类别识别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;论文使用Weka数据挖掘软件中的分类器进行分类，使用DKPro框架中的Stanford POS-Tagger和Parser进行数据预处理，使用使DKPro-TC文本分类框架来提取论文句子的特征。&lt;/p&gt;

&lt;h2 id=&quot;11-特征提取&quot;&gt;&lt;strong&gt;1.1 特征提取&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;111-结构特征&quot;&gt;1.1.1 结构特征&lt;/h3&gt;

&lt;p&gt;这部分主要提取的是篇章单元的词统计特征、位置特征以及标点符号特征。&lt;/p&gt;

&lt;p&gt;词统计特征，Biran and Rambow在2011年发现论据的平均长度比其他句子要长，所以将篇章单元所覆盖句子中单词的数量加入到特征集中，除此之外，特征集还包含：当前句子的前一个和后一个篇章单元所包含词的数量，篇章单元的覆盖句子的词占篇章单元单词的比例。&lt;/p&gt;

&lt;p&gt;位置特征，四个Boolean特征：篇章单元是否出现在文章的介绍（introduction）或结论（conclusion）中，是否出现在某一段的第一句或最后一句；一个数值特征：篇章单元中所覆盖句子在文章中的位置，主论点经常出现在文章的介绍（introduction）或结论（conclusion）中，段落也经常是以论点作为开始或结束。本论文认为这个特征能够很好的预测（主/分）论点。&lt;/p&gt;

&lt;p&gt;标点符号特征：篇章单元所覆盖句子中的标点符号数量；当前句子的前一个和后一个篇章单元的标点符号的数量；句子是否以问号结束。&lt;/p&gt;

&lt;h3 id=&quot;112-词汇特征&quot;&gt;1.1.2 词汇特征&lt;/h3&gt;

&lt;p&gt;这部分的特征主要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Stanford POS-Tagger&lt;/code&gt;来进行预处理阶段的词性标注，词汇特征主要包括：动词（verbs）、副词（adverbs）和情态动词（modals），常用的技术有：词类区分（POS: Part-of-Speech tagging）和命名实体识别（NE: named entity tagging）。&lt;/p&gt;

&lt;p&gt;动词和副词在识别篇章单元上有重要的作用，比如，某些动词（believe、think、agree等）标志着一个主论点的出现，某些副词（also、often、really等）就可能是论据的表达方式，某些情态动词（should、could等）通常用来预示分论点的出现。&lt;/p&gt;

&lt;h3 id=&quot;113-句法特征&quot;&gt;1.1.3 句法特征&lt;/h3&gt;

&lt;p&gt;这部分主要提取：篇章单元的每个句子中包含子从句的数量特征；分析树（parse tree）的深度；分析树中的产生式（production rules），NP、VP、PP是名词、动词、介词短语（短语级别）；N、V、P分别是名词、动词、介词；每个篇章单元中句子的主要动词的时态，论据一般使用过去时，而论点一般使用现在时。&lt;/p&gt;

&lt;h3 id=&quot;114-指示词特征&quot;&gt;1.1.4 指示词特征&lt;/h3&gt;

&lt;p&gt;论点经常有这些指示词：therefore、thus、consequently等引出，然而论据可能包含这些词：because、reason、furthermore等。本论文使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Penn Discourse Treebank 2.0 Annotation Manual&lt;/code&gt;来收集类似上面指示词，剔除掉与识别论证结构无关的指示词，最终收集到55个指示词。&lt;/p&gt;

&lt;p&gt;除此之外还定义了5个Boolean特征来表示是否包含这五个第一人称：I，me，my，mine，myself。本论文认为这些特征与主论点有很强的关联性，因为这些词的出现常常表达了作者的个人立场。&lt;/p&gt;

&lt;h3 id=&quot;115-上下文特征&quot;&gt;1.1.5 上下文特征&lt;/h3&gt;

&lt;p&gt;论文认为一个论点的出现，后面往往跟着有论据。所以会从篇章单位的上下句子提取相关特征来表述上下文特征。&lt;/p&gt;

&lt;h2 id=&quot;12-篇章单元分类&quot;&gt;&lt;strong&gt;1.2 篇章单元分类&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;本论文使用SVM、贝叶斯、C4.5决策树以及随机森林四种分类方法，使用信息增益（Information Gain）来判断某些特征能够为分类系统带来多少信息，带来的信息越多，该特征越重要，也就是对一个特征而言，分类系统有它和没它时信息量将发生变化，而前后信息量的差值就是这个特征给系统带来的信息量，信息量向正方向增长越大则表明该特征越能影响分类系统的效果。以信息增益为依据选取前100个特征。结果表明，使用SVM分类方法效果最好，虽然贝叶斯方法的准确度比SVM的低，但效率更高。SVM分类结果对比表如表2所示：&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表2 SVM分类结果对比表&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/59ef278400012b1906660340.png&quot; alt=&quot;SVM分类结果对比表&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同特征对篇章单元的识别结果的影响如表3所示：&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表3 不同特征对篇章单元的识别结果影响对比表&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/59ef27a500010cf807580242.png&quot; alt=&quot;不同特征对篇章单元的识别结果影响对比表&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;13-结果分析&quot;&gt;&lt;strong&gt;1.3 结果分析&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;有趣的是指示词特征对识别非论证部分（none）并没有用，但在识别主论点（major claim）、分论点（claim）、论据（premise）上表现良好，一个主要的原因可能是指示词并不是对篇章单元的每个句子产生作用，有些指示词具有一词多义，比如since，可能表示时间的“自从”，也可能表示的是因果的“因为”。&lt;/p&gt;

&lt;p&gt;分类系统对识别论证部分和非论证部分有很好的效果，但在识别主论点（major claims）与分论点（claims）上的效果一般，结果矩阵如表4所示：&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表4 结果分析矩阵&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/59ef27bf00018ade05340218.png&quot; alt=&quot;结果分析矩阵&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MC=Major Claim，Cl=Claim，Pr=Premise，No=None，横轴表示实际类别，纵轴表示分类预测的类别。&lt;/p&gt;

&lt;p&gt;从上面的结果分析矩阵可以得出，总共有193个分论点（Claims）被错误分类为论据（Premise）。论文对这个现象的解释是：许多的分论点出现在第一段，且含有first(ly)、second(ly)等指示单词，这可能表示的是分论点对主论点的支持或解释，但往往会被分类器认为是主论点的论据。为解决这个问题，论文作者提出了一个可能的解决方法，即定义指示单词的位置特征或消除指示单词特征作用。&lt;/p&gt;

&lt;p&gt;有些包含一个完整的句子且不包含指示单词的分论点也可能被错误分类，比如，“Competition helps in improvement and evolution”作为一个分论点可能被错误分类为论据。实际上，如果不知道作者的写作含义，可能连人也分不清是什么类别，解决这类问题的方法是，特征集中加入更多复杂的上下文特征。&lt;/p&gt;

&lt;h1 id=&quot;2-论证关系识别&quot;&gt;&lt;strong&gt;2 论证关系识别&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;21-什么是论证关系&quot;&gt;&lt;strong&gt;2.1 什么是论证关系？&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;“(1) Museums and art galleries provide a better understanding about arts than Internet. (2) In most museums and art galleries, detailed descriptions in terms of the background, history and author are provided. (3) Seeing an artwork online is not the same as watching it with our own eyes, as (4) the picture online does not show the texture or three-dimensional structure of the art, which is important to study.”
在上面这段英文中，加粗部分（1）为一个论点（Claims），斜体部分（2，3，4）为论据（Premise），论据（2）和（3）支持/加强论点（1），而论据（4）支持/加强论据（3），所以这段英文中有3对支持/加强（support）论证关系（2，1）、（3，1）和（4，3）。&lt;/p&gt;

&lt;p&gt;本论文将论证关系分为Support和Non-support，且不考虑分论点与主论点之间的论证关系，因为这是唯一个跨越段落的论证关系，在6330对（pair）论证关系中，Support和Non-support分布情况如下表所示：&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表5 Support和Non-support分布情况表&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片5=&quot;&quot; src=&quot;http://img.mukewang.com/59ef27e20001369a04640076.png&quot; alt=&quot;Support和Non-support分布情况表&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-特征提取&quot;&gt;&lt;strong&gt;2.2 特征提取&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;221-结构特征&quot;&gt;2.2.1 结构特征&lt;/h3&gt;

&lt;p&gt;三个基于词统计特征：源单元的词数量；目标单元的词数量；源单元和目标单元的词数量绝对差；
三个基于标点符号统计特征：源单元的标点符号数量；目标单元的标点符号数量；源单元和目标单元的标点符号数量绝对差；
九个基于位置的结构特征：源单元与目标单元所覆盖句子在文章中的位置（2）；源单元与目标单元所覆盖句子是否处于段落的开始或结尾（4）；目标单元是否出现在源单元之前（1）；源单元与目标单元所覆盖句子之间的距离（1）；源单元与目标单元是否在同一个句子中（1）。&lt;/p&gt;

&lt;h3 id=&quot;222-词汇特征&quot;&gt;2.2.2 词汇特征&lt;/h3&gt;

&lt;p&gt;词汇特征主要包括单词对（word pairs）、第一个单词、情态动词、两个篇章单元相同术语的数量。论文认为篇章单元的第一个单词包含重要的信息。&lt;/p&gt;

&lt;h3 id=&quot;223-句法特征&quot;&gt;2.2.3 句法特征&lt;/h3&gt;

&lt;p&gt;同篇章结构类别识别的句法特征。&lt;/p&gt;

&lt;h3 id=&quot;224-指示词特征&quot;&gt;2.2.4 指示词特征&lt;/h3&gt;

&lt;p&gt;同篇章结构类别识别的指示词特征。&lt;/p&gt;

&lt;h3 id=&quot;225-篇章单元类型特征&quot;&gt;2.2.5 篇章单元类型特征&lt;/h3&gt;

&lt;p&gt;篇章单元类型（major claim，claim，premise）特征对两个篇章单元的论证关系识别有重要指示作用。&lt;/p&gt;

&lt;h2 id=&quot;23-分类结果分析&quot;&gt;&lt;strong&gt;2.3 分类结果分析&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;同样是SVM的分类效果最好。&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表6 论证关系分类效果表&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片6=&quot;&quot; src=&quot;http://img.mukewang.com/59ef280e0001201d06660266.png&quot; alt=&quot;论证关系分类效果表&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;表6 论证关系分类效果表&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-识别议论文中论证性篇章结构_&quot; 图片7=&quot;&quot; src=&quot;http://img.mukewang.com/59ef28200001c04d06140224.png&quot; alt=&quot;论证关系分类效果表&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/deeplearning/2017/10/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E8%AF%86%E5%88%AB%E8%AE%AE%E8%AE%BA%E6%96%87%E4%B8%AD%E8%AE%BA%E8%AF%81%E6%80%A7%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84.html</link>
        <guid isPermaLink="true">http://localhost:4000/deeplearning/2017/10/24/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E8%AF%86%E5%88%AB%E8%AE%AE%E8%AE%BA%E6%96%87%E4%B8%AD%E8%AE%BA%E8%AF%81%E6%80%A7%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84.html</guid>
        
        <category>论文笔记</category>
        
        <category>议论文</category>
        
        <category>论证性</category>
        
        <category>篇章结构识别</category>
        
        
        <category>Deeplearning</category>
        
      </item>
    
      <item>
        <title>论文笔记-基于全局和局部内聚的学生论文中的篇章结构识别</title>
        <description>&lt;p&gt;找技术路线很头大啊，明天还要做一个技术分享（压力山大）…这篇论文《Discourse Element Identification in Student Essays based on Global and Local Cohesion》的训练集是中国学生写的中文文章，虽然对我研究的托福雅思的英文议论文不同，但我想思路和技术方法可能是有一定借鉴作用的。&lt;/p&gt;

&lt;p&gt;论文主要是通过探索整篇文章中句子与句子之间关系的内聚性来分析文章的篇章结构。通过这种方式能更好的识别Thesis、Main idea和Conclusion标签类别。论文将篇章结构的识别作为一个分类问题来看待，文章中的每个句子使用分类器（朴树贝叶斯、决策树和SVM等）独立分类，论文主要使用SVM模型和基于线性链的条件随机场模型（CRF）来对句子进行篇章结构标签分类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 基本特征：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;位置特征&lt;/li&gt;
  &lt;li&gt;指示单词特征：in my opinion，in conclusion，should，hope等&lt;/li&gt;
  &lt;li&gt;非文本特征：单词的长度，段落句子个数，标点符号特征等&lt;/li&gt;
  &lt;li&gt;主题和提示信息特征：对每个句子提取与文章标题和提示信息的余弦相似性的特征&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2 内聚链&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里主要挖掘关系与词汇的内聚特征，主要构建的是在文章所有句子范围内单词的身份链（identity chains）和词汇链（lexical chains）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;身份链（identity chains）：通过挖掘每个句子中的人物名称，第一、二、三人称等特征，将同属一类身份的部分组成一个身份链；&lt;/li&gt;
  &lt;li&gt;词汇链（lexical chains）：通过挖掘每个句子中不同词汇的重复，单词的同义表达等特征，将同属一类单词的部分组成一个词汇链。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3 全局链（global chains）与局部链（local chains）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于第二部分的内聚链来构造一个句子链（Sentence Chains），一个句子链包含那些相似的身份链和词汇链。&lt;/p&gt;

&lt;p&gt;局部链是那些只包含单一子主题的句子链，全局链那些只包含多个子主题的句子链。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;基于全局和局部内聚的学生论文中的篇章结构识别_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59eb38b30001999f09180520.png&quot; alt=&quot;图片描述&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;图1 训练样本中全局链与局部链图&lt;/p&gt;

&lt;p&gt;网格中的每个实体节点表示一个句子中包含来自内聚链的单词。
文章假设一个段落就是一个子主题，所以将那些跨越三个段落的句子链分类为全局链，只在一个段落中的句子链为局部链。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 基于句子链的内聚特征：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;链类型特征：global-identity, local-identity, global-lexical 和 local-lexical chains&lt;/li&gt;
  &lt;li&gt;全局标题特征：全局链中的某个句子如果包含题目中的关键字，那么可能将这条句子分类为thesis标签&lt;/li&gt;
  &lt;li&gt;相互作用特征：如果两个句子链中有超过1个共同句子，则认为两个句子链相互作用&lt;/li&gt;
  &lt;li&gt;结构特征：句子链覆盖句子或段落的最大数和平均数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用条件随机场（CRF）模型对三个不同主题的六种篇章结构分类效果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;基于全局和局部内聚的学生论文中的篇章结构识别_&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/59eb38f50001cbbf18600658.png&quot; alt=&quot;图片描述&quot; style=&quot;display:block; margin:auto; width:100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;图2 分类效果图&lt;/p&gt;

&lt;p&gt;我们可以发现添加了内聚特征的模型可以明显提升识别Main idea 和 Thesis类别标签的精确度。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/deeplearning/2017/10/19/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%B1%80%E5%92%8C%E5%B1%80%E9%83%A8%E5%86%85%E8%81%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84%E8%AF%86%E5%88%AB.html</link>
        <guid isPermaLink="true">http://localhost:4000/deeplearning/2017/10/19/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8E%E5%85%A8%E5%B1%80%E5%92%8C%E5%B1%80%E9%83%A8%E5%86%85%E8%81%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84%E8%AF%86%E5%88%AB.html</guid>
        
        <category>论文笔记</category>
        
        <category>全局</category>
        
        <category>局部</category>
        
        <category>篇章结构识别</category>
        
        
        <category>Deeplearning</category>
        
      </item>
    
      <item>
        <title>论文笔记-在学生作文中自动识别篇章结构</title>
        <description>&lt;p&gt;最近在研究基于自然语言处理的作文自动评分系统，现在对其中一篇与篇章结构分析相关的论文：《Finding the WRITE stuff： Automatic identification of discourse structure in student essays》作一个大概总结。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 为什么要研究篇章结构？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在国内外都有很多自动评分系统，这些自动评分系统大多从拼写检查、语法检查、内容分析等来帮助学生提高写作质量，学生通过这些类型的自动评分系统的反馈来改进他们写作的某些方面：语法、拼写等。这些系统将会继续受到学生的重视，因为在这些方面的改善对于学生写出高质量文章依然是至关重要的。&lt;/p&gt;

&lt;p&gt;随着学生深入学习英文写作，便需要开始思考文章的篇章结构。不同类型的作文一般具有不同类型的篇章结构，比如信件、议论文等，它们拥有不同的篇章结构且篇章结构的优良在很大程度上影响作文的评分。分析篇章结构的自动评分系统为学生提供作文篇章结构的反馈，它使得学生对作文的篇章结构有了全面的分析，例如，如果系统反馈出学生的作文没有结论部分，那么学生可以在作文的结论部分多下功夫。这种类似于传统教师的自动化反馈可以帮助学生提高他们在篇章结构的组织和把控能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 什么是篇章结构？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;就议论文而言，现在普遍将篇章结构分为8类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Title 文章标题&lt;/li&gt;
  &lt;li&gt;Introduction 介绍文章背景&lt;/li&gt;
  &lt;li&gt;Prompt 主题总述或汇总提示&lt;/li&gt;
  &lt;li&gt;Thesis 阐述了作者对他/她正在争论的问题的主要矛盾&lt;/li&gt;
  &lt;li&gt;Main idea 提出与文章相关的主要思想/论点&lt;/li&gt;
  &lt;li&gt;Supporting idea 提供证据来解释或支持文章的主要思想&lt;/li&gt;
  &lt;li&gt;Conclusion 总结全文的主要思想&lt;/li&gt;
  &lt;li&gt;Other/Irrelevant 不适用于上述要素，也不构成任何有意义的贡献&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59e821a300018fef06730510.png&quot; alt=&quot;一篇标记好的议论文作文&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;图1 一篇标记好的议论文作文&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 如何分析篇章结构？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;篇章结构的研究分析可分为微观和宏观两个角度。微观篇章结构指的是篇章中一个句子内部的结构或两个连续的句子之间的结构，宏观篇章结构是指更高层次的结构，表现为句群、段落之间的结构。&lt;/p&gt;

&lt;p&gt;微观角度的篇章结构理论主要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;浅层衔接理论&lt;/li&gt;
  &lt;li&gt;Hobbs模型&lt;/li&gt;
  &lt;li&gt;修辞结构理论（RST）&lt;/li&gt;
  &lt;li&gt;宾州篇章树库理论&lt;/li&gt;
  &lt;li&gt;意图结构理论&lt;/li&gt;
  &lt;li&gt;信息结构理论&lt;/li&gt;
  &lt;li&gt;基于连接依存数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;宏观角度的篇章结构理论则相对较少，主要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;篇章模式&lt;/li&gt;
  &lt;li&gt;超主位理论&lt;/li&gt;
  &lt;li&gt;篇章宏观结构理论&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.1 基于决策的篇章结构分析方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;核心思想是：使用一系列特征提取的算法提取文章中每个句子的与篇章结构相关的特征，将这些特征向量输入C5.0（一种决策树的机器学习算法）中来对句子所属类别进行分类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1.1 基于RST提取修辞特征和核心与边界状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按照修辞结构理论（RST），可以将任何一篇议论文按照图2的形式构建RST篇章树。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构_&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/59e821f70001070610190341.png&quot; alt=&quot;RST篇章树&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;图2 RST篇章树&lt;/p&gt;

&lt;p&gt;树的叶子节点表示文章中的篇章单位（Discourse Unit），在连接篇章单位的弧线上标明文本间的修辞关系；箭头指向的篇章单位在该关系中为核心（nucleus），否则为边界（satellite）；水平线表示文本范围（span）；垂直线对应的文本范围为该修辞关系的“核心”。比如图2中A和B两个篇章单位的修辞关系是：B是A的背景描述，A在“背景”修辞关系中为“核心”，B为“边界”。&lt;/p&gt;

&lt;p&gt;修辞特征可以反映两个篇章单位之间的语义、所包含的含义以及文本之间的关系，一般来说这种由不同篇章单位以及它们之间的修辞特征关系构成的修辞结构树可以由Marcu的&lt;code class=&quot;highlighter-rouge&quot;&gt;cue-phrase-based discourse parser&lt;/code&gt;来构建。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1.2 提取核心单词、术语等词汇特征&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提取句子中核心单词或术语的特征，比如A，becauseB，because表示对A这种结果的一种增强；First的出现可能意味着一个新的论点或论据的出现。“opinion”,“feel”相对“Should”, “might” ,“agree” ,“disagree” 与 “I”连接的时候更有可能与Thesis相关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1.3 提取句法结构与语法特征&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;五种句法结构与语法：主从复合句、补语从句、不定式分句、关系从句以及助动词。一个不定式短语出现在一个句子或一个段落的开始往往标志一个新论点（Main idea）的出现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1.4 基于位置的特征&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种方法制定了一系列句子位置对应篇章结构类别的规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Introductory：作文的第一句；&lt;/li&gt;
  &lt;li&gt;Thesis：第一段中除第一句以外的所有文本；&lt;/li&gt;
  &lt;li&gt;Main ideas：所有正文段落的第一句；&lt;/li&gt;
  &lt;li&gt;Supporting ideas：正文段落中除第一句以外的所有文本；&lt;/li&gt;
  &lt;li&gt;Conclusion：最后一段中的所有文本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.1.5 基于标点符号的特征&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;句号、问号、感叹号等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 基于概率的篇章结构分析方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;核心思想：基于概率的篇章结构分析方法希望给一篇作文中越可能的标签序列分配更高的概率，越不可能的标签序列分配越低的概率。&lt;/p&gt;

&lt;p&gt;步骤一：有限状态机使用极大似然估计技术从训练数据中估计每个句子的标签概率，比如，如果句子中包含“conclusion”单词时，这个句子是Conclusion标签的概率要比Introduction标签的概率大；&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构_&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/59e8222b0001993b06720307.png&quot; alt=&quot;正确标记的训练数据的标签序列&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;图3 正确标记的训练数据的标签序列&lt;/p&gt;

&lt;p&gt;步骤二：接下来我们需要为由步骤一组成的标签序列评估其概率，选择最有可能的一组标签序列。局部语言模型评估某个标签序列的概率公式为：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构_&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/59e822520001be8008620048.png&quot; alt=&quot;评估某个标签序列的概率公式&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设每个句子标签的概率都依赖其前两个句子标签，&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构_&quot; 图片5=&quot;&quot; src=&quot;http://img.mukewang.com/59e8225f00011d4107260064.png&quot; alt=&quot;每个句子标签的概率&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;局部语言模型无法捕捉全局特征，预测的标签序列缺乏全局连贯性，比如：96%的Thesis句出现在一个单独的段落中，一个总结句可能出现在Thesis后的n个Main idea/Supporting idea语句块之后，如果n&amp;gt;2，这种可能性高达88%。使用EM算法来训练全局语言模型捕捉这种全局特征。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构_&quot; 图片6=&quot;&quot; src=&quot;http://img.mukewang.com/59e8226d0001e76c06730296.png&quot; alt=&quot;语言模型&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;图4 语言模型&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;L表示标签序列，W表示其对应的单词序列，P(L)表示标签序列L的概率，而P(W&lt;/td&gt;
      &lt;td&gt;L)表示序列L产生序列W的概率&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;基于概率的篇章结构分析方法以文章中每个句子的单词序列W作为输入，使用极大似然估计技术和EM算法来计算出最大概率的标签序列L。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;论文笔记-在学生作文中自动识别篇章结构_&quot; 图片7=&quot;&quot; src=&quot;http://img.mukewang.com/59e8228b0001819002940032.png&quot; alt=&quot;最大概率的标签序列L&quot; style=&quot;display:block; margin:auto&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;P(L)表示标签序列L的概率，而P(W&lt;/td&gt;
      &lt;td&gt;L)表示标签序列L产生序列W的概率。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/deeplearning/2017/10/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%9C%A8%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84.html</link>
        <guid isPermaLink="true">http://localhost:4000/deeplearning/2017/10/16/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%9C%A8%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E7%AF%87%E7%AB%A0%E7%BB%93%E6%9E%84.html</guid>
        
        <category>论文笔记</category>
        
        <category>作文自动评分系统</category>
        
        <category>篇章结构</category>
        
        
        <category>Deeplearning</category>
        
      </item>
    
      <item>
        <title>死磕数据库调优-数据库优化的几点思考</title>
        <description>&lt;p&gt;上篇我们讲了下在数据库表设计时如何根据业务需求来选取最适合自己的字段属性设计，今天我们来聊聊当你拿到一句sql语句，你会从哪些方面来优化它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方面一、in、exists还是join&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用场景：我们要查询整个湖北省所有的水土流失信息，显然全国的水土流失表中的数据比湖北省城市数要大很多，假设全国的水土流失表有100万条数据，湖北省总共有80个市（包括直辖市、县级市和市辖区等）。&lt;/p&gt;

&lt;p&gt;问题：那么对于这种使用场景，sql中使用in还是exists？&lt;/p&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1、select * from shuituInfo where cid in(select id from city );&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2、select * from shuituInfo where exists(select id from city where shuituInfo.cid= city.id);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;测试下来，在表结构一样的情况下，我们发现1比2的效率要高很多。&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;p&gt;如果两个表中一个较小，一个较大，则子查询表数据大的用exists，子查询表数据小的用in。因为in会使用城市表中的id去到水土流失信息表中直接匹配所需要的行，而exists是根据匹配项去判断是或者否，然后根据是否返回结果。当子查询的表数据量大而主表数据量小，用exists判断，效率就会高，而当子查询的表数据量小而主表数据量大的时候，直接匹配你需要的值则更快。&lt;/p&gt;

&lt;p&gt;主表有100万行，子查询里面有80条数据，那么exists会把100万行在子查询里面进行匹配，匹配上了就显示，匹配不上就不显示，所以需要判断100万次，而in则会使用子查询的80条记录直接匹配主表中的100万行数据，in的效率通常会更高，但是如果反过来，主表80条记录，子查询里面有100万行，exists只进行80次判断，而in会用100万个数据去匹配这80条记录，所以比exists更快。所以说in的效率取决于子表的数据量大小，而exists的效率取决于主表的数据量大小。如果字表的数据量小，使用in时只需要从主表中检索符合字表的数据就好了；如果主表的数据量小，使用exists只需要判断主表中的数据是否满足子查询。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3、select s.* from shuituInfo s, city c where s.cid = c.id;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其实我们使用隐式(implicit) inner join的效率会更高一点：&lt;/p&gt;

&lt;p&gt;EXISTS &amp;lt;= IN &amp;lt;= JOIN&lt;/p&gt;

&lt;p&gt;NOT EXISTS &amp;lt;= NOT IN &amp;lt;= LEFT JOIN&lt;/p&gt;

&lt;p&gt;所以在同等情况下，尽量避免子查询，而用join来实现。个人理解是，join之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成查询工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方面二、union 和 union all&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一些应用场景下，我们常需要使用union来写一些去重的sql，但union会将各查询子集的记录做比较并去除相同的记录，所以比起单纯的union all（不排除重复的值）来说通常速度都会慢上许多。一般来说，如果我们确定在某些应用场景下合并子集后不会出现重复值那么使用union all。&lt;/p&gt;

&lt;p&gt;对于索引列最好使用union all，因复杂的查询【包含运算等】将使or、in放弃索引而全表扫描。&lt;/p&gt;

&lt;p&gt;对于只有非索引字段最好使用or或者in，因为非索引字段本来要全表扫描而union all会成倍增加表扫描的次数。见文献-MySQL中使用or、in与union all在查询命令下的效率对比&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方面三、常见的优化手段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、应该尽量把字段设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;not null&lt;/code&gt;，这样在将来执行查询的时候，数据库不用去比较&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;值。&lt;/p&gt;

&lt;p&gt;2、最好是在相同类型的字段间进行比较的操作。在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。&lt;/p&gt;

&lt;p&gt;3、在建有索引的字段上尽量不要使用函数进行操作，或者进行计算。比如：在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。&lt;/p&gt;

&lt;p&gt;4、在搜索字符型字段时，我们有时会使用like关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。因为在有些情况（比如&lt;code class=&quot;highlighter-rouge&quot;&gt;like '%param%'&lt;/code&gt;）下，like查询使用不到索引，会扫描全表，但如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;like 'param'&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;like 'param%'&lt;/code&gt;的情况下，索引不会失效。但在数据量非常大的时候还是建议不使用like。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;MySQL中使用or、in与union all在查询命令下的效率对比：http://www.jb51.net/article/75171.htm&lt;/p&gt;

&lt;p&gt;MySQL数据库优化的八种方式：http://www.cnblogs.com/zhyunfe/p/6209074.html&lt;/p&gt;

&lt;p&gt;20+条MySQL性能优化的最佳经验：http://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html&lt;/p&gt;

</description>
        <pubDate>Sun, 13 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/database/2017/08/13/%E6%AD%BB%E7%A3%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%9D%E8%80%83.html</link>
        <guid isPermaLink="true">http://localhost:4000/database/2017/08/13/%E6%AD%BB%E7%A3%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%9D%E8%80%83.html</guid>
        
        <category>数据库设计</category>
        
        <category>数据库优化</category>
        
        
        <category>Database</category>
        
      </item>
    
      <item>
        <title>死磕数据库调优-不选最好的，只选最适合的</title>
        <description>&lt;p&gt;终于把老板（导师）接的项目的一期做完了，项目也算告一段落了。整个项目从0到1，从架构设计到功能逻辑实现，我感觉这是我锻炼到的最多的一次，其中我思考最多的不是功能逻辑的实现，因为在不同的项目里需求不一样，功能逻辑也就不一样，所以这个在web项目里没有什么通用性（除了功能需求相似的情况下），因为这是我第一次做架构，而这个角色不会太多的思考某个功能点的技术路线或解决方案应该是怎么样，而是会比以往思考的更多的是框架性能是否足够优化，能承受多大的并发压力，比如数据库表应该怎样设计、数据库性能应该怎样优化等问题。接下来我会总结下在项目中我对数据库性能优化的一系列思考，今天先来讲讲我在项目中遇到的那些字段属性的选择。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据业务需求选取最合适的字段属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主流的关系型数据库（如MySQL，Oracle，SQLServer等）都支持大量数据的存取，但在我们的项目中如果不考虑实际业务需求来设计表的字段属性，那么就很可能会造成大量多余的数据存储空间，所以我们在设计数据库表的字段属性时，我们可以将表中字段的宽度设得尽可能小。&lt;/p&gt;

&lt;p&gt;在数据库中，字符型的数据是最多的，可以占到整个数据库的80%以上。为此正确处理字符型的数据，对于提高数据库的性能有很大的作用。&lt;/p&gt;

&lt;p&gt;例如，我们用char(11)来存储手机号码，char是固定长度的，在不足11位的情况下会在后面补齐空格，而varchar是变长的，11只是最大值，当你存储的字符小于11时，按实际长度存储。通常情况下手机号码的长度是固定在11位的，所以不需要使用varchar(11)来存储，因为在char比varchar效率稍高一些；同样的，我们用char(6)来定义邮政编码这个字段，如果将其设置为char(255)，显然给数据库增加了不必要的空间，甚至使用varchar这种类型也是多余的。&lt;/p&gt;

&lt;p&gt;所以如果某个字段的长度总是近似的，如一般在90个到100个字符之间，甚至是相同的长度，此时比较适合采用char字符类型。比较典型的应用就是MD5哈希值。当利用MD5哈希值来存储用户密码时，就非常使用采用char字符类型。因为其长度是相同的。另外，像用来存储用户的身份证号码等等，一般也建议使用char类型的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;varchar VS char&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从碎片角度进行考虑。使用CHAR字符型时，由于存储空间都是一次性分配的。为此某个字段的内容，其都是存储在一起的。单从这个角度来讲，其不存在碎片的困扰。而可变长度的字符数据类型，其存储的长度是可变的。当其更改前后数据长度不一致时，就不可避免的会出现碎片的问题。故使用可变长度的字符型数据时，我们就要时不时的对碎片进行整理。如执行数据库导出导入作业，来消除碎片。&lt;/p&gt;

&lt;p&gt;另外varchar在位数相同的情况下会比char多占用一个存储位置。比如char(1)与varchar(1)这两个定义，虽然这两个都只能够用来保存单个的字符，但是varchar要比char多占用一个存储位置。这主要是因为使用varchar数据类型时，会多用1个字节用来存储长度信息。这个管理上的开销char字符类型是没有的。&lt;/p&gt;

&lt;p&gt;那既然varchar是变长的，那么varchar(100)和varchar(200)有没有什么区别呢？当然有区别了，虽然它们用来存储90个字符数据的时候其存储空间是相同的。但是对于内存的消耗是不同的。对于varchar数据类型来说，硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的，但是对于内存来说，它是使用固定大小的内存块来保存值，也就是说varchar(200)是使用200个字符空间来保存值。显然，这对于排序或者临时表(这些内容都需要通过内存来实现)作业会产生比较大的不利影响。所以说在内存的操作方式中，varchar是按照最长的方式在内存中进行操作的。比如说要进行排序的时候，varcahr(100)是按照100这个长度来进行的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的字符串类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕数据库调优-记在数据库设计中对数据库性能优化的思考&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/598fdf33000107f114620540.png&quot; style=&quot;width:100%&quot; alt=&quot;常见的字符串类型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们一般会用tinyint(1)来描述性别而不会直接用char，也不会用int(1)。int类型占4个字节，tinyint占1个字节。int(1)和int(4) 从本身长度还是存储方式上都是一样的，区别就是显示的长度不同，如果列制定了zerofill 就会用0填充显示，int(4)指定后就会显示为0002。tinyint(1)和tinyint(4)没什么区别，存123都能存的下，而如果tinyint(3) zerofill 的话，插入值 12，会存储012，zerofill自动左边补零，它会限制显示长度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的数值类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕数据库调优-记在数据库设计中对数据库性能优化的思考&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/598fdf200001df3614640560.png&quot; style=&quot;width:100%&quot; alt=&quot;常见的数值类型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tinyint VS enum VS set&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;enum是一个字符串对象，其值通常选自一个允许值列表中，该列表在表创建时的列规格说明中被明确地列举。枚举最大可以有 65535 个成员值。&lt;/p&gt;

&lt;p&gt;在下列某些情况下，值也可以是空串(“”) 或 NULL：&lt;/p&gt;

&lt;p&gt;如果将一个无效值插入一个 ENUM (即，一个不在允许值列表中的字符串)，空字符串将作为一个特殊的错误值被插入。事实上，这个字符串有别于一个”普通的”空字符串，因为这个字符串有个数字索引值为 0。稍后有更详细描述。&lt;/p&gt;

&lt;p&gt;如果一个 ENUM 被声明为 NULL，NULL 也是该列的一个合法值，并且该列的缺省值也将为 NULL 。如果一个 ENUM 被声明为 NOT NULL，该列的缺省值将是该列表所允许值的第一个成员。&lt;/p&gt;

&lt;p&gt;每个枚举值均有一个索引值：&lt;/p&gt;

&lt;p&gt;在列说明中列表值所允许的成员值被从 1 开始编号。&lt;/p&gt;

&lt;p&gt;空字符串错误值的索引值为 0。这就意味着，你可以使用下面所示的 SELECT 语句找出被赋于无效 ENUM值的记录行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&amp;gt; SELECT * FROM tbl_name WHERE enum_col=0;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;NULL 值的索引值为 NULL。&lt;/p&gt;

&lt;p&gt;指定为 ENUM(“one”, “two”, “three”) 的一个列，可以有下面所显示的任一值。每个值的索引值也如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕数据库调优-记在数据库设计中对数据库性能优化的思考&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/599017d90001470b13720314.png&quot; style=&quot;width:100%&quot; alt=&quot;ENUM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的enum分析可以看出，enum适合存储表单界面中的“单选值”，下面我们来看看set数据类型。&lt;/p&gt;

&lt;p&gt;set是一种多选字符串数据类型，适合存储表单界面的“多选值”。设定set的时候，同样需要给定“固定的几个选项”；存储的时候，可以存储其中的若干个值。&lt;/p&gt;

&lt;p&gt;设定set的格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;set(&quot;param1&quot;,&quot;param2&quot;,&quot;param3&quot;,...)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;set的每个选项值也对应一个数字，依次是1，2，4，8，16…，最多有64个选项
使用的时候，可以使用set选项的字符串本身（多个选项用逗号分隔），也可以使用多个选项的数字之和（比如：1+2+4=7）&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕数据库调优-记在数据库设计中对数据库性能优化的思考&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/599018370001dd7511780932.png&quot; style=&quot;width:100%&quot; alt=&quot;set&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;15=1+2+4+8 &amp;lt;=&amp;gt; ‘music,read,swimming,footbal’&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;7=1+2+4&amp;lt;=&amp;gt; ‘music,read,swimming’&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;了解了set后，以后我们在做权限管理这一块功能的时候就不需要单建一张权限表，然后在角色表里加一个权限的字段，现在我们直接用set就可以很方便实现一个角色对应多种权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么对于enum和tinyint我们到底用哪一个呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;个人推荐尽量使用tinyint来代替enum，我们可以用tinyint(1)来代替enum表示性别字段，enum对php这种弱类型来说简直是灾难，而且如果项目以后要做不同数据库的迁移，enum可能会出现一些问题，enum的移植性不如tinyint，维护起来比较麻烦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL数据库中CHAR与VARCHAR之争：http://tech.it168.com/a2011/0426/1183/000001183173.shtml&lt;/p&gt;

&lt;p&gt;MySQL 数据类型：http://www.runoob.com/mysql/mysql-data-types.html&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/database/2017/08/08/%E6%AD%BB%E7%A3%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98-%E4%B8%8D%E9%80%89%E6%9C%80%E5%A5%BD%E7%9A%84-%E5%8F%AA%E9%80%89%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84.html</link>
        <guid isPermaLink="true">http://localhost:4000/database/2017/08/08/%E6%AD%BB%E7%A3%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98-%E4%B8%8D%E9%80%89%E6%9C%80%E5%A5%BD%E7%9A%84-%E5%8F%AA%E9%80%89%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84.html</guid>
        
        <category>数据库设计</category>
        
        <category>数据库调优</category>
        
        <category>字段属性</category>
        
        
        <category>Database</category>
        
      </item>
    
      <item>
        <title>死磕Spring源码-Spring MVC</title>
        <description>&lt;p&gt;Spring IoC是Spring的核心，所以IoC也是Spring MVC的基础，Spring MVC 会建立起一个IOC容器体系，IoC的启动过程与web容器启动的过程是集成在一起的，它们的启动由ContextLoaderListener监听器负责完成。建立IOC容器体系后，DispatcherServlet作为Spring MVC处理web请求的转发器也建立起来，从而完成响应HTTP请求的准备工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、IOC容器的启动（ContextLoaderListener）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IoC容器的启动过程就是建立上下文的过程，由ContextLoaderListener启动的上下文为根上下文，在根上下文的基础上，还有一个与Web MVC相关的上下文作为根上下文的子上下文来保存DispatcherServlet所需要的MVC对象，构成一个上下文体系。这个上下文体系的建立与初始化是由ContextLoader来完成的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
     public ContextLoaderListener() {
     }
     public ContextLoaderListener(WebApplicationContext context) {
          super(context);
     }
     @Override
     public void contextInitialized(ServletContextEvent event) {
          initWebApplicationContext(event.getServletContext());
     }
     @Override
     public void contextDestroyed(ServletContextEvent event) {
          closeWebApplicationContext(event.getServletContext());
          ContextCleanupListener.cleanupAttributes(event.getServletContext());
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在ContextLoaderListener中实现了ServletContextListener接口，这个接口里的函数会结合Web容器的生命周期被调用（contextInitialized，服务器启动时被调用；contextDestroyed，服务器关闭时被调用）。因为ServletContextListener是ServletContext的监听者，如果ServletContext发生变化，会触发预先设计好的动作，比如初始化和销毁。比如初始化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ContextLoaderListener.contextInitialized
@Override
public void contextInitialized(ServletContextEvent event) {
    initWebApplicationContext(event.getServletContext());
}
//初始化WebApplicationContext根上下文
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
    //根上下文作为唯一实例存在，用ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE标志位来实现
    if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
        throw new IllegalStateException(
                &quot;Cannot initialize context because there is already a root application context present - &quot; +
                &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);
    }

    Log logger = LogFactory.getLog(ContextLoader.class);
    servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&quot;Root WebApplicationContext: initialization started&quot;);
    }
    long startTime = System.currentTimeMillis();

    try {
        if (this.context == null) {
            //创建根上下文
            this.context = createWebApplicationContext(servletContext);
        }
        if (this.context instanceof ConfigurableWebApplicationContext) {
            //转型为需要产生的IoC容器
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
            if (!cwac.isActive()) {
                if (cwac.getParent() == null) {
                    // 载入根上下文的双亲上下文
                    ApplicationContext parent = loadParentContext(servletContext);
                    cwac.setParent(parent);
                }
                configureAndRefreshWebApplicationContext(cwac, servletContext);
            }
        }
        //设置ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE标志位
   servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

        ClassLoader ccl = Thread.currentThread().getContextClassLoader();
        if (ccl == ContextLoader.class.getClassLoader()) {
            currentContext = this.context;
        }
        else if (ccl != null) {
            currentContextPerThread.put(ccl, this.context);
        }

        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +
                    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);
        }
        if (logger.isInfoEnabled()) {
            long elapsedTime = System.currentTimeMillis() - startTime;
            logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);
        }

        return this.context;
    }
    catch (RuntimeException ex) {
        logger.error(&quot;Context initialization failed&quot;, ex);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
        throw ex;
    }
    catch (Error err) {
        logger.error(&quot;Context initialization failed&quot;, err);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
        throw err;
    }
}

protected WebApplicationContext createWebApplicationContext(ServletContext sc) {
    //判断使用什么样的类作为Web容器中的IoC容器
    Class&amp;lt;?&amp;gt; contextClass = determineContextClass(sc);
    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
        throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +
                &quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);
    }
    return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
}

protected Class&amp;lt;?&amp;gt; determineContextClass(ServletContext servletContext) {
    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);
    //如果在ServletContext中配置了CONTEXT_CLASS_PARAM，则使用这个class反射生成根上下文实例。
    if (contextClassName != null) {
        try {
            return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());
        }
        catch (ClassNotFoundException ex) {
            throw new ApplicationContextException(
                    &quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;, ex);
        }
    }
    else {//如果没有配置CONTEXT_CLASS_PARAM，则使用默认的contextClass来反射生成根上下文实例。
        contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());
        try {
            return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());
        }
        catch (ClassNotFoundException ex) {
            throw new ApplicationContextException(
                    &quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;, ex);
        }
    }
}

//设置ServletContext以及配置各类参数，最终调用refresh方法来初始化容器
protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
    if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
        // The application context id is still set to its original default value
        String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);
        if (idParam != null) {
            wac.setId(idParam);
        }
        else {
            // Generate default id...
            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
                    ObjectUtils.getDisplayString(sc.getContextPath()));
        }
    }

    wac.setServletContext(sc);
    String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);
    if (configLocationParam != null) {
        wac.setConfigLocation(configLocationParam);
    }

    ConfigurableEnvironment env = wac.getEnvironment();
    if (env instanceof ConfigurableWebEnvironment) {
        ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);
    }

    customizeContext(sc, wac);
    wac.refresh();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ContextLoaderListener初始化根上下文过程图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-SpringMVC&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/597dfb49000101aa16560728.png&quot; style=&quot;width:100%&quot; alt=&quot;初始化根上下文过程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、Spring MVC的启动（DispatcherServlet）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在完成ContextLoaderListener的初始化后，Web容器开始初始化DispatcherServlet。DispatcherServlet会建立自己的上下文来持有Spring MVC的Bean对象，在建立自己持有的IOC容器时，会将根上下文作为自己持有的上下文的双亲上下文，建立了这个上下文后将该上下文保存到ServletContext中，供以后检索和使用。DispatcherServlet的启动过程也就是Spring MVC的启动过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 DispatcherServlet的继承关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-SpringMVC&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/597ef8590001cdb904720208.png&quot; style=&quot;width:50%&quot; alt=&quot;DispatcherServlet的继承关系&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DispatcherServlet通过继承FrameworkServlet和HttpServletBean来继承HttpServlet，这样就可以使用Servlet API来对HTTP请求进行响应，成为Spring MVC的前端处理器。&lt;/p&gt;

&lt;p&gt;DispatcherServlet的工作分为两部分：一个是&lt;strong&gt;初始化部分&lt;/strong&gt;，通过调用initStrategies方法完成Spring MVC的初始化；一个是&lt;strong&gt;对HTTP请求进行响应&lt;/strong&gt;，作为一个servlet，Web容器会调用Servlet的doGet和doPost方法来完成响应动作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 DispatcherServlet的启动与初始化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DispatcherServlet的启动与Servlet的启动是相似的，在Servlet初始化时会调用init方法，在DispatcherServlet的基类HttpServletBean的初始化也由init开始。DispatcherServlet持有一个以自己的Servlet名称命名的IoC容器，这个容器作为根上下文的子上下文存在，在Web容器的上下文体系中，一个根上下文可以作为多个Servlet子上下文的双亲上下文。&lt;/p&gt;

&lt;p&gt;一般情况下controller相关的bean或者对应的注解扫描配置在子上下文中，而service、dao的bean或者对应的注解扫描配置在根上下文中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;建立MVC的上下文代码逻辑：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HttpServletBean.init()
@Override
public final void init() throws ServletException {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Initializing servlet '&quot; + getServletName() + &quot;'&quot;);
    }

    // 获取Servlet的初始化参数，配置Bean属性
    try {
        PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
        ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
        bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
        initBeanWrapper(bw);
        bw.setPropertyValues(pvs, true);
    }
    catch (BeansException ex) {
        logger.error(&quot;Failed to set bean properties on servlet '&quot; + getServletName() + &quot;'&quot;, ex);
        throw ex;
    }

    // 具体初始化过程
    initServletBean();

    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Servlet '&quot; + getServletName() + &quot;' configured successfully&quot;);
    }
}

@Override
protected final void initServletBean() throws ServletException {
    getServletContext().log(&quot;Initializing Spring FrameworkServlet '&quot; + getServletName() + &quot;'&quot;);
    if (this.logger.isInfoEnabled()) {
        this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization started&quot;);
    }
    long startTime = System.currentTimeMillis();
    //初始化上下文
    try {
        this.webApplicationContext = initWebApplicationContext();
        initFrameworkServlet();
    }
    catch (ServletException ex) {
        this.logger.error(&quot;Context initialization failed&quot;, ex);
        throw ex;
    }
    catch (RuntimeException ex) {
        this.logger.error(&quot;Context initialization failed&quot;, ex);
        throw ex;
    }

    if (this.logger.isInfoEnabled()) {
        long elapsedTime = System.currentTimeMillis() - startTime;
        this.logger.info(&quot;FrameworkServlet '&quot; + getServletName() + &quot;': initialization completed in &quot; +
                elapsedTime + &quot; ms&quot;);
    }
}

//这里的初始化上下文和ContextLoaderListner不太一样
protected WebApplicationContext initWebApplicationContext() {
    //使用ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE来获取根上下文
    WebApplicationContext rootContext =
            WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    WebApplicationContext wac = null;

    if (this.webApplicationContext != null) {
        wac = this.webApplicationContext;
        if (wac instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
            if (!cwac.isActive()) {
                if (cwac.getParent() == null) {
                    // 设置根上下文为双亲上下文
                    cwac.setParent(rootContext);
                }
                configureAndRefreshWebApplicationContext(cwac);
            }
        }
    }
    if (wac == null) {
        wac = findWebApplicationContext();
    }
    //如果以上都没有能获取MVC的IoC容器，则创建一个
    if (wac == null) {
        wac = createWebApplicationContext(rootContext);
    }

    if (!this.refreshEventReceived) {
        onRefresh(wac);
    }

    if (this.publishContext) {
        //把建立好的子上下文存放到ServletContext中去，使用的属性名就是当前servlet名
        String attrName = getServletContextAttributeName();
        getServletContext().setAttribute(attrName, wac);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&quot;Published WebApplicationContext of servlet '&quot; + getServletName() +
                    &quot;' as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);
        }
    }

    return wac;
}

protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {
    Class&amp;lt;?&amp;gt; contextClass = getContextClass();
    if (this.logger.isDebugEnabled()) {
        this.logger.debug(&quot;Servlet with name '&quot; + getServletName() +
                &quot;' will try to create custom WebApplicationContext context of class '&quot; +
                contextClass.getName() + &quot;'&quot; + &quot;, using parent context [&quot; + parent + &quot;]&quot;);
    }
    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
        throw new ApplicationContextException(
                &quot;Fatal initialization error in servlet with name '&quot; + getServletName() +
                &quot;': custom WebApplicationContext class [&quot; + contextClass.getName() +
                &quot;] is not of type ConfigurableWebApplicationContext&quot;);
    }
    //实例化需要的具体上下文对象，这个上下文对象也是XmlWebApplicationContext
    ConfigurableWebApplicationContext wac =
            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);

    wac.setEnvironment(getEnvironment());
    //设置双亲上下文
    wac.setParent(parent);
    wac.setConfigLocation(getContextConfigLocation());

    configureAndRefreshWebApplicationContext(wac);

    return wac;
}

protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
    if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
        if (this.contextId != null) {
            wac.setId(this.contextId);
        }
        else {
            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
                    ObjectUtils.getDisplayString(getServletContext().getContextPath()) + &quot;/&quot; + getServletName());
        }
    }

    wac.setServletContext(getServletContext());
    wac.setServletConfig(getServletConfig());
    wac.setNamespace(getNamespace());
    wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));

    ConfigurableEnvironment env = wac.getEnvironment();
    if (env instanceof ConfigurableWebEnvironment) {
        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());
    }

    postProcessWebApplicationContext(wac);
    applyInitializers(wac);
    //通过refresh方法来调用容器初始化过程
    wac.refresh();
}

DispatcherServlet.onRefresh
protected void onRefresh(ApplicationContext context) {
    initStrategies(context);
}

//启动整个Spring MVC框架的初始化
protected void initStrategies(ApplicationContext context) {
    initMultipartResolver(context);
    initLocaleResolver(context);
    initThemeResolver(context);
    initHandlerMappings(context);
    initHandlerAdapters(context);
    initHandlerExceptionResolvers(context);
    initRequestToViewNameTranslator(context);
    initViewResolvers(context);
    initFlashMapManager(context);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MVC框架的初始化是在initStrategies方法中完成的，初始化了支持国际化的LocaleResolver、request映射的HandlerMappings、视图生成的ViewResolvers等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//初始化HandlerMapping
private void initHandlerMappings(ApplicationContext context) {
    this.handlerMappings = null;
    //detectAllHandlerMappings这里默认为true，即默认从所有的IoC容器中获取HandlerMapping
    if (this.detectAllHandlerMappings) {
        // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.
        Map&amp;lt;String, HandlerMapping&amp;gt; matchingBeans =
                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
        if (!matchingBeans.isEmpty()) {
            this.handlerMappings = new ArrayList&amp;lt;HandlerMapping&amp;gt;(matchingBeans.values());
            // We keep HandlerMappings in sorted order.
            AnnotationAwareOrderComparator.sort(this.handlerMappings);
        }
    }
    else {//否则从当前的IoC容器中通过getBean获取所有Bean名称为“handlerMapping”的HandlerMapping
        try {
            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
            this.handlerMappings = Collections.singletonList(hm);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Ignore, we'll add a default HandlerMapping later.
        }
    }

    // 如果没有handlerMappings，则从配置文件中读取
    if (this.handlerMappings == null) {
        this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;No HandlerMappings found in servlet '&quot; + getServletName() + &quot;': using default&quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;initHandlerMappings是对HandlerMappings的初始化，这些Map的作用是为HTTP请求找到相应的Controller控制器，以完成功能逻辑。IoC容器初始化后，容器里有各种各样的Bean，initHandlerMappings会从IoC容器中通过getBean来获取handlerMapping，handlerMapping包含了MVC中Controller的定义和配置，同时handlerMappings变量就已经获取了在BeanDefinition配置好的映射关系。加载的HandlerMapping被放在一个List中并已经排好序，存储着HTTP请求对应的映射数据，List中的一个元素就是一个HandlerMapping，一个mapping中有一系列的URL与Controller的映射。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;initHandlerMappings方法调用栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-SpringMVC&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/597ef9330001fb1313280208.png&quot; style=&quot;width:100%&quot; alt=&quot;initHandlerMappings方法调用栈&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-SpringMVC&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/597ef94100012e7b13780762.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-SpringMVC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 MVC处理HTTP分发请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面已经完成了HandlerMapping的加载，每一个HandlerMapping持有一系列从URL请求到Controller的映射，这种映射关系通常用一个Map（LinkedHashMap，命名为handlerMap）来持有。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;private final Map&amp;lt;String, Object&amp;gt; urlMap = new LinkedHashMap&amp;lt;String, Object&amp;gt;();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;某个URL映射到哪个Controller，这部分的配置是在容器对Bean进行依赖注入时发生的，通过Bean的postProcessor来完成，（registerHandler方法）。这样就为DispatcherServlet的分发奠定了数据基础。&lt;/p&gt;

&lt;p&gt;SimpleUrlHandlerMapping注册handler的代码逻辑&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SimpleUrlHandlerMapping.initApplicationContext
@Override
public void initApplicationContext() throws BeansException {
    super.initApplicationContext();
    registerHandlers(this.urlMap);
}

protected void registerHandlers(Map&amp;lt;String, Object&amp;gt; urlMap) throws BeansException {
    if (urlMap.isEmpty()) {
        logger.warn(&quot;Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping&quot;);
    }
    else {
        for (Map.Entry&amp;lt;String, Object&amp;gt; entry : urlMap.entrySet()) {
            String url = entry.getKey();
            Object handler = entry.getValue();
            // 确保url以&quot;/&quot;开头
            if (!url.startsWith(&quot;/&quot;)) {
                url = &quot;/&quot; + url;
            }
            // 去掉空格
            if (handler instanceof String) {
                handler = ((String) handler).trim();
            }
            registerHandler(url, handler);
        }
    }
}

protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {
    Assert.notNull(urlPath, &quot;URL path must not be null&quot;);
    Assert.notNull(handler, &quot;Handler object must not be null&quot;);
    Object resolvedHandler = handler;

    if (!this.lazyInitHandlers &amp;amp;&amp;amp; handler instanceof String) {
        String handlerName = (String) handler;
        if (getApplicationContext().isSingleton(handlerName)) {
            resolvedHandler = getApplicationContext().getBean(handlerName);
        }
    }

    Object mappedHandler = this.handlerMap.get(urlPath);
    if (mappedHandler != null) {
        if (mappedHandler != resolvedHandler) {
            throw new IllegalStateException(
                    &quot;Cannot map &quot; + getHandlerDescription(handler) + &quot; to URL path [&quot; + urlPath +
                    &quot;]: There is already &quot; + getHandlerDescription(mappedHandler) + &quot; mapped.&quot;);
        }
    }
    else {
        //如果url是“/”，则这个url映射的Controller就是rootHandler
        if (urlPath.equals(&quot;/&quot;)) {
            if (logger.isInfoEnabled()) {
                logger.info(&quot;Root mapping to &quot; + getHandlerDescription(handler));
            }
            setRootHandler(resolvedHandler);
        }//如果url是“/*”，则这个url映射的Controller就是DefaultHandler
        else if (urlPath.equals(&quot;/*&quot;)) {
            if (logger.isInfoEnabled()) {
                logger.info(&quot;Default mapping to &quot; + getHandlerDescription(handler));
            }
            setDefaultHandler(resolvedHandler);
        }
        else {//如果url是正常的url，设置handlerMap的key和value分别对应url和对应的Controller
            this.handlerMap.put(urlPath, resolvedHandler);
            if (logger.isInfoEnabled()) {
                logger.info(&quot;Mapped URL path [&quot; + urlPath + &quot;] onto &quot; + getHandlerDescription(handler));
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;准备好handlerMap中的数据后，我们来看看handlerMapping如何完成请求的映射处理。
在HandlerMapping中定义了getHandler方法，这个方法会根据我们刚刚初始化得到的handlerMap来获取与HTTP请求对应的HandlerExecutionChain，它封装了具体的Controller对象。HandlerExecutionChain有两个比较重要：拦截器（Interceptor）链和handler对象，handler对象就是HTTP对应的Controller，通过拦截器链里的拦截器来对handler对象提供功能的增强。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AbstractHandlerMapping.getHandler
@Override
public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    //获取request对应的handler
    Object handler = getHandlerInternal(request);
    //获取默认的handler
    if (handler == null) {
        handler = getDefaultHandler();
    }
    if (handler == null) {
        return null;
    }
    // 根据名称取出对应的Handler Bean
    if (handler instanceof String) {
        String handlerName = (String) handler;
        handler = getApplicationContext().getBean(handlerName);
    }
    //把这个handler封装到HandlerExecutionChain中并加上拦截器
    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);
    if (CorsUtils.isCorsRequest(request)) {
        CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);
        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);
        CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);
        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);
    }
    return executionChain;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取request对应的handler的代码逻辑&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
    //从request获取url路径
    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
    //从HandlerMap中获取指定url路径的handler
    Object handler = lookupHandler(lookupPath, request);
    if (handler == null) {
        // 如果没有对应url路径的handler则返回相应的handler（RootHandler或DefaultHandler）
        Object rawHandler = null;
        if (&quot;/&quot;.equals(lookupPath)) {
            rawHandler = getRootHandler();
        }
        if (rawHandler == null) {
            rawHandler = getDefaultHandler();
        }
        if (rawHandler != null) {
            if (rawHandler instanceof String) {
                String handlerName = (String) rawHandler;
                rawHandler = getApplicationContext().getBean(handlerName);
            }
            validateHandler(rawHandler, request);
            handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
        }
    }
    if (handler != null &amp;amp;&amp;amp; logger.isDebugEnabled()) {
        logger.debug(&quot;Mapping [&quot; + lookupPath + &quot;] to &quot; + handler);
    }
    else if (handler == null &amp;amp;&amp;amp; logger.isTraceEnabled()) {
        logger.trace(&quot;No handler mapping found for [&quot; + lookupPath + &quot;]&quot;);
    }
    return handler;
}

protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
    // 直接匹配url
    Object handler = this.handlerMap.get(urlPath);
    if (handler != null) {
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        validateHandler(handler, request);
        return buildPathExposingHandler(handler, urlPath, urlPath, null);
    }
    // 如果直接匹配url不成功，则匹配最佳的
    List&amp;lt;String&amp;gt; matchingPatterns = new ArrayList&amp;lt;String&amp;gt;();
    for (String registeredPattern : this.handlerMap.keySet()) {
        if (getPathMatcher().match(registeredPattern, urlPath)) {
            matchingPatterns.add(registeredPattern);
        }
        else if (useTrailingSlashMatch()) {
            if (!registeredPattern.endsWith(&quot;/&quot;) &amp;amp;&amp;amp; getPathMatcher().match(registeredPattern + &quot;/&quot;, urlPath)) {
                matchingPatterns.add(registeredPattern +&quot;/&quot;);
            }
        }
    }
    String bestPatternMatch = null;
    Comparator&amp;lt;String&amp;gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);
    if (!matchingPatterns.isEmpty()) {
        Collections.sort(matchingPatterns, patternComparator);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Matching patterns for request [&quot; + urlPath + &quot;] are &quot; + matchingPatterns);
        }
        bestPatternMatch = matchingPatterns.get(0);
    }
    if (bestPatternMatch != null) {
        handler = this.handlerMap.get(bestPatternMatch);
        if (handler == null) {
            Assert.isTrue(bestPatternMatch.endsWith(&quot;/&quot;));
            handler = this.handlerMap.get(bestPatternMatch.substring(0, bestPatternMatch.length() - 1));
        }
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = getApplicationContext().getBean(handlerName);
        }
        validateHandler(handler, request);
        String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);

        Map&amp;lt;String, String&amp;gt; uriTemplateVariables = new LinkedHashMap&amp;lt;String, String&amp;gt;();
        for (String matchingPattern : matchingPatterns) {
            if (patternComparator.compare(bestPatternMatch, matchingPattern) == 0) {
                Map&amp;lt;String, String&amp;gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);
                Map&amp;lt;String, String&amp;gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);
                uriTemplateVariables.putAll(decodedVars);
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;URI Template variables for request [&quot; + urlPath + &quot;] are &quot; + uriTemplateVariables);
        }
        return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到handler对象后，把这个handler封装到HandlerExecutionChain中并加上拦截器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
    HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?
            (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));

    String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
    for (HandlerInterceptor interceptor : this.adaptedInterceptors) {
        if (interceptor instanceof MappedInterceptor) {
            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;
            if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {
                chain.addInterceptor(mappedInterceptor.getInterceptor());
            }
        }
        else {
            chain.addInterceptor(interceptor);
        }
    }
    return chain;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们完成了对HandlerExecutionChain的封装工作，为handler对http请求响应做好了准备。&lt;/p&gt;

&lt;p&gt;DispatcherServlet是HttpServlet的子类，和其他的HttpServlet一样，通过doService方法来响应HTTP请求（再调用doDispatch）。DispatcherServlet通过getHandler得到一个HandlerExecutionChain后，通过HandlerAdapter来验证这个handler的合法性（handler instanceof Controller，如果是Controller的对象则返回true，反之返回false），合法后执行handler方法获取结果数据，这些数据都封装在ModelAndView中返回给前端进行视图呈现，对视图呈现的处理是通过调用入口：render方法来实现的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null || mappedHandler.getHandler() == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = &quot;GET&quot;.equals(method);
            if (isGet || &quot;HEAD&quot;.equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);
                }
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {
                    return;
                }
            }

            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
        }
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                new NestedServletException(&quot;Handler processing failed&quot;, err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-MVC处理HTTP分发请求&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/597f3b22000129d617520768.png&quot; style=&quot;width:100%&quot; alt=&quot;MVC处理HTTP分发请求&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;《Spring技术内幕 深入解析Spring架构与设计原理》&lt;/p&gt;

</description>
        <pubDate>Wed, 26 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/07/26/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BSpring-MVC.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/07/26/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BSpring-MVC.html</guid>
        
        <category>java</category>
        
        <category>Spring</category>
        
        <category>源码</category>
        
        <category>Spring MVC</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕Spring源码-AOP</title>
        <description>&lt;p&gt;在上一篇Spring源码的依赖注入总结中，我们可以清楚的知道DI有助于应用对象之间的解耦，这章我们来聊聊另外一种常见且有用的解耦方式，在比较大的系统中的日志管理、事务管理等功能，我们可以使用用面向切面编程的思想。在软件开发中，像日志这种散布在应用中多处的功能就是横切关注点，而AOP可以实现横切关注点与它们所影响的对象之间的解耦。&lt;/p&gt;

&lt;p&gt;在面向切面编程中，我们只需在一个地方定义通用的功能，然后以声明的方式定义这个功能（Advice）何时（Before、After or Around）要以何种方式在何处（Pointcut）应用，并且我们无需改变使用这个通用功能的类。这样做有两个好处：第一是把每个关注点集中在一个地方而不是分散到项目的各个地方去；第二是代码结构极其简洁，非常好维护，这对于骨子里就有极简主义的程序猿来说真是一大幸事！不得不佩服Spring团队（迷弟脸）….&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP三个基本点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Advice：通知，这定义了切入点的具体要干的事情，分为BeforeAdvice、AfterAdvice以及ThrowsAdvice。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Around(&quot;timeCost()”)//这时的timeCost()就是一个通知&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Pointcut：切点，这定义了切入点的位置，将需要增加的地方用某个正则表达式进行表示，或根据某个方法名来匹配。利用MethodMatcher中的matches方法来进行匹配判断，在JdkRegexpMethodPointcut中，matches方法实际上是通过JDK来实现正则表达式的匹配。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Pointcut(&quot;execution(public * com.intelligentler.shuitu.controller.*.*(..))”)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Advisor：通知器，把具体操作（通知）和待增强的位置（切点）结合起来，定义在哪一个关注点使用哪一个通知。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Aspect
@Component
@Order(-5)
public class TimeCostAspect {
    …….
} 这里的`TimeCostAspect`就不单单是一个POJO，而且还是一个切面。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;这里有个单例模式的彩蛋：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor implements Serializable {
     private Pointcut pointcut = Pointcut.TRUE;
     public DefaultPointcutAdvisor() {
     }
     public DefaultPointcutAdvisor(Advice advice) {
          this(Pointcut.TRUE, advice);
     }
     public DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) {
          this.pointcut = pointcut;
          setAdvice(advice);
     }
     public void setPointcut(Pointcut pointcut) {
          this.pointcut = (pointcut != null ? pointcut : Pointcut.TRUE);
     }
     @Override
     public Pointcut getPointcut() {
          return this.pointcut;
     }
     @Override
     public String toString() {
          return getClass().getName() + &quot;: pointcut [&quot; + getPointcut() + &quot;]; advice [&quot; + getAdvice() + &quot;]&quot;;
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在DefaultPointcutAdvisor类中Pointcut被设置为Pointcut.TRUE;Pointcut.TRUE在Pointcut的定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Pointcut.class
Pointcut TRUE = TruePointcut.INSTANCE;
//TruePointcut.class
class TruePointcut implements Pointcut, Serializable {
     public static final TruePointcut INSTANCE = new TruePointcut();
     private TruePointcut() {
     }
     @Override
     public ClassFilter getClassFilter() {
          return ClassFilter.TRUE;
     }
     @Override
     public MethodMatcher getMethodMatcher() {
          return MethodMatcher.TRUE;
     }
     private Object readResolve() {
          return INSTANCE;
     }
     @Override
     public String toString() {
          return &quot;Pointcut.TRUE&quot;;
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重点来了：这里的TruePointcut INSTANCE是一个单例模式，使用static类变量来持有单例，再使用private私有构造函数来确保单例不会被再次创建和实例化。在这个类中的MethodMatcher.TRUE也是类似的单例实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP的设计与实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring的AOP采用的是&lt;a href=&quot;https://zhoum1118.github.io/java/2017/06/22/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E9%80%82%E4%BB%A3%E8%A3%85.html&quot;&gt;动态代理模式&lt;/a&gt;，Spring在代理类中包裹切面，在运行期间把切面织入到Bean中，也就是说Spring用代理类封装了目标类，同时拦截了被通知方法的调用，处理完通知（Advice）后，再把调用转发给真正的目标Bean，也正因为是动态代理，所以Spring的AOP只支持到方法连接点而无法提供字段和构造器接入点（AspectJ和JBoss可以），所以Spring无法创建细粒度的通知。&lt;/p&gt;

&lt;p&gt;根据Spring AOP的动态代理的过程，我们可以把AOP的设计分为两大块：第一，需要为目标对象建立代理对象（如何生成代理对象？）；第二，需要启动代理对象的拦截器来完成各种横切面的织入（如何织入横切面同时如何拦截对目标对象方法的调用？）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是代理对象–AOP的动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring AOP的核心技术是动态代理，对于增强的对象方法，在用户调用这个对象方法（request）的时候其实是调用Spring AOP提前为其生成好的代理对象（Proxy）的相应方法，这个代理对象的方法实现就包含了preOperation—request—postOperation，通过对对象方法的这种拦截，增强了目标对象的方法操作，这种方式就是代理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何生成代理对象？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-AOP分析&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/597dad5c00012f2713520784.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-AOP分析&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过继承ProxyConfig、AdvisedSupport和ProxyCreatorSupport等基类的功能实现，具体的AOP代理对象的生成，根据不同的需要，分别由AspectJProxyFactory、ProxyFactoryBean和ProxyFactory来完成。对于需要AspectJ的AOP应用，AspectJProxyFactory起到了集成Spring和AspectJ的作用；对于使用Spring AOP的应用，ProxyFactoryBean和ProxyFactory都提供了AOP功能的封装，其中对于ProxyFactoryBean，可以在IOC容器中完成声明配置，而对于ProxyFactory则需要编程式地使用Spring AOP的功能。Spring的AspectJProxyFactory、ProxyFactoryBean和ProxyFactory封装了代理对象AopProxy的生成过程，代理对象的生成实现过程由JDK的Proxy和CGLIB第三方来实现。&lt;/p&gt;

&lt;p&gt;下面我们具体分析下ProxyFactoryBean，ProxyFactoryBean是一个FactoryBean，FactoryBean一般是如何生成Bean的呢？在调用getBean方法-&amp;gt;doGetBean方法中，我们可以看到无论是直接取单例的bean，还是创建单例、多例、自定义生命周期的bean，都会经过bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);这个方法，深入进去会发现最终会调用FactoryBean的getObject方法生产指定Bean的实例对象（Spring中具体的getObject的实现方法有70多个），也就是说对于FactoryBean而言，调用getBean(String BeanName)得到的是具体某个Bean对象（在getObject中具体实现的）而不是FactoryBean对象本身，如果想得到FactoryBean对象本身，只需要加上&amp;amp;符号即可。在FactoryBean的实现原理中我们可以发现工厂模式和装饰器模式的具体应用。&lt;/p&gt;

&lt;p&gt;对于ProxyFactoryBean来说，生成代理对象，也是通过getObject方法封装（修饰）了对目标对象增加的增强处理。那么我们具体分析下ProxyFactoryBean中的getObject方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public Object getObject() throws BeansException {
    //初始化通知器链
    initializeAdvisorChain();
    //区分singleton和prototype，生成对应的proxy代理对象
    if (isSingleton()) {
        return getSingletonInstance();
    }
    else {
        if (this.targetName == null) {
            logger.warn(&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot; +
                    &quot;Enable prototype proxies by setting the 'targetName' property.&quot;);
        }
        return newPrototypeInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的初始化通知器链只发生在第一次通过ProxyFactoryBean去获取代理对象的时候，在initializeAdvisorChain方法里有一个标志位advisorChainInitialized来保证这一点。&lt;/p&gt;

&lt;p&gt;生成单例代理对象是在getSingletonInstance方法中完成的，它是生成AopProxy代理对象的调用入口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private synchronized Object getSingletonInstance() {
    if (this.singletonInstance == null) {
        this.targetSource = freshTargetSource();
        if (this.autodetectInterfaces &amp;amp;&amp;amp; getProxiedInterfaces().length == 0 &amp;amp;&amp;amp; !isProxyTargetClass()) {
            // Rely on AOP infrastructure to tell us what interfaces to proxy.
            Class&amp;lt;?&amp;gt; targetClass = getTargetClass();
            if (targetClass == null) {
                throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);
            }
            setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));
        }
        // Initialize the shared singleton instance.
        super.setFrozen(this.freezeProxy);
        //通过代理工厂来生成对应的代理对象
        this.singletonInstance = getProxy(createAopProxy());
    }
    return this.singletonInstance;
}

protected Object getProxy(AopProxy aopProxy) {
    return aopProxy.getProxy(this.proxyClassLoader);
}

protected final synchronized AopProxy createAopProxy() {
    if (!this.active) {
        activate();
    }
    //通过AopProxyFactory工厂类来获取Aop的代理对象AopProxy，生成什么样的代理对象由AdivisedSupport决定，AdivisedSupport作为参数传入createAopProxy方法中，这里表示为this。
    return getAopProxyFactory().createAopProxy(this);
}

@Override
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        //从AdvisedSupport中获取目标对象class
        Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                    &quot;Either an interface or a target is required for proxy creation.&quot;);
        }
        //如果targetClass是接口类则使用JDK来生成代理对象，否则使用CGLIB来生成。
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        return new ObjenesisCglibAopProxy(config);
    }
    else {
    	//默认使用JDK来生成代理对象
        return new JdkDynamicAopProxy(config);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-AOP分析&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/597dadc80001f1ff09520680.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-AOP分析&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何拦截对目标对象方法的调用？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于JDK的代理对象，拦截使用的是InvocationHandler的invoke回调入口；对于CGLIB的代理对象，拦截是有设置好的回调callback方法（intercept方法）来完成的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    MethodInvocation invocation;
    Object oldProxy = null;
    boolean setProxyContext = false;

    TargetSource targetSource = this.advised.targetSource;
    Class&amp;lt;?&amp;gt; targetClass = null;
    Object target = null;

    try {
        if (!this.equalsDefined &amp;amp;&amp;amp; AopUtils.isEqualsMethod(method)) {
            // The target does not implement the equals(Object) method itself.
            return equals(args[0]);
        }
        else if (!this.hashCodeDefined &amp;amp;&amp;amp; AopUtils.isHashCodeMethod(method)) {
            // The target does not implement the hashCode() method itself.
            return hashCode();
        }
        else if (method.getDeclaringClass() == DecoratingProxy.class) {
            // There is only getDecoratedClass() declared -&amp;gt; dispatch to proxy config.
            return AopProxyUtils.ultimateTargetClass(this.advised);
        }
        else if (!this.advised.opaque &amp;amp;&amp;amp; method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;
                method.getDeclaringClass().isAssignableFrom(Advised.class)) {
            // Service invocations on ProxyConfig with the proxy config...
            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
        }

        Object retVal;

        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }

        // 获取目标对象
        target = targetSource.getTarget();
        if (target != null) {
            targetClass = target.getClass();
        }

        // 获取拦截器链
        List&amp;lt;Object&amp;gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // 如果没有设定拦截器则直接调用目标对象的对应方法
        if (chain.isEmpty()) {
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        }
        else {
            // We need to create a method invocation...
            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // Proceed to the joinpoint through the interceptor chain.
            retVal = invocation.proceed();
        }

        // Massage return value if necessary.
        Class&amp;lt;?&amp;gt; returnType = method.getReturnType();
        if (retVal != null &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp; returnType.isInstance(proxy) &amp;amp;&amp;amp;
                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            // Special case: it returned &quot;this&quot; and the return type of the method
            // is type-compatible. Note that we can't help if the target sets
            // a reference to itself in another returned object.
            retVal = proxy;
        }
        else if (retVal == null &amp;amp;&amp;amp; returnType != Void.TYPE &amp;amp;&amp;amp; returnType.isPrimitive()) {
            throw new AopInvocationException(
                    &quot;Null return value from advice does not match primitive return type for: &quot; + method);
        }
        return retVal;
    }
    finally {
        if (target != null &amp;amp;&amp;amp; !targetSource.isStatic()) {
            // Must have come from TargetSource.
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}

@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    Object oldProxy = null;
    boolean setProxyContext = false;
    Class&amp;lt;?&amp;gt; targetClass = null;
    Object target = null;
    try {
        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }
        // May be null. Get as late as possible to minimize the time we
        // &quot;own&quot; the target, in case it comes from a pool...
        target = getTarget();
        if (target != null) {
            targetClass = target.getClass();
        }
        //获取AOP通知
        List&amp;lt;Object&amp;gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
        Object retVal;
        // 如果没有配置AOP通知，则直接调用目标对象的对应方法
        if (chain.isEmpty() &amp;amp;&amp;amp; Modifier.isPublic(method.getModifiers())) {
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = methodProxy.invoke(target, argsToUse);
        }
        else {
            // 启动AOP通知
            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
        }
        retVal = processReturnType(proxy, target, method, retVal);
        return retVal;
    }
    finally {
        if (target != null) {
            releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不管用什么方法生成的代理对象，（在invoke或intercept方法中）对拦截器的调用都是通过proceed方法实现的，在proceed方法中完成对目标对象的增强功能，这种实现是通过运行逐个具体的拦截器的拦截方法来完成的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public Object proceed() throws Throwable {
    // 从索引为-1的拦截器开始调用，并按序递增，拦截器方法调用完毕则开始调用目标对象的方法
    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
        return invokeJoinpoint();
    }

    Object interceptorOrInterceptionAdvice =
            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
        InterceptorAndDynamicMethodMatcher dm =
                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
        // 判断拦截器的拦截方法是否匹配当前的调用方法，匹配则调用拦截器（invoke）方法方法
        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
            return dm.interceptor.invoke(this);
        }
        else {
            // 不匹配则递归调用proceed
            return proceed();
        }
    }
    else {
        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先会根据配置来判断拦截器是否与当前的调用方法相匹配（matches），如果当前的调用方法与配置的拦截器相匹配，那么相应的拦截器就开始发挥作用。这个过程是一个递归遍历的过程，它会遍历在代理对象中设置的拦截器链中所有的拦截器，被匹配的拦截器被逐一调用，直到所有的拦截器都被遍历完，才是对目标对象的方法调用，这样就完成了对目标对象方法调用的增强。&lt;/p&gt;

&lt;p&gt;应该注意到，Advice通知不是直接对目标对象作用来完成增强的，而是对不同种类的通知通过AdviceAdapter适配器来实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;《Spring实战》&lt;/p&gt;

&lt;p&gt;《Spring技术内幕 深入解析Spring架构与设计原理》&lt;/p&gt;

</description>
        <pubDate>Fri, 21 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/07/21/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BAOP.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/07/21/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BAOP.html</guid>
        
        <category>java</category>
        
        <category>Spring</category>
        
        <category>源码</category>
        
        <category>AOP</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕设计模式-工厂模式</title>
        <description>&lt;p&gt;上篇我们讲了观察者模式、适配器模式和代理模式，在Java中应用很多的还有一个工厂模式，工厂模式分很多种，所以我们单列一篇文章来总结。&lt;/p&gt;

&lt;p&gt;工厂模式&lt;/p&gt;

&lt;p&gt;1、 传统方式&lt;/p&gt;

&lt;p&gt;传统要获取一个类的对象，通常的方法是在本类中通过一个new操作符产生一个指定类的对象实例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Produce1 {  
    public Produce1(){  
        //Produce1的构造函数
    }  
}  

public class Produce2 {  
    public Produce2(){  
        //Produce2的构造函数
    }  
}  

public class Client {  
    public static void main(String[] args) {  
        Produce1 p1 = new Produce1();  
        Produce2 p2 = new Produce2();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很显然如果用上面的方式获取少数的Produce的对象是可行的，但多了就不行了，而且会导致类与类之间的耦合度非常高，于是出现了工厂模式，工厂模式就是屏蔽创建对象的具体过程，用户只需要调用工厂方法就可以得到对象的实例。&lt;/p&gt;

&lt;p&gt;工厂模式按其复杂程度分为三类：简单工厂、工厂、抽象工厂模式。&lt;/p&gt;

&lt;p&gt;2、  简单工厂模式&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;一个抽象产品类，可以派生出多个具体产品类。&lt;/p&gt;

&lt;p&gt;一个具体工厂类，用于生产产品。&lt;/p&gt;

&lt;p&gt;简单工厂模式的类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式-工厂模式&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/597869370001b2f717940376.png&quot; style=&quot;width:100%&quot; alt=&quot;简单工厂模式的类图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Produce {  
    public create();
}  

public class Produce1 extends Produce {  
    public create() {  
        System.out.println(&quot;生产Produce1&quot;);  
    }  
}  
public class Produce2 extends Produce{  
    public create(){  
        System.out.println(&quot;生产Produce2&quot;);  
    }  
}  

public class Factory {  
    public Produce createProduce(int type) {  
        switch (type) {  

        case 1:  
            return new Produce1().create();  

        case 2:  
            return new Produce2().create();  

        default:  
            break;  
        }  
        return null;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、 工厂模式&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;一个抽象产品类，可以派生出多个具体产品类。&lt;/p&gt;

&lt;p&gt;一个抽象工厂类，可以派生出多个具体工厂类。&lt;/p&gt;

&lt;p&gt;每个具体工厂类只能创建一个具体产品类的实例。&lt;/p&gt;

&lt;p&gt;工厂模式的类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式-工厂模式&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/5978697c00011f5820700340.png&quot; style=&quot;width:100%&quot; alt=&quot;工厂模式的类图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Produce {  
    public create();
}  
public class Produce1 extends Produce {  
    public create() {  
        System.out.println(&quot;生产Produce1&quot;);  
    }  
}  
public class Produce2 extends Produce{  
    public create(){  
        System.out.println(&quot;生产Produce2&quot;);  
    }  
}  
interface Factory {  
    Produce createProduce();  
}  

public class Factory1 implements Factory{  

    public void createProduce() {  
        return new Produce1().create();  
    }  

}  
public class Factory2 implements Factory {  

    public void createProduce() {  
        return new Produce2().create();  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、 抽象工厂模式&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。&lt;/p&gt;

&lt;p&gt;一个抽象工厂类，可以派生出多个具体工厂类。&lt;/p&gt;

&lt;p&gt;每个具体工厂类可以创建多个具体产品类的实例。&lt;/p&gt;

&lt;p&gt;抽象工厂模式的类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式-工厂模式&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/597869ae000133b021240638.png&quot; style=&quot;width:100%&quot; alt=&quot;抽象工厂模式的类图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Java代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ProductA {

    void create();
}

interface ProductB {

    void create();
}

class ProductA1 implements ProductA{

    public void create() {
        System.out.println(&quot;生产ProductA1&quot;);
    }

}

class ProductA2 implements ProductA{

    public void create() {
        System.out.println(&quot;生产ProductA2&quot;);
    }

}

class ProductB1 implements ProductB{

    public void create() {
        System.out.println(&quot;生产ProductB1&quot;);
    }

}

class ProductB2 implements ProductB{

    public void create() {
        System.out.println(&quot;生产ProductB2&quot;);
    }

}
public interface Factory {

    ProductA createProductA();

    ProductB createProductB();

}
public class Factory1 implements Factory{

    public ProductA createProductA() {
        return new ProductA1();
    }

    public ProductB createProductB() {
        return new ProductB1();
    }

}

public class Factory2 implements Factory{

    public ProductA createProductA() {
        return new ProductA2();
    }

    public ProductB createProductB() {
        return new ProductB2();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Java的JDK中，我们能找到一个很典型的抽象工厂模型：迭代器。在Java JDK 1.2 引进了一个容器类接口，其中包含了一个iterator()方法，所有容器类均实现了该方法，iterator方法是一个工厂方法，它使得调用者不知道iterator对象是由哪个类实例化的。&lt;/p&gt;

&lt;p&gt;比如list.iterator()；set.iterator()；我们不必关心iterator方法返回值是什么，只需要知道迭代器支持什么样的容器接口，才能遍历出集合中的元素。&lt;/p&gt;

&lt;p&gt;List的Iterator的抽象工厂模式类图：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式-工厂模式&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/597869df0001fc1019820516.png&quot; style=&quot;width:100%&quot; alt=&quot;List的Iterator的抽象工厂模式类图&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/07/18/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/07/18/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</guid>
        
        <category>java</category>
        
        <category>设计模式</category>
        
        <category>工厂模式</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕Spring源码-依赖注入</title>
        <description>&lt;p&gt;上篇文章我们分析了IOC容器的初始化，可以看出初始化其实就是在IoC容器中建立BeanDefinition数据映射，但并没有对Bean的依赖关系进行注入，依赖注入是用户第一次向IoC容器索要Bean的时候触发的，调用BeanFactory的getBean方法将触发依赖注入，这个时候才会创建对象实例，也可以通过设置bean的lazy-init属性来让bean的实例化过程在容器初始化的过程就完成，如果通过设置Bean的lazy-init属性，那么在容器初始化这个bean的时候就会调用getBean去触发依赖注入。&lt;/p&gt;

&lt;p&gt;如果doGetBean方法在当前的IoC容器中找不到Bean，会到双亲BeanFactory中去取，如果当前的双亲容器找不到那就再顺着双亲BeanFactory链一直向上寻找。&lt;/p&gt;

&lt;p&gt;get某一个Bean的时候会依赖注入其所依赖的所有的Bean，触发getBean的递归调用，直到取到一个没有任何依赖的bean为止。&lt;/p&gt;

&lt;p&gt;依赖注入实现过程图：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-依赖注入&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59770a0900018d2e17240986.png&quot; style=&quot;width:100%&quot; alt=&quot;依赖注入实现过程图&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
     // BeanWrapper是用来持有创建出来的Bean对象的
     BeanWrapper instanceWrapper = null;
     //如果是单例，则将缓存中的同名Bean清除
     if (mbd.isSingleton()) {
          instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
     }
     if (instanceWrapper == null) {
     		//创建Bean实例对象
          instanceWrapper = createBeanInstance(beanName, mbd, args);
     }
     final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
     Class&amp;lt;?&amp;gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

     // Allow post-processors to modify the merged bean definition.
     synchronized (mbd.postProcessingLock) {
          if (!mbd.postProcessed) {
               applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
               mbd.postProcessed = true;
          }
     }

     // Eagerly cache singletons to be able to resolve circular references
     // even when triggered by lifecycle interfaces like BeanFactoryAware.
     boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
               isSingletonCurrentlyInCreation(beanName));
     if (earlySingletonExposure) {
          if (logger.isDebugEnabled()) {
               logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
                         &quot;' to allow for resolving potential circular references&quot;);
          }
          addSingletonFactory(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() {
               @Override
               public Object getObject() throws BeansException {
                    return getEarlyBeanReference(beanName, mbd, bean);
               }
          });
     }

     // 初始化Bean实例，执行依赖注入
     Object exposedObject = bean;
     try {
          populateBean(beanName, mbd, instanceWrapper);
          if (exposedObject != null) {
               exposedObject = initializeBean(beanName, exposedObject, mbd);
          }
     }
     catch (Throwable ex) {
          if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
               throw (BeanCreationException) ex;
          }
          else {
               throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
          }
     }

     if (earlySingletonExposure) {
          Object earlySingletonReference = getSingleton(beanName, false);
          if (earlySingletonReference != null) {
               if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
               }
               else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
                    String[] dependentBeans = getDependentBeans(beanName);
                    Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;String&amp;gt;(dependentBeans.length);
                    for (String dependentBean : dependentBeans) {
                         if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                              actualDependentBeans.add(dependentBean);
                         }
                    }
                    if (!actualDependentBeans.isEmpty()) {
                         throw new BeanCurrentlyInCreationException(beanName,
                                   &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
                                   StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                   &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                                   &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                                   &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                                   &quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
                    }
               }
          }
     }

     // Register bean as disposable.
     try {
          registerDisposableBeanIfNecessary(beanName, bean, mbd);
     }
     catch (BeanDefinitionValidationException ex) {
          throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
     }

     return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;依赖注入比较重要的两个方法：createBeanInstance和populateBean&lt;/p&gt;

&lt;p&gt;createBeanInstance实例化Bean对象的方法调用栈：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-依赖注入&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/597706160001eb1617380344.png&quot; style=&quot;width:100%&quot; alt=&quot;createBeanInstance方法调用栈&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {
    // Make sure bean class is actually resolved at this point.
    Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);

    if (beanClass != null &amp;amp;&amp;amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;amp;&amp;amp; !mbd.isNonPublicAccessAllowed()) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
    }

    if (mbd.getFactoryMethodName() != null)  {
        return instantiateUsingFactoryMethod(beanName, mbd, args);
    }

    // Shortcut when re-creating the same bean...
    boolean resolved = false;
    boolean autowireNecessary = false;
    if (args == null) {
        synchronized (mbd.constructorArgumentLock) {
            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                resolved = true;
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    if (resolved) {
        if (autowireNecessary) {
            return autowireConstructor(beanName, mbd, null, null);
        }
        else {
            return instantiateBean(beanName, mbd);
        }
    }

    // Need to determine the constructor...
    Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
        return autowireConstructor(beanName, mbd, ctors, args);
    }

    // No special handling: simply use no-arg constructor.
    return instantiateBean(beanName, mbd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;createBeanInstance中生成了Bean所包含的Java对象，Spring中用SimpleInstantiationStrategy类来生成Bean对象的实例，实例化Java对象的方法有两种：&lt;/p&gt;

&lt;p&gt;1、通过BeanUtils，它使用了JVM的反射功能来生成Java对象实例&lt;/p&gt;

&lt;p&gt;2、用CGLIB来生成，CGLIB是一种常用的字节码生成器的类库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {
     // Don't override the class with CGLIB if no overrides.
     if (bd.getMethodOverrides().isEmpty()) {
          Constructor&amp;lt;?&amp;gt; constructorToUse;
          synchronized (bd.constructorArgumentLock) {
               constructorToUse = (Constructor&amp;lt;?&amp;gt;) bd.resolvedConstructorOrFactoryMethod;
               if (constructorToUse == null) {
                    final Class&amp;lt;?&amp;gt; clazz = bd.getBeanClass();
                    if (clazz.isInterface()) {
                         throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
                    }
                    try {
                         if (System.getSecurityManager() != null) {
                              constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt;() {
                                   @Override
                                   public Constructor&amp;lt;?&amp;gt; run() throws Exception {
                                        return clazz.getDeclaredConstructor((Class[]) null);
                                   }
                              });
                         }
                         else {
                              constructorToUse =     clazz.getDeclaredConstructor((Class[]) null);
                         }
                         bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                    }
                    catch (Throwable ex) {
                         throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
                    }
               }
          }
		  //通过BeanUtils进行实例化，从这个方法中可以看到具体调用了ctor.newInstance()方法
          return BeanUtils.instantiateClass(constructorToUse);
     }
     else {
          // 使用CGLIB来实例化对象
          return instantiateWithMethodInjection(bd, beanName, owner);
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Bean对象生成好了之后，Spring用BeanWrapper来持有创建出来的Bean对象，接下来Spring通过populateBean方法来把这些Bean对象的依赖关系设置好，以完成整个依赖注入的过程。&lt;/p&gt;

&lt;p&gt;依赖注入的发生是在BeanWrapper的setPropertyValues中，具体的实现过程在其子类BeanWrapperImpl；createBeanInstance方法返回值就是一个BeanWrapper对象。再把BeanWrapper对象作为一个形参传入populateBean中。populateBean是对Bean的初始化，依赖注入就发生在这里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
     //这里通过解析BeanDefinition来获取property值
     PropertyValues pvs = mbd.getPropertyValues();

     if (bw == null) {
          if (!pvs.isEmpty()) {
               throw new BeanCreationException(
                         mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
          }
          else {
               // Skip property population phase for null instance.
               return;
          }
     }

     // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
     // state of the bean before properties are set. This can be used, for example,
     // to support styles of field injection.
     boolean continueWithPropertyPopulation = true;

     if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
          for (BeanPostProcessor bp : getBeanPostProcessors()) {
               if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                         continueWithPropertyPopulation = false;
                         break;
                    }
               }
          }
     }

     if (!continueWithPropertyPopulation) {
          return;
     }
     //开始进行依赖注入的过程，先处理autowire的注入，可以根据Bean的名字或类型来完成Bean的autowire
     if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
               mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
          MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

          // Add property values based on autowire by name if applicable.
          if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
               autowireByName(beanName, mbd, bw, newPvs);
          }

          // Add property values based on autowire by type if applicable.
          if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
               autowireByType(beanName, mbd, bw, newPvs);
          }

          pvs = newPvs;
     }

     boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
     boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

     if (hasInstAwareBpps || needsDepCheck) {
          PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
          if (hasInstAwareBpps) {
               for (BeanPostProcessor bp : getBeanPostProcessors()) {
                    if (bp instanceof InstantiationAwareBeanPostProcessor) {
                         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                         pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                         if (pvs == null) {
                              return;
                         }
                    }
               }
          }
          if (needsDepCheck) {
               checkDependencies(beanName, mbd, filteredPds, pvs);
          }
     }
     //对属性进行注入
     applyPropertyValues(beanName, mbd, bw, pvs);
}

protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
     if (pvs == null || pvs.isEmpty()) {
          return;
     }

     MutablePropertyValues mpvs = null;
     List&amp;lt;PropertyValue&amp;gt; original;

     if (System.getSecurityManager() != null) {
          if (bw instanceof BeanWrapperImpl) {
               ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
          }
     }

     if (pvs instanceof MutablePropertyValues) {
          mpvs = (MutablePropertyValues) pvs;
          if (mpvs.isConverted()) {
               // Shortcut: use the pre-converted values as-is.
               try {
                    bw.setPropertyValues(mpvs);
                    return;
               }
               catch (BeansException ex) {
                    throw new BeanCreationException(
                              mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
               }
          }
          original = mpvs.getPropertyValueList();
     }
     else {
          original = Arrays.asList(pvs.getPropertyValues());
     }

     TypeConverter converter = getCustomTypeConverter();
     if (converter == null) {
          converter = bw;
     }
     //对BeanDefinition的解析是在这个valueResolver中完成的
     BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

     // Create a deep copy, resolving any references for values.
     List&amp;lt;PropertyValue&amp;gt; deepCopy = new ArrayList&amp;lt;PropertyValue&amp;gt;(original.size());
     boolean resolveNecessary = false;
     for (PropertyValue pv : original) {
          if (pv.isConverted()) {
               deepCopy.add(pv);
          }
          else {
               String propertyName = pv.getName();
               Object originalValue = pv.getValue();
               //解析BeanDefinition
               Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
               Object convertedValue = resolvedValue;
               boolean convertible = bw.isWritableProperty(propertyName) &amp;amp;&amp;amp;
                         !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
               if (convertible) {
                    convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
               }
               // Possibly store converted value in merged bean definition,
               // in order to avoid re-conversion for every created bean instance.
               if (resolvedValue == originalValue) {
                    if (convertible) {
                         pv.setConvertedValue(convertedValue);
                    }
                    deepCopy.add(pv);
               }
               else if (convertible &amp;amp;&amp;amp; originalValue instanceof TypedStringValue &amp;amp;&amp;amp;
                         !((TypedStringValue) originalValue).isDynamic() &amp;amp;&amp;amp;
                         !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
                    pv.setConvertedValue(convertedValue);
                    deepCopy.add(pv);
               }
               else {
                    resolveNecessary = true;
                    deepCopy.add(new PropertyValue(pv, convertedValue));
               }
          }
     }
     if (mpvs != null &amp;amp;&amp;amp; !resolveNecessary) {
          mpvs.setConverted();
     }

     // Set our (possibly massaged) deep copy.
     try {
          bw.setPropertyValues(new MutablePropertyValues(deepCopy));
     }
     catch (BeansException ex) {
          throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;populateBean解析BeanDefinition中设置的property值，获取到Bean的依赖信息并设置Bean的依赖关系。通过使用BeanDefinitionResolver对BeanDefinition进行解析，然后注入到property中。&lt;/p&gt;

&lt;p&gt;resolveValueIfNecessary方法包含了对所有的注入类型的处理，里面包含各种instanceof的判断，比如RuntimeBeanReference，Array，List，Map等数据类型，RuntimeBeanReference是在对BeanDefinition进行解析时生成的数据对象，是在载入BeanDefinition时根据配置生成的，如果RuntimeBeanReference是在双亲容器中则从双亲容器中去获取Bean（通过getBean方法）。&lt;/p&gt;

&lt;p&gt;完成解析过程后就已经是为依赖注入做好了准备条件，依赖注入的发生是在BeanWrapper的setPropertyValues中，具体的实现过程在其子类BeanWrapperImpl。&lt;/p&gt;

&lt;p&gt;setPropertyValue的方法调用栈：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-依赖注入&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/597707120001cc6617260690.png&quot; style=&quot;width:100%&quot; alt=&quot;setPropertyValue的方法调用栈&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一、依赖注入的概念和触发方法（getBean）&lt;/p&gt;

&lt;p&gt;二、依赖注入有两个重要的方法：createBeanInstance和populateBean&lt;/p&gt;

&lt;p&gt;—&amp;gt;以beanName、BeanDefinition等作为输入，执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)&lt;/code&gt;
创建BeanWrapper实例，BeanWrapper持有创建出来的Bean对象，在方法中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &lt;/code&gt;来生成Bean对象。Spring有两种方式生成Bean对象，
第一是通过BeanUtils，它使用了JVM的反射功能来生成Java对象实例。
第二是用CGLIB来生成，CGLIB是一种常用的字节码生成器的类库。&lt;/p&gt;

&lt;p&gt;—&amp;gt;以createBeanInstance生成好的BeanWrapper对象作为输入，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)&lt;/code&gt;
完成依赖注入过程；&lt;/p&gt;

&lt;p&gt;—&amp;gt;在方法populateBean中， 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PropertyValues pvs = mbd.getPropertyValues();&lt;/code&gt;
解析BeanDefinition来获取property值；&lt;/p&gt;

&lt;p&gt;—&amp;gt;以上一步获得的PropertyValues和BeanWrapper对象等作为输入，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)&lt;/code&gt;完成属性的注入；&lt;/p&gt;

&lt;p&gt;—&amp;gt;在方法applyPropertyValues中，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;bw.setPropertyValues(mpvs);&lt;/code&gt;完成属性的注入；以beanName和BeanDefinition作为输入，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);&lt;/code&gt;生成BeanDefinitionValueResolver对象，这个对象用来解析BeanDefinition；调用
&lt;code class=&quot;highlighter-rouge&quot;&gt;Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);&lt;/code&gt;解析BeanDefinition，然后通过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object convertedValue = resolvedValue;
pv.setConvertedValue(convertedValue);
deepCopy.add(pv);
bw.setPropertyValues(new MutablePropertyValues(deepCopy)); 注入到BeanWrapper对象的property中。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此我们就完成了BeanDefinition的依赖注入，生成了Bean的持有对象BeanWrapper，用getWrappedInstance()方法就可以得到这个封装的bean的实例。BeanWrapperImpl里面的Object就是BeanWrapper“包裹”的bean，通过getWrappedInstance()方法对外提供。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、Spring 4.3.3源码&lt;/p&gt;

&lt;p&gt;2、《Spring技术内幕 深入解析Spring架构与设计原理》&lt;/p&gt;

</description>
        <pubDate>Thu, 13 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/07/13/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/07/13/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html</guid>
        
        <category>java</category>
        
        <category>Spring</category>
        
        <category>源码</category>
        
        <category>依赖注入</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕Spring源码-IoC容器</title>
        <description>&lt;p&gt;我们都知道IoC（Inversion of control）是控制反转，控制反转的核心是依赖反转，那到底什么是“依赖反转”，“哪些方面的控制被反转了？”－－依赖对象的获得被反转了。通过依赖注入的方式获取类对象实例而不是传统的在类自身通过新建（new）类对象来获取。所以这种反转是“责任”的反转，传统的这种对对象的管理是由java类自身来管理，而Spring通过IoC容器来管理，这种对对象的依赖关系的管理被反转了，转到IoC容器来了。对象之间的相互依赖关系由IoC容器进行管理，并由IoC容器完成对象的注入。这种做法降低了类之间的耦合度，同时提高了代码的可测试性。&lt;/p&gt;

&lt;p&gt;IoC容器主要有两个容器系列：BeanFactory和ApplicationContext。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC容器主要的接口设计图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59744b1b0001c33d17101006.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、BeanFactory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接口类BeanFactory提供了Spring中所有IOC容器的最基本的功能规范，来看看&lt;strong&gt;BeanFactory的组织结构图&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/597444f50001bb0106261194.png&quot; style=&quot;width:50%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface BeanFactory {
    //如果我们加了这个转义字符，则得到的是这个IOC容器本身，否则得到的是IOC容器的实例
     String FACTORY_BEAN_PREFIX = “&amp;amp;”;
     Object getBean(String name) throws BeansException;
     &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
     &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException;
     Object getBean(String name, Object... args) throws BeansException;
     &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, Object... args) throws BeansException;
     boolean containsBean(String name);
     boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
     boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
     boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
     boolean isTypeMatch(String name, Class&amp;lt;?&amp;gt; typeToMatch) throws NoSuchBeanDefinitionException;
     Class&amp;lt;?&amp;gt; getType(String name) throws NoSuchBeanDefinitionException;
     String[] getAliases(String name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的IoC容器都需要满足BeanFactory这个基本的接口定义，Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系。对IoC容器来说，BeanDefinition抽象了对Bean的定义的一种数据类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BeanDefinition的组织结构如下图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/59744544000144cd06161220.png&quot; style=&quot;width:50%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BeanFactory是一个接口类，我们来看看一个BeanFactory的具体实现类XmlBeanFactory，从名字上就能看出来这是一个与xml相关的BeanFactory，它是一个可以读取以XML文件方式定义的BeanDefinition的IoC容器。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/597445bc000120d818280524.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class XmlBeanFactory extends DefaultListableBeanFactory {

     private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);

     public XmlBeanFactory(Resource resource) throws BeansException {
          this(resource, null);
     }

     public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
          super(parentBeanFactory);
          this.reader.loadBeanDefinitions(resource);
     }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在XmlBeanFactory这个IOC容器中，初始化了一个XmlBeanDefinitionReader，用这个XmlBeanDefinitionReader来处理XML中的BeanDefinition对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;手工创建IOC容器&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class XmlIOCTest {

     public static void main(String[] args) {
//定义BeanDefinition的信息来源，在XmlBeanFactory中作为构造函数的参数传给XmlBeanFactory     
		  ClassPathResource resource = new ClassPathResource(&quot;config\\beans.xml”);
//创建一个BeanFactory的IoC容器
          DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
//创建一个加载BeanDefinition的读取器，通过一个回调配置给BeanFactory
          XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
//从信息来源中加载BeanDefinition
          reader.loadBeanDefinitions(resource);
          Admin admin = (Admin)factory.getBean(&quot;admin&quot;);
          admin.setName(&quot;ming.zhou&quot;);
          admin.setPassword(&quot;123&quot;);
          admin.setStatus(1);
          System.out.println(admin);
     }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输入结果：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Admin{id=null, name='ming.zhou', password='123', status=1}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由上我们可以总结IoC容器的初始化过程（refresh()方法来启动）：（源码查看可以通过loadBeanDefinitions逐步查看）
Resource定位过程－－BeanDefinition的载入－－向IoC容器注册BeanDefinition（调用BeanDefinitionRegistry接口来实现，每个bean放在hashMap中存储）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、ApplicationContext&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接口类ApplicationContext是高级形态意义的IOC容器。&lt;/p&gt;

&lt;p&gt;IoC容器的初始化是由refresh()方法来启动的，它标志这IoC容器的正式启动，启动过程包含BeanDefinition的Resource定位、载入和注册三个基本过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 Resource定位&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resource接口设计图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片5=&quot;&quot; src=&quot;http://img.mukewang.com/597450100001ace507340894.png&quot; style=&quot;width:50%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FileSystemApplicationContext，支持XML定义的BeanDefinition的ApplicationContext，可指定以文件形式的BeanDefinition的读入，文件放在本地文件系统中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FileSystemApplicationContext的继承关系图:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片6=&quot;&quot; src=&quot;http://img.mukewang.com/597447b90001efaa07380916.png&quot; style=&quot;width:50%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;getResourceByPath()的调用栈：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片7=&quot;&quot; src=&quot;http://img.mukewang.com/597447e10001335817380988.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过查看FileSystemApplicationContext中的getResourceByPath()的方法调用栈可以发现这个&lt;strong&gt;IOC容器资源定位的实现过程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片8=&quot;&quot; src=&quot;http://img.mukewang.com/597447fa0001cf1e17800904.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;类AbstractRefreshableApplicationContext对容器初始化源码分析:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected final void refreshBeanFactory() throws BeansException {
//如果已经建立了BeanFactory，则销毁并关闭该BeanFactory，保证refresh以后使用的是新建立起来的IoC容器
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory);
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
    }
}

@Override
public Resource getResource(String location) {
    Assert.notNull(location, &quot;Location must not be null&quot;);

    for (ProtocolResolver protocolResolver : this.protocolResolvers) {
        Resource resource = protocolResolver.resolve(location, this);
        if (resource != null) {
            return resource;
        }
    }

    if (location.startsWith(&quot;/&quot;)) {
        return getResourceByPath(location);
    }
    //处理带有classpath标识的Resource
    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
    }
    else {
        try {
            // 处理URL标识的Resource
            URL url = new URL(location);
            return new UrlResource(url);
        }
        catch (MalformedURLException ex) {
            // No URL -&amp;gt; resolve as resource path.
            return getResourceByPath(location);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整个过程起源于FileSystemApplicationContext的构造函数的初始化，通过构造函数中的refresh()方法来启动整个应用，在AbstractRefreshableApplicationContext中的refreshBeanFactory()方法中我们可以看到使用了createBeanFactory构建了一个DefaultListableBeanFactory的IOC容器，同时启动资源载入（AbstractRefreshableApplicationContext中的loadBeanDefinitions()方法是抽象方法，因为载入的方式有很多种，具体的载入操作交由其子类去具体实现，这里的子类就是
XmlWebApplicationContext
）；具体的资源载入在XmlWebApplicationContext的loadBeanDefinitions()中读入BeanDefinition时完成（loadBeanDefinitions方法在方法调用栈中第一次出现是在XmlWebApplicationContext中的），载入的具体实现在XmlWebApplicationContext的基类AbstractBeanDefinitionReader中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 BeanDefinition的载入与解析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;loadBeanDefinitions的调用方法栈:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片9=&quot;&quot; src=&quot;http://img.mukewang.com/597449790001262916520684.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了Resource定位对象后，开始BeanDefinition的载入与解析的工作，按照Spring的Bean定义规则来对这个XML的文档树进行解析了，解析工作是交给BeanDefinitionParserDelegate来完成的。BeanDefinition的载入分为两部分：首先是通过调用XML的解析器得到document对象，但这些document对象并没有按照Spring的Bean规则进行解析；然后在完成通用的XML解析后，才开始按照Spring的Bean规则进行解析。按照Spring的Bean规则进行解析过程是在documentReader中实现的，把Bean的id、name、aliase等属性元素读取出来后设置到生成的BeanDefinitionHolder中去。BeanDefinitionHolder是BeanDefinition的封装类，封装了BeanDefinition，Bean的名字和别名，用它来完成向IoC容器注册。&lt;/p&gt;

&lt;p&gt;BeanDefinition的载入与解析过程源码解析如下，有点长，但不难，耐心看下去思路还是很清晰的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
//调用入口
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(new EncodedResource(resource));
}
//载入XML形式的BeanDefinition
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
    }

    Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
    if (currentResources == null) {
        currentResources = new HashSet&amp;lt;EncodedResource&amp;gt;(4);
        this.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    if (!currentResources.add(encodedResource)) {
        throw new BeanDefinitionStoreException(
                &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
    }
    //得到XML文件，并获取IO的InputSource准备进行读取
    try {
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(
                &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
    }
    finally {
        currentResources.remove(encodedResource);
        if (currentResources.isEmpty()) {
            this.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}
//具体的读取过程
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {
    try {
        //调用XML的解析器得到document对象
        Document doc = doLoadDocument(inputSource, resource);
        //启动对BeanDefinition解析过程
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;IOException parsing XML document from &quot; + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
    }
}
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    //得到BeanDefinitionDocumentReader来对XML的BeanDefinition进行解析
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    int countBefore = getRegistry().getBeanDefinitionCount();
    //调用BeanDefinitionDocumentReader的registerBeanDefinitions完成具体的解析过程
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    return getRegistry().getBeanDefinitionCount() - countBefore;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;BeanDefinitionDocumentReader类的registerBeanDefinitions方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug(&quot;Loading bean definitions&quot;);
    Element root = doc.getDocumentElement();
    doRegisterBeanDefinitions(root);
}
protected void doRegisterBeanDefinitions(Element root) {
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isInfoEnabled()) {
                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
                            &quot;] not matching: &quot; + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    parseBeanDefinitions(root, this.delegate);
    postProcessXml(root);

    this.delegate = parent;
}
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    //BeanDefinitionHolder是BeanDefinition的封装类，封装了BeanDefinition，Bean的名字和别名，用它来完成向IoC容器注册
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            //向IoC容器注册解析得到的BeanDefinition
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
                    bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
//BeanDefinitionParserDelegate类方法，具体的解析过程，把Bean的id、name、aliase等属性元素读取出来后设置到生成的BeanDefinitionHolder中去
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
    //取得&amp;lt;Bean&amp;gt;元素中的id、name、aliase属性的值
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;String&amp;gt;();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {
        beanName = aliases.remove(0);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName +
                    &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
        }
    }

    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }
    //对Bean元素的详细解析，比如class、parent、init-method、destroy-method等
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    // Register an alias for the plain bean class name, if still possible,
                    // if the generator returned the class name plus a suffix.
                    // This is expected for Spring 1.2/2.0 backwards compatibility.
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &amp;amp;&amp;amp;
                            beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; +
                            &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;载入与解析的方法调用流程图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片10=&quot;&quot; src=&quot;http://img.mukewang.com/59744a180001978917380986.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过以上的载入过程，我们大致完成了IoC容器的Bean对象的数据准备工作或初始化工作，但现在IoC容器BeanDefinition中还只是存在些静态的配置信息，还不能供IoC容器直接使用，要想让IoC容器发挥作用还需要进行BeanDefinition的注册。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 BeanDefinition的注册&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注册过程相对简单，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的，这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册，通过源码分析，我们可以看到在IoC容器中是持有一个HashMap来装BeanDefinition数据的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;registerBeanDefinition的调用方法栈:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕Spring源码-IoC源码&quot; 图片11=&quot;&quot; src=&quot;http://img.mukewang.com/59744a4700014e0a17340788.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕Spring源码-IoC源码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt;(256);
public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}

@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {

    Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
    Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

    if (beanDefinition instanceof AbstractBeanDefinition) {
        try {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    &quot;Validation of bean definition failed&quot;, ex);
        }
    }

    BeanDefinition oldBeanDefinition;

    //检查是不是有同名字的BeanDefinition已经在IoC容器中注册了，如果存在且不允许覆盖则抛出异常
    oldBeanDefinition = this.beanDefinitionMap.get(beanName);
    if (oldBeanDefinition != null) {
        if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean '&quot; + beanName +
                    &quot;': There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);
        }
        else if (oldBeanDefinition.getRole() &amp;lt; beanDefinition.getRole()) {
            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
            if (this.logger.isWarnEnabled()) {
                this.logger.warn(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
                        &quot;' with a framework-generated bean definition: replacing [&quot; +
                        oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
            }
        }
        else if (!beanDefinition.equals(oldBeanDefinition)) {
            if (this.logger.isInfoEnabled()) {
                this.logger.info(&quot;Overriding bean definition for bean '&quot; + beanName +
                        &quot;' with a different definition: replacing [&quot; + oldBeanDefinition +
                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
            }
        }
        else {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
                        &quot;' with an equivalent definition: replacing [&quot; + oldBeanDefinition +
                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
            }
        }
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            //注册过程需要synchronized，保证数据的一致性
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;String&amp;gt;(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                if (this.manualSingletonNames.contains(beanName)) {
                    Set&amp;lt;String&amp;gt; updatedSingletons = new LinkedHashSet&amp;lt;String&amp;gt;(this.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    this.manualSingletonNames = updatedSingletons;
                }
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            this.manualSingletonNames.remove(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (oldBeanDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注册过程会检查是不是有同名字的BeanDefinition已经在IoC容器中注册了，如果存在且不允许覆盖则抛出异常，注册过程需要synchronized，保证数据的一致性。&lt;/p&gt;

&lt;p&gt;完成了BeanDefinition的注册，IOC容器的初始化过程就结束了，在这个IOC容器中已经有了整个Bean的配置信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IoC的概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;（提供IoC容器最基本的功能规范），BeanFactory接口的基本方法有哪些？从手工创建IOC容器中可以获悉IoC的建立与初始化过程（四步：资源定位-&amp;gt;创建BeanFactory的IoC容器-&amp;gt;创建一个加载BeanDefinition的读取器，通过一个回调配置给BeanFactory-&amp;gt;从已定位的资源中加载BeanDefinition）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;（高级形态意义的IOC容器），以FileSystemApplicationContext为例解析ApplicationContext的初始化过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;资源定位&lt;/strong&gt;：Resource getResource(String location)，不同标识对应不同的Resource，classPath-&amp;gt;classPathResource；url-&amp;gt;ServletContextResource；否则调用容器本身的getResourceByPath方法获取Resource&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;载入与解析资源&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;int loadBeanDefinitions(Resource resource)&lt;/code&gt;，input是之前定位好的资源对象Resource，输出是这次加载了多少个BeanDefinition；载入与解析的工作分为两步：&lt;/p&gt;

&lt;p&gt;第一：通过调用XML的解析器得到document对象；&lt;/p&gt;

&lt;p&gt;第二：&lt;/p&gt;

&lt;p&gt;—&amp;gt;将得到的document对象作为输入传入&lt;code class=&quot;highlighter-rouge&quot;&gt;registerBeanDefinitions(Document doc, Resource resource)&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;—&amp;gt;然后使用BeanDefinitionDocumentReader类来按照Spring的Bean规则解析Document对象，得到Document的Element对象，&lt;code class=&quot;highlighter-rouge&quot;&gt;Element root = doc.getDocumentElement()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;—&amp;gt;解析element对象，&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)&lt;/code&gt;，将Element作为输入，在parseBeanDefinitionElement方法中解析，取得&lt;Bean&gt;元素中的id、name、aliase属性的值，对Bean元素的详细解析，比如class、parent、init-method、destroy-method等&lt;/Bean&gt;&lt;/p&gt;

&lt;p&gt;—&amp;gt;最终将解析的数据作为输入，生成BeanDefinitionHolder的实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;资源的注册&lt;/strong&gt;：这部分相对载入与解析要更简单一些，将这部分生成的BeanDefinitionHolder作为输入，传入&lt;code class=&quot;highlighter-rouge&quot;&gt;void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;—&amp;gt;从BeanDefinitionHolder对象中获取beanName和BeanDefinition，&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String beanName = definitionHolder.getBeanName();
registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;并以beanName和BeanDefinition作为输入去注册Bean，用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;new ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt;(256)&lt;/code&gt;的hashMap来维护Bean。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、Spring 4.3.3源码&lt;/p&gt;

&lt;p&gt;2、《Spring 技术内幕（深入解析Spring架构与设计原理）》&lt;/p&gt;

</description>
        <pubDate>Sun, 02 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/07/02/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BIoC.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/07/02/%E6%AD%BB%E7%A3%95Spring%E6%BA%90%E7%A0%81%E4%B9%8BIoC.html</guid>
        
        <category>java</category>
        
        <category>Spring</category>
        
        <category>源码</category>
        
        <category>IoC</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕设计模式-观适代装</title>
        <description>&lt;p&gt;最近看spring源码的时候会看到很多经典的设计模式，索性就把几个常用的经典的设计模式再复习总结遍。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;观察者模式&lt;/li&gt;
  &lt;li&gt;适配器模式&lt;/li&gt;
  &lt;li&gt;代理模式&lt;/li&gt;
  &lt;li&gt;装饰器模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一、观察者模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;观察者模式是在维护多个对象之间的一对多的依赖关系，也就是说，当一个对象的状态发生了改变时会通知所有依赖于它的对象，好让这些对象对新的变化做出反应。观察者模式既可以有效的维护对象的一致性，又能最大限度的降低对象之间的耦合度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;长什么样：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式&quot; src=&quot;http://img.mukewang.com/597098400001ecc520880750.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕设计模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的UML类图可以看出：有两个接口，一个是主体对象接口，一个是观察者接口。主体对象接口定义了通知的方法，实现它的类Boss中有新增/删除观察者的方法；观察者接口定义了更新的方法，当boss的状态改变后，boss会notify所有的观察者来执行update方法做相应的更新操作。这么说可能还有点抽象，下面直接上代码demo。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么做：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface BossInterface
{
    void notify();
}

public interface Observer
{
    void update();
}

public class Boss implements BossInterface
{
    private String bossSay;

    private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;Observer&amp;gt;();

    // 增加观察者
    public void addObserver(Observer observer)
    {
        this.observers.add(observer);
    }

    // 移除观察者
    public void deleteObserver(Observer observer)
    {
        this.observers.remove(observer);
    }

    //获取Boss状态
    public String getBossSay()
    {
        return bossSay;
    }

    //设置Boss状态
    public void setBossSay(String bossSay)
    {
        this.bossSay = bossSay;
    }

    //通知所有的观察者工作
    public void notify()
    {
        foreach (Observer observer in observers)
        {
            observer.update();
        }
    }
}

public class Coder implements Observer
{
    private Boss boss;

    public Coder(Boss boss)
    {
        this.boss = boss;
    }

    // 更新状态
    public void update()
    {
        if (boss.getBossSay() == &quot;兄弟们，为了世界和平，一起Hello,world吧！&quot;)
        {
            //开始写代码
        }
    }
}

public class UI extends Observer
{
    private Boss boss;

    public UI(Boss boss)
    {
        this.boss = boss;
    }

    // 更新状态
    public void update()
    {
        if (boss.getBossSay() == &quot;兄弟们，为了世界和平，一起Hello,world吧！&quot;)
        {
            //开始写UI
        }
    }
}

public class PM extends Observer
{
    private Boss boss;

    public PM(Boss boss)
    {
        this.boss = boss;
    }

    // 更新状态
    public void update()
    {
        if (boss.getBossSay() == &quot;兄弟们，为了世界和平，一起Hello,world吧！&quot;)
        {
            //开始写项目的各种文档，请程序员、测试、运维、美工吃饭
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;二、适配器模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;适配器模式就是将那些原本由于接口不兼容而不能一起工作的类适配成可以在一起工作的类，适配器是一种增强或转换的工具，将那些不符合我们的需求但已经存在的类的接口，在不修改这类接口本身的情况下适配成我们想要的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;长什么样：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式&quot; src=&quot;http://img.mukewang.com/5970988f000189c215220838.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕设计模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么做：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class ExistingClass {
    public void enhanceMethod() {
        System.out.println(&quot;被适配类具有 特殊功能...&quot;);
    }
}

// 目标接口，或称为标准接口
interface RequiredInterface {
    public void requiredMethod();
}

// 原本存在的类，只提供普通功能
class OriginalClass implements RequiredInterface {
    public void requiredMethod() {
        System.out.println(&quot;普通类 具有 普通功能...&quot;);
    }
}

// 适配器类，继承了被适配类，同时实现标准接口
class Adapter extends ExistingClass implements RequiredInterface{
    public void requiredMethod() {
        super.enhanceMethod();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、代理模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代理模式顾名思义就是使用了一个代理人，有代理就有在代理背后的目标对象，代理模式的意义在你不直接对目标对象进行操作，而是通过代理对象来操作目标对象，那么在代理对象这一层你就可以对目标对象进行很多增强的工作并且不用改变目标对象的代码。在实际工作中也很有指导意义，就是永远别去改别人已经写好的上线测试过了的代码，你可以利用代理模式来扩展目标对象的功能。&lt;/p&gt;

&lt;p&gt;举个栗子：你购买了一个第三方的工具，当你在使用上问题的时候，你可能不能直接找到写这个工具的程序猿/媛，但你可以找到售后服务人员或技术支持人员，这个角色充当的就是代理对象，程序猿/媛就是目标对象，你找售后人员反映问题，售后把问题总结后集中反馈给程序猿/媛，他们去修改代码，给出个解决方案，具体的流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/5971caec0001d6c913360472.png&quot; style=&quot;width:100%&quot; alt=&quot;死磕设计模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出，用户先去调售后服务（代理对象），她是我们的程序猿/媛（目标对象）的代理，代理对象是对目标对象的扩展，同时代理对象会调用目标对象的方法来完成目的。&lt;/p&gt;

&lt;p&gt;代理模式根据其代理的方式分为三种：静态代理，动态代理和Cglib代理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 静态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代理方式：代理对象和目标对象必须实现同一个接口或继承同一个父类，通过调用代理对象的相同的方法来调用目标对象的方法。&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 制定好的行业标准
*/
public interface OperationStandard {

    void operate();
}

/**
* 目标对象，实现相同的行业标准
*/
public class Coder implements OperationStandard {
    public void operate() {
        //调整代码，提出解决方案
    }
}

/**
* 代理对象，实现相同的行业标准
*/
public class Service implements OperationStandard{
    //接收保存目标对象
    private Coder target;
    public Service(Coder target){
        this.target=target;
    }

    public void operate() {
        System.out.println(“增强功能1...&quot;);
        target.operate();//执行目标对象的方法
        System.out.println(“增强功能2...&quot;);
    }
}

/**
* 用户
*/
public class Customer {
    public static void main(String[] args) {
        //目标对象
        Coder target = new Coder();

        //代理对象,把目标对象传给代理对象,建立代理关系
        Service proxy = new Service(target);

        proxy.operate();//执行的是代理的方法
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;静态代理虽然简单，但缺点也很明显：目标对象和代理对象都要实现相同的接口，一旦接口需要变动，目标类和代理类都需要维护。这很好理解，售后人员和程序猿/媛之间对项目都有明确的标准的需求或功能文档，程序猿/媛按照标准文档开发，售后人员按照标准文档对外提供服务，一旦公司的这些标准文档变化了，那么需要组织售后人员和程序猿/媛一起进行培训，这样无疑很耗时耗力。&lt;/p&gt;

&lt;p&gt;动态代理可以很好的解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 动态代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;动态代理利用JDK的API动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)&lt;/p&gt;

&lt;p&gt;JDK中生成代理对象的API：
java.lang.reflect.Proxy.newProxyInstance
static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces,InvocationHandler h )&lt;/p&gt;

&lt;p&gt;注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为:&lt;/p&gt;

&lt;p&gt;ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的&lt;/p&gt;

&lt;p&gt;Class&amp;lt;?&amp;gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型&lt;/p&gt;

&lt;p&gt;InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入&lt;/p&gt;

&lt;p&gt;行业标准和目标类和静态代理是一样的，下面只写代理类的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 创建动态代理对象
* 动态代理不需要实现接口,但是需要指定接口类型
*/
public class Service{

    //维护一个目标对象
    private Object target;
    public Service(Object target){
        this.target=target;
    }

   //给目标对象生成代理对象
    public Object getProxyInstance(){
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(&quot;增强功能1&quot;);
                        //执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        System.out.println(&quot;增强功能2&quot;);
                        return returnValue;
                    }
                }
        );
    }

}
/**
* 用户
*/
public class Customer {
    public static void main(String[] args) {
        // 目标对象
        OperationStandard target = new Coder();
        // 【原始的类型 class com.intelligentler.Controller.Coder】
        System.out.println(target.getClass());

        // 给目标对象，创建代理对象
        OperationStandard proxy = (OperationStandard) new Service(target).getProxyInstance();
        // class $Proxy0   内存中动态生成的代理对象
        System.out.println(proxy.getClass());

        // 执行代理对象的方法
        proxy.operate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候售后人员就厉害了，她不需要依赖标准文档就可以对接不同类型的程序猿/媛，你想让她去代理哪个程序猿/媛都可以，因为她会动态的去调用不同目标对象的执行方法。但动态代理中的目标对象还是要实现标准接口，否则无法使用动态代理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.3 Cglib代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理。&lt;/p&gt;

&lt;p&gt;Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)&lt;/p&gt;

&lt;p&gt;Cglib子类代理实现方法:&lt;/p&gt;

&lt;p&gt;1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可.&lt;/p&gt;

&lt;p&gt;2.引入功能包后,就可以在内存中动态构建子类&lt;/p&gt;

&lt;p&gt;3.代理的类不能为final,否则报错&lt;/p&gt;

&lt;p&gt;4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* 目标对象,没有实现任何接口
*/
public class Coder {

    public void operate() {
        //调整代码，提出解决方案
    }
}
Cglib代理工厂:ServiceProxyFactory.java
/**
* Cglib子类代理工厂
* 对Coder在内存中动态构建一个子类对象
*/
public class ServiceProxyFactory implements MethodInterceptor{
    //维护目标对象
    private Object target;

    public ServiceProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象创建一个代理对象
    public Object getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return en.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(&quot;增强功能1&quot;);

        //执行目标对象的方法
        Object returnValue = method.invoke(target, args);

        System.out.println(&quot;增强功能1&quot;);

        return returnValue;
    }
}

/**
* 用户
*/
public class Customer {
    @Test
    public void test(){
        //目标对象
        Coder target = new Coder();
        //代理对象
        Coder proxy = (Coder)new ServiceProxyFactory(target).getProxyInstance();
        //执行代理对象的方法
        proxy.save();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Cglib代理中售后人员和程序猿/媛有着无比的默契，沟通不再需要标准文档。&lt;/p&gt;

&lt;p&gt;在Spring的AOP编程中:&lt;/p&gt;

&lt;p&gt;如果加入容器的目标对象有实现接口,用JDK代理&lt;/p&gt;

&lt;p&gt;如果目标对象没有实现接口,用Cglib代理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、装饰器模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;装饰器模式可以在运行时增强或改变对象的功能。通常给对象增强功能，有三种方式：&lt;/p&gt;

&lt;p&gt;1、直接修改对象添加相应的功能&lt;/p&gt;

&lt;p&gt;2、派生对应的子类来扩展&lt;/p&gt;

&lt;p&gt;3、使用对象组合的方式&lt;/p&gt;

&lt;p&gt;显然，直接修改对应的类这种方式并不可取，它需要我们去修改以前的代码，这是程序猿的大忌。适配器模式就是派生对应的子类来扩展对象的功能。在面向对象的设计中，我们应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰器模式类图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕设计模式-观适代装模式&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/5979a7b50001c76b16540970.png&quot; width=&quot;100%&quot; alt=&quot;装饰器模式类图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Component：待装饰对象的接口&lt;/p&gt;

&lt;p&gt;ConcreteComponent：待装饰对象的具体实现类&lt;/p&gt;

&lt;p&gt;Decorator：所有装饰器的父类，它也可以继承Component类，以便可以自己增强自己。&lt;/p&gt;

&lt;p&gt;ConcreteDecorator：具体的装饰器类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java代码实现：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public abstract class Component {  
    /**
     * 待增强的方法
     */  
    public abstract void operation();  
}
public class ConcreteComponent extends Component {  

    public void operation() {}  

}  
public abstract class Decorator extends Component {  
    /**
     * 持有组件对象
     */  
    protected Component component;  

    /**
     * 构造方法，传入组件对象
     * @param component 组件对象
     */  
    public Decorator(Component component) {  
        this.component = component;  
    }  

    public void operation() {  
        //转发请求给组件对象，可以在转发前后执行一些附加动作  
        component.operation();  
    }  


}  
public class ConcreteDecoratorA extends Decorator {  
       public ConcreteDecoratorA(Component component) {  
            super(component);  
   }  
       private void operationFirst(){ } //在调用父类的operation方法之前需要执行的操作  
       private void operationLast(){ } //在调用父类的operation方法之后需要执行的操作  
       public void operation() {  
           //调用父类的方法，可以在调用前后执行一些增强功能
           operationFirst(); //添加的功能  
           //这里可以选择性的调用父类的方法，如果不调用则相当于完全改写了方法，实现了新的功能
           super.operation();
           operationLast(); //添加的功能  
   }  
}  
public class Client{  
   public static void main(String[] args){  
    Component c1 = new ConcreteComponent (); //首先创建需要被装饰的原始对象(即要被装饰的对象)  
    Decorator decoratorA = new ConcreteDecoratorA(c1); //给对象透明的增加功能A并调用  
    decoratorA .operation();  
    Decorator decoratorB = new ConcreteDecoratorB(c1); //给对象透明的增加功能B并调用  
    decoratorB .operation();
    //这里实现了自己装饰自己的功能，装饰器也可以装饰具体的装饰对象，此时相当于给对象在增加A的功能基础上在添加功能B  
    Decorator decoratorBandA = new ConcreteDecoratorB(decoratorA);  
    decoratorBandA.operation();  
  }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Java中的IO是明显的装饰器模式的运用。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;http://www.cnblogs.com/cenyu/p/6289209.html&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/hust_is_lcd/article/details/7884320&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/06/22/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E9%80%82%E4%BB%A3%E8%A3%85.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/06/22/%E6%AD%BB%E7%A3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E9%80%82%E4%BB%A3%E8%A3%85.html</guid>
        
        <category>java</category>
        
        <category>设计模式</category>
        
        <category>观察者</category>
        
        <category>适配器</category>
        
        <category>代理</category>
        
        <category>装饰器模式</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>浅谈hashMap、hashTable、ConcurrentHashMap（1.6、1.8）</title>
        <description>&lt;p&gt;最近看Spring IoC源码的时候，发现Spring IoC中的BeanDefinition的注册采用ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt;(256)来存储BeanDefinition，这让我想起了HashMap、HashTable以及ConcurrentHashMap的区别与联系，现在总结这三个类的实现原理和区别，在大脑里也重新再整理下这部分知识点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、HashMap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1 HashMap的定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HashMap是最常用的集合类框架之一，它实现了Map接口，所以存储的元素也是键值对映射的结构，并允许使用null值和null键，其内元素是无序的，如果要保证有序，可以使用LinkedHashMap。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable{}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 hashMap的基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。
HashMap()
//构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。
HashMap(int initialCapacity)
//构造一个带指定初始容量和加载因子的空 HashMap。
HashMap(int initialCapacity, float loadFactor)
//构造一个映射关系与指定 Map 相同的 HashMap。
HashMap(Map&amp;lt;? extendsK,? extendsV&amp;gt; m)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在hashMap的size达到initialCapacity*loadFactor时会对hashMap进行扩容，值得注意的是hashMap的size大小总是2的幂次方。初始容量和加载因子的选取也是影响HashMap性能的原因之一，加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间；加载因子过低也可能容易导致HashMap执行rehash操作。&lt;/p&gt;

&lt;p&gt;保证hashMap的size大小总为2的幂次方的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : 	n + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过对（n - 1）无符号右移，最终会返回一个2的幂次方的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要保证hashMap的size的大小为2的幂次方？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在往hashMap中添加值(putVal())，要获取添加的值得index的时候，hashMap中使用了hashMap中Node数组的length:n与key的hash值‘相与’ &lt;code class=&quot;highlighter-rouge&quot;&gt;(n - 1) &amp;amp; hash&lt;/code&gt;来计算，当hashMap的size：n为2的幂时，n - 1 转化为全为1的二进制格式，和hash‘相与’时就是hash的值，因为做与运算要比做mod运算快很多，所以保证hashMap的size的大小为2的幂次方时会提高确定key的index位置的效率。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;HashMap能不能放入大于Integer_Max_Value个元素？&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;//1073741824 我们知道hashMap中的最大的size为1073741824，而Integer的Max_Value为2147483647，那么还能放Integer_Max_Value个元素吗？研究源码发现是可以的。

final Node&amp;lt;K,V&amp;gt;[] resize() {
    Node&amp;lt;K,V&amp;gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &amp;gt; 0) {
        if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
    ...
    }
    ...
} 在扩容的resize()方法中，如果`oldCap &amp;gt;= MAXIMUM_CAPACITY`，不会对threshold扩容，而是直接将其赋值为Integer.MAX_VALUE，将冲突的值放在链表或红黑树中。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;当链表的大小大于8的时候就一定会转化为红黑树吗？&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //TREEIFY_THRESHOLD默认为8，当链表的大小大于8的时候就一定会转化为红黑树吗？
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;答案是不一定，hashMap在treeifyBin方法中将链表转换为红黑树，但会有一个判断，如果当前的hashMap长度小于64是，会对hashMap进行扩容resize()。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final void treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, int hash) {
    int n, index; Node&amp;lt;K,V&amp;gt; e;
    //MIN_TREEIFY_CAPACITY 64
    if (tab == null || (n = tab.length) &amp;lt; MIN_TREEIFY_CAPACITY)
        resize();
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在HashMap中我们直接接触的最常用的两个方法就是get和put方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

public V get(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们通过hashCode和equals方法来保证HashMap中的key值的唯一性。
当我们调用put存值时，HashMap首先会调用K的hashCode方法，获取哈希码，通过哈希码快速找到某个存放位置，这里需要注意的是，如果hashCode不同，equals一定为false，如果hashCode相同，equals不一定为true。所以理论上，hashCode可能存在冲突的情况，也就是碰撞，当碰撞发生时，计算出的hashCode是相同的，这时会比较对应hashCode位置的key，最终通过equals来比较。HashMap通过hashCode和equals最终判断出K是否已存在，如果两个hash值相等且key值相等(e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果冲突发生的次数多了，链表的长度越来越长，该怎么办呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;随着HashMap中元素的数量越来越多，发生碰撞的概率也就越来越大，碰撞所产生的链表长度也就会越来越长，这样势必会影响HashMap的速度，因为原来找到数组的index就可以直接根据key取到值了，但是冲突严重，也就是说链表长，那就得循环链表了，时间就浪费在循环链表上了，也就慢了。为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;hashMap为什么是线程不安全的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当hashMap扩容的时候会调用transfer方法，它是采用头插法来转移旧值到新的hashMap中去，假如转移前链表顺序是1-&amp;gt;2-&amp;gt;3，那么转移后就会变成3-&amp;gt;2-&amp;gt;1，那么在多线程的情况下就可能造成1-&amp;gt;2的同时2-&amp;gt;1的环形链表，进而形成死循环。&lt;/p&gt;

&lt;p&gt;那在多线程下使用HashMap我们可以采用如下几种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在外部包装HashMap，实现同步机制&lt;/li&gt;
  &lt;li&gt;使用集合的工具类 Collections的静态方法synchronizedMap，在这个方法中创建了工具类 Collections中的内部类SynchronizedMap的实例来实现HashMap的线程安全：Map m = Collections.synchronizedMap(new HashMap(…));，这里就是对HashMap做了一次包装&lt;/li&gt;
  &lt;li&gt;使用java.util.HashTable，效率最低&lt;/li&gt;
  &lt;li&gt;使用java.util.concurrent.ConcurrentHashMap，相对安全，效率较高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;二、HashTable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1 HashTable的定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HashTable和HashMap很相似，但HashTable是线程安全的，同时HashTable中的key和value都不能为null。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class Hashtable&amp;lt;K,V&amp;gt;
    extends Dictionary&amp;lt;K,V&amp;gt;
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 Hashtable的基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//构造一个具有默认初始容量 (11) 和默认加载因子 (0.75) 的空 Hashtable。
Hashtable()
//构造一个带指定初始容量和默认加载因子 (0.75) 的空 Hashtable。
Hashtable(int initialCapacity)
//构造一个带指定初始容量和加载因子的空 Hashtable。
Hashtable(int initialCapacity, float loadFactor)
//构造一个映射关系与指定 Map 相同的 Hashtable。
Hashtable(Map&amp;lt;? extends K, ? extends V&amp;gt; t)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Hashtable中很多操作Hashtable的方法都加上了synchronized关键字来保证线程安全，比如：get和put方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public synchronized V put(K key, V value) {}
public synchronized V get(Object key) {}
public synchronized V remove(Object key) {}
public synchronized void clear() {}
public synchronized Object clone() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;HashMap与HashTable的几点不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、HashMap是非线程安全的，而HashTable是线程安全的；&lt;/p&gt;

&lt;p&gt;2、HashMap的遍历一般使用Iterator，而HashTable一般使用的是Enumeration。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Enumeration&amp;lt;E&amp;gt; {

    boolean hasMoreElements();

    E nextElement();
}

public interface Iterator&amp;lt;E&amp;gt; {
 
    boolean hasNext();

    E next();

    default void remove() {
        throw new UnsupportedOperationException(&quot;remove&quot;);
    }

    default void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面JDK1.8版本中的Enumeration和Iterator的代码中可以看到，Iterator对集合的操作多了一个remove，也就是说在对HashMap进行遍历的时候可以调用Iterator的remove方法来删除HashMap中的值。值得注意的是，Iterator支持fail-fast机制，在用Iterator遍历一个集合时，如果另外的线程调用了该集合的remove方法，则会抛出ConcurrentModificationException(比较了modCount == expectedModCount)，但调用Iterator的remove方法则不会。Enumeration的遍历输出是先进后出的，而Iterator的遍历输出是先进先出的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、concurrentHashMap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从上面可以看出Hashtable和Collections.synchronizedMap(hashMap)基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能是十分糟糕的，而且Hashtable已经过时了。为了提高高并发下的性能，我们来看下并发安全的ConcurrentHashMap。ConcurrentHashMap之所以高效是因为它更好的降低了锁的粒度，锁加在了每个Segment上而不是直接加在整个HashMap上，参数concurrencyLevel是用户估计的并发级别，就是说你觉得最多有多少线程共同修改这个map，根据这个来确定Segment数组的大小，concurrencyLevel默认为16。ConcurrentHashMap的key和value都不能为null。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 先来看下ConcurrentHashMap 在JDK1.6中的版本。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构。&lt;/p&gt;

&lt;p&gt;其包含两个核心静态内部类 Segment和HashEntry。&lt;/p&gt;

&lt;p&gt;Segment继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶。&lt;/p&gt;

&lt;p&gt;HashEntry 用来封装映射表的键 / 值对；
每个桶是由若干个 HashEntry 对象链接起来的链表。&lt;/p&gt;

&lt;p&gt;一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;浅谈hashMap、hashTable、ConcurrentHashMap（1.6、1.8）&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/598581d50001106005020537.png&quot; style=&quot;width:70%&quot; alt=&quot;ConcurrentHashMap 1.6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 ConcurrentHashMap 在JDK1.8中的版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而在JDK1.8中的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/fb6e91b013cc&quot;&gt;CAS&lt;/a&gt;，Compare and Swap即比较并替换，CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，如果不相同则证明内存值在并发的情况下被其它线程修改过了，则不作任何修改，返回false，等待下次再修改。&lt;/p&gt;

&lt;p&gt;table：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。&lt;/p&gt;

&lt;p&gt;Node：保存key，value及key的hash值的数据结构。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    final int hash;
    final K key;
    volatile V val;//保证并发的可见性
    volatile Node&amp;lt;K,V&amp;gt; next;//保证并发的可见性
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;table初始化操作会延缓到第一次put行为，但put方法是可以并发的，那么如何确保table只初始化一次？在initTable方法中用sizeCtl来确保，sizeCtl变量是用volatile修饰的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private transient volatile int sizeCtl;

public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            //初始化table
            tab = initTable();
        //tabAt调用Unsafe.getObjectVolatile获取指定内存的数据f
        else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
            //如果f为null，说明table中这个位置第一次插入元素，利用casTabAt调用Unsafe.compareAndSwapObject方法插入Node节点
            if (casTabAt(tab, i, null,
                         new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        //如果hash为-1，意味有其它线程正在扩容，则一起进行扩容操作。
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        //其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发
        else {
            V oldVal = null;
            synchronized (f) {
                //比较当前内存中的值是否还是f，防止被其它线程修改
                if (tabAt(tab, i) == f) {
                    //如果f.hash &amp;gt;= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点
                    if (fh &amp;gt;= 0) {
                        binCount = 1;
                        for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&amp;lt;K,V&amp;gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node&amp;lt;K,V&amp;gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                //如果链表中节点数binCount &amp;gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构，提高遍历查询效率。
                if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    //检查当前容量是否需要进行扩容
    addCount(1L, binCount);
    return null;
}

private final Node&amp;lt;K,V&amp;gt;[] initTable() {
    Node&amp;lt;K,V&amp;gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        //如果一个线程发现sizeCtl&amp;lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片
        if ((sc = sizeCtl) &amp;lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                    table = tab = nt;
                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。&lt;/p&gt;

&lt;p&gt;1.6中采用ReentrantLock 分段锁的方式，使多个线程在不同的segment上进行写操作不会发现阻塞行为；1.8中直接采用了内置锁synchronized&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HashMap深度解析：http://blog.csdn.net/ghsau/article/details/16843543&lt;/p&gt;

&lt;p&gt;谈谈HashMap线程不安全的体现：http://www.importnew.com/22011.html&lt;/p&gt;

&lt;p&gt;JDK 1.8 ConcurrentHashMap 源码剖析：http://blog.csdn.net/lsgqjh/article/details/54867107&lt;/p&gt;

&lt;p&gt;java中的CAS：http://www.jianshu.com/p/fb6e91b013cc&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/06/13/%E6%B5%85%E8%B0%88hashMap-hashTable-ConcurrentHashMap-1.6-1.8.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/06/13/%E6%B5%85%E8%B0%88hashMap-hashTable-ConcurrentHashMap-1.6-1.8.html</guid>
        
        <category>hashMap</category>
        
        <category>hashTable</category>
        
        <category>ConcurrentHashMap</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕redis-Spring使用redis存储sessionId</title>
        <description>&lt;p&gt;&lt;strong&gt;一、redis 储备知识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Redis 是完全开源免费的一个高性能的key-value数据库。&lt;/p&gt;

&lt;p&gt;Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。&lt;/p&gt;

&lt;p&gt;string类型是Redis最基本的数据类型，一个键最大能存储512MB。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;127.0.0.1:6379&amp;gt; set database “redis”&lt;/p&gt;

  &lt;p&gt;OK&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; get database&lt;/p&gt;

  &lt;p&gt;“redis”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。每个 hash 可以存储 2^32 -1 键值对（40多亿）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;127.0.0.1:6379&amp;gt; hmset user:1 zhoum 24 man coder&lt;/p&gt;

  &lt;p&gt;OK&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; hgetall user:1&lt;/p&gt;

  &lt;p&gt;1) “zhoum”&lt;/p&gt;

  &lt;p&gt;2) “24”&lt;/p&gt;

  &lt;p&gt;3) “man”&lt;/p&gt;

  &lt;p&gt;4) “coder”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis List列表是简单的字符串列表，按照插入顺序排序。列表最多可存储 2^32 - 1 元素。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;127.0.0.1:6379&amp;gt; lpush databases redis&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; lpush databases mysql&lt;/p&gt;

  &lt;p&gt;(integer) 2&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; lpush databases sqlite&lt;/p&gt;

  &lt;p&gt;(integer) 3&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; lpush databases mongodb&lt;/p&gt;

  &lt;p&gt;(integer) 4&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; lrange databases 0 10&lt;/p&gt;

  &lt;p&gt;1) “mongodb”&lt;/p&gt;

  &lt;p&gt;2) “sqlite”&lt;/p&gt;

  &lt;p&gt;3) “mysql”&lt;/p&gt;

  &lt;p&gt;4) “redis”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis的Set是string类型的无序集合。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;127.0.0.1:6379&amp;gt; sadd databases redis&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; sadd databases mysql&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; sadd databases sqlite&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; sadd databases sqlite&lt;/p&gt;

  &lt;p&gt;(integer) 0&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; smembers databases&lt;/p&gt;

  &lt;p&gt;1) “sqlite”&lt;/p&gt;

  &lt;p&gt;2) “mysql”&lt;/p&gt;

  &lt;p&gt;3) “redis”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Redis zset 和 set 一样也是string类型元素的有序集合,且不允许重复的成员。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;127.0.0.1:6379&amp;gt; zadd databases 0 redis&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; zadd databases 0 mysql&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; zadd databases 0 sqlite&lt;/p&gt;

  &lt;p&gt;(integer) 1&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; zadd databases 0 sqlite&lt;/p&gt;

  &lt;p&gt;(integer) 0&lt;/p&gt;

  &lt;p&gt;127.0.0.1:6379&amp;gt; ZRANGEBYSCORE databases 0 1000&lt;/p&gt;

  &lt;p&gt;1) “redis”&lt;/p&gt;

  &lt;p&gt;2) “mysql”&lt;/p&gt;

  &lt;p&gt;3) “sqlite”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;二、Spring使用redis存储sessionid&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pom.xml中的redis部分&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;配置文件：redis.properties&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis.maxIdle=100  
redis.maxActive=300  
redis.maxWait=1000  
redis.timeout=100000  
redis.maxTotal=1000  
redis.minIdle=8  
redis.testOnBorrow=true
redis.host=127.0.0.1
redis.port=6379
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Spring redis配置文件：redis-context.xml&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:p=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis.clients.jedis.JedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;maxIdle&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${redis.maxIdle}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;maxTotal&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${redis.maxTotal}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;maxWaitMillis&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${redis.maxWait}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;testOnBorrow&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${redis.testOnBorrow}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jedisConnectionFactory&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;poolConfig&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hostName&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${redis.host}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;port&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;${redis.port}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redisTemplate&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.data.redis.core.RedisTemplate&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;connectionFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jedisConnectionFactory&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;keySerializer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;valueSerializer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hashKeySerializer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hashValueSerializer&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;java代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import org.springframework.data.redis.core.RedisTemplate;
import java.io.Serializable;

@Autowired
protected RedisTemplate&amp;lt;Serializable, Serializable&amp;gt; redisTemplate;

public void addAdminRedis(String sessionId, Integer aid) {
    if(null != sessionId &amp;amp;&amp;amp; null != aid){
        redisTemplate.opsForValue().set(sessionId+ADMIN_SUFFIX,aid);
    }
}

public AdministratorVo getAdminRedis(String sessionId) {
    if(null == sessionId){
        return  null;
    }
    if(null == redisTemplate.opsForValue().get(sessionId+ADMIN_SUFFIX)){
        return  null;
    }
    Integer aid = (Integer)redisTemplate.opsForValue().get(sessionId+ADMIN_SUFFIX);
    AdministratorVo admin = adminMapper.selectAdminById(aid);
    if(null != admin){
        admin.setPassword(null);
    }
    return admin;
}

public void deleteAdminRedis(String sessionId) {
    if(sessionId != null){
        AdministratorVo vo = getAdminRedis(sessionId+ADMIN_SUFFIX);
        if(null != vo){
            redisTemplate.delete(ADMIN_POWER_PREFIX+vo.getId().toString());
        }

        redisTemplate.delete(sessionId+ADMIN_SUFFIX);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 01 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/database/2017/06/01/%E6%AD%BB%E7%A3%95redis-Spring%E4%BD%BF%E7%94%A8redis%E5%AD%98%E5%82%A8sessionId.html</link>
        <guid isPermaLink="true">http://localhost:4000/database/2017/06/01/%E6%AD%BB%E7%A3%95redis-Spring%E4%BD%BF%E7%94%A8redis%E5%AD%98%E5%82%A8sessionId.html</guid>
        
        <category>redis</category>
        
        <category>Spring</category>
        
        <category>sessionId</category>
        
        
        <category>Database</category>
        
      </item>
    
      <item>
        <title>浅谈Java多线程</title>
        <description>&lt;p&gt;Java多线程是Java程序员必须掌握的基本的知识点，这块知识点比较复杂，知识点也比较多，今天我们一一来聊下Java多线程，系统的整理下这部分内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、Java中线程创建的三种方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1．通过继承Thread类，重写Thread的run()方法，将线程运行的逻辑放在其中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread extends Thread{  
    public void run(){  
        //do run something 
  }  
}  
public class ThreadDemo {  
    public static void main(String[] args) {  
        MyThread mt1= new MyThread();  
        MyThread mt2= new MyThread();  
        MyThread mt3= new MyThread();  
        mt1.start();  
        mt2.start();  
        mt3.start();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2．通过实现Runnable接口，实例化Thread类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//构造一个实现了Runnable接口的类
class MyThread1 implements Runnable{ 
    public void run(){  
        //do run something 
    }  
}
public class RunnableDemo {  
    public static void main(String[] args) {  
    	//创建一个类对象
        MyThread1 mt = new MyThread1();  
        //由Runnable创建Thread对象
        Thread t1 = new Thread(mt);  
        Thread t2 = new Thread(mt);  
        Thread t3 = new Thread(mt);  
        //启动线程
        t1.start();  
        t2.start();  
        t3.start();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3．实现Callable接口，创建FutureTask包装器，实例化Thread类&lt;/p&gt;

&lt;p&gt;FutureTask实现接口类图：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;浅谈Java多线程&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59b20e0e0001c1d704360178.png&quot; alt=&quot;FutureTask实现接口类图&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {
	//取消任务的运行
    boolean cancel(boolean mayInterruptIfRunning);
	//如果任务在完成前取消了返回true
    boolean isCancelled();
	//任务结束（正常结束、中途取消、发生异常）,返回true
    boolean isDone();
	//返回最终计算完成的结果
    V get() throws InterruptedException, ExecutionException;
	//返回在指定时间内计算的结果，如果超过指定时间没有结果则抛出TimeoutException异常
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}

public interface Callable&amp;lt;V&amp;gt;{
    V call() throws Exception;
}

class MyThread2 implements Callable&amp;lt;Integer&amp;gt;{
    public Integer call(){
        //do call something
    }
}

public class CallableDemo{
    public static void main(String[] args){
        MyThread2 mt = new MyThread2();
        FutureTask&amp;lt;Integer&amp;gt; task = new FutureTask&amp;lt;&amp;gt;(mt);
        Thread t = new Thread(task);
        t.start();
        Integer result = task.get();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;1、不要直接调用Thread类或Runnable接口的run方法，直接调用run方法单纯执行run方法体中的内容，而不会启动新线程，应该调用Thread的start方法，这个方法将创建一个执行run方法的新线程。&lt;/p&gt;

&lt;p&gt;2、尽量不要使用第一种方式来创建线程，因为有多个任务，这种方式需要为每个任务创建一个独立的线程（new MyThread()），这个代价太大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、未捕获异常处理器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道在run方法中无法抛出任何不可查的异常，但一旦run方法中出现了这类异常则会直接导致线程终止，在这种情况下，线程就GG了。通过分析，我们知道在线程死亡之前，异常会被传递到一个用于未捕获异常的处理器中，所以为了防止这种情况出现，我们可以为线程安装一个未捕获异常处理器。&lt;/p&gt;

&lt;p&gt;未捕获异常处理器必须实现Thread.UncaughtExceptionHanlder接口的类（这个接口类在Thread），这个类只有一个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FunctionalInterface
public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过Thread的静态方法&lt;code class=&quot;highlighter-rouge&quot;&gt;setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)&lt;/code&gt;为线程安装一个默认的处理器。&lt;/p&gt;

&lt;p&gt;当一个线程因为未捕获异常而终止时，通过uncaughtException方法的System.err.print打印异常信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void uncaughtException(Thread t, Throwable e) {
    if (parent != null) {
        parent.uncaughtException(t, e);
    } else {
        Thread.UncaughtExceptionHandler ueh =
            Thread.getDefaultUncaughtExceptionHandler();
        if (ueh != null) {
            ueh.uncaughtException(t, e);
        } else if (!(e instanceof ThreadDeath)) {
            System.err.print(&quot;Exception in thread \&quot;&quot;
                             + t.getName() + &quot;\&quot; &quot;);
            e.printStackTrace(System.err);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、线程状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;线程的五个基本状态：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;新建（New）&lt;/li&gt;
  &lt;li&gt;可运行状态（Runnable）&lt;/li&gt;
  &lt;li&gt;运行时状态（Running）&lt;/li&gt;
  &lt;li&gt;阻塞状态（Blocked）&lt;/li&gt;
  &lt;li&gt;死亡状态（Dead）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程调用start()方法开始后，就进入到可运行状态，随着CPU的资源调度在运行和可运行之间切换；遇到阻塞则进入阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这五种状态的相互之间转换图如下图所示：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;浅谈Java多线程&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/59b20e2f0001c39a14580596.png&quot; style=&quot;width:100%&quot; alt=&quot;五种状态的相互之间转换图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线程被阻塞可能是由于下面五方面的原因：（《Thinking in Java》）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用sleep(毫秒数)，使线程进入睡眠状态。在规定时间内，这个线程是不会运行的。&lt;/li&gt;
  &lt;li&gt;用suspend()暂停了线程的执行。除非收到resume()消息，否则不会返回“可运行”状态。这两个方法已经过时。&lt;/li&gt;
  &lt;li&gt;用wait()暂停了线程的执行。除非线程收到notify()或notifyAll()消息，否则不会变成“可运行”状态。&lt;/li&gt;
  &lt;li&gt;线程正在等候一些IO操作完成。&lt;/li&gt;
  &lt;li&gt;线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如果线程中有同步方法，那么线程状态图如下图所示：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;浅谈Java多线程&quot; 图片3=&quot;&quot; src=&quot;http://img.mukewang.com/59b20e430001126914620580.png&quot; style=&quot;width:100%&quot; alt=&quot;同步方法的线程状态图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当互斥资源被一个线程访问时，互斥资源就上锁了，这时候其他线程访问该互斥资源就会进入了一个锁池（Lock pool）；当锁被释放，其他线程获得了锁，就变为可运行状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果线程调用了wait()等方法，那么线程状态图如下图所示：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;浅谈Java多线程&quot; 图片4=&quot;&quot; src=&quot;http://img.mukewang.com/59b20e530001c4c914580592.png&quot; style=&quot;width:100%&quot; alt=&quot;线程相互作用的状态图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们都知道线程调用了wait()（这个方法是Object的方法）方法之后，线程会释放掉锁，这个时候线程进入等待池（Wait pool）；等线程收到通知之后等待获取锁，获取锁之后才可以运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、线程同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Java中线程同步分五种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;synchronized&lt;/li&gt;
  &lt;li&gt;ReentrantLock与Condition&lt;/li&gt;
  &lt;li&gt;volatile&lt;/li&gt;
  &lt;li&gt;ThreadLocal&lt;/li&gt;
  &lt;li&gt;BlockingQueue&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;4.1 synchronized、wait与notify&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个线程访问用synchronized关键字修饰的代码块，如果这个代码块被该线程第一个访问，则这个线程会获取到该Java对象的内部锁，其他线程访问的时候则会因为获取不到内部锁而阻塞。synchronized可以修饰类方法（static修饰的方法）、实例方法和类（Object.class），但是不能修饰抽象类的抽象方法和接口中的接口方法。&lt;/p&gt;

&lt;p&gt;线程在执行同步方法时是具有排它性的。当任意一个线程进入到一个对象的任意一个同步方法时，这个对象的所有同步方法都被锁定了，在此期间，其他任何线程都不能访问这个对象的任意一个同步方法，直到这个线程执行完它所调用的同步方法并从中退出，从而导致它释放了该对象的同步锁之后。在一个对象被某个线程锁定之后，其他线程是可以访问这个对象的所有非同步方法的。&lt;/p&gt;

&lt;p&gt;我们知道wait()和notify()方法只能在加锁的代码块中使用，因为调用wait()方法时会释放所持有的对象的lock，同时进入等待状态，notifyAll()方法会唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 ReentrantLock与Condition&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ReentrantLock是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。其lock和unlock必须成对出现，否则可能会出现死锁，通常在finally代码释放锁。ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//fair为true时创建公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Condition代表条件对象，用于线程之间的通信，当一个线程A需要另一个线程B满足一定条件才可以继续操作时，A线程可以调用Condition的await()来阻塞当前线程，且放弃锁，等到B线程执行了某些操作并满足了一些条件后signalAll()唤醒阻塞的线程，当A线程重新强占了锁资源后再变成可运行状态。Condition条件对象对于一个对象来说可以有多个，但Object的wait()和notify()对于一个对象来说只有一个条件对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.3 volatile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于volatile修饰的变量，jvm虚拟机保证从主内存加载到线程工作内存的值是最新的。volatile可保证变量的可见性，但无法保证原子性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4 ThreadLocal&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;多线程同步无非是让原本多个线程对某个操作并行变成串行，我们必须小心地对共享资源进行同步，同步不仅会带来一定的效能延迟，而且在处理同步的时候，又要注意对象的锁定与释放，稍有不慎就有可能产生死锁。&lt;/p&gt;

&lt;p&gt;既然这么麻烦，ThreadLocal不对共享资源加锁，而是为每个线程创造一个资源的复本。将每一个线程存取数据的行为加以隔离，实现的方法就是给予每个线程一个特定空间来保管该线程所独享的资源。&lt;/p&gt;

&lt;p&gt;当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。在 ThreadLocal 类中有一个 ThreadLocalMap ，用于存储每一个线程的变量的副本。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。&lt;/p&gt;

&lt;p&gt;锁是一种以时间换空间的机制，而ThreadLocal正好是以空间换时间的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.5 BlockingQueue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;阻塞队列在&lt;a href=&quot;https://zhoum1118.github.io/java/2017/05/13/%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88Collection.html&quot;&gt;《浅谈Java集合Collection》&lt;/a&gt;有提到过：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;

&lt;p&gt;《Java核心技术》&lt;/p&gt;

&lt;p&gt;Java 多线程 线程状态图：http://www.cnblogs.com/mengdd/archive/2013/02/20/2917966.html&lt;/p&gt;

&lt;p&gt;JAVA中线程同步的方法：http://www.cnblogs.com/duanxz/p/3709608.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/p&gt;
</description>
        <pubDate>Sun, 28 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/28/%E6%B5%85%E8%B0%88Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/28/%E6%B5%85%E8%B0%88Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</guid>
        
        <category>Java</category>
        
        <category>多线程</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JVM-垃圾收集器机制</title>
        <description>&lt;h2 id=&quot;引文&quot;&gt;&lt;strong&gt;引文&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Java GC主要可以由三个问题展开来讲&lt;/p&gt;

&lt;p&gt;1、哪些内存需要回收&lt;/p&gt;

&lt;p&gt;2、什么时候回收&lt;/p&gt;

&lt;p&gt;3、怎样回收&lt;/p&gt;

&lt;p&gt;这三个问题讲清楚后，至少在脑海里对Java GC有了一个比较清晰的理解，那接下来我们就一个个攻克这三个问题。&lt;/p&gt;

&lt;h2 id=&quot;1哪些内存需要回收&quot;&gt;&lt;strong&gt;1、哪些内存需要回收&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;就Java内存运行时区域来说，线程私有的程序计数器、虚拟机栈和本地方法栈随线程生而生，随线程亡而亡，因此这几个区域的内存分配和回收具备确定性，也就不需要过多考虑回收的问题，因为方法体结束或线程结束时，内存自然就跟着回收了。我们需要考虑的是线程共享的方法区和Java堆。&lt;/p&gt;

&lt;h2 id=&quot;2什么时候回收&quot;&gt;&lt;strong&gt;2、什么时候回收&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;下图是这一节的简介图
&lt;img title=&quot;死磕JVM-垃圾收集器机制_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/5922a76900018eae14500956.png&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“什么时候回收”这个问题对于&lt;strong&gt;Java堆&lt;/strong&gt;的直接的回答就是当对象死亡的时候，那对象什么死亡或者如何来标记一个对象是死是活呢？Java GC中有两种标志算法：引用计数算法和可达性分析算法。&lt;/p&gt;

&lt;h3 id=&quot;21-引用计数算法&quot;&gt;&lt;strong&gt;2.1 引用计数算法&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;算法思想：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减1。但触发一次GC的时候，对象的计数器的值为0的对象就说明该对象不可以再使用，可以被回收。&lt;/p&gt;

&lt;p&gt;这种标记的算法很简单高效，但就像&lt;a href=&quot;https://zhoum1118.github.io/javascript/2017/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.html&quot;&gt;《死磕JavaScript-垃圾收集机制》&lt;/a&gt;中引用计数算法存在同样的弊端：相互循环引用。简单说就是对象A保有对象B的引用，同时对象B也保有对象A的引用，那么这两个对象的引用计数在任何时候都不会为0，也就是不会被GC回收。&lt;/p&gt;

&lt;h3 id=&quot;22-可达性分析算法&quot;&gt;&lt;strong&gt;2.2 可达性分析算法&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;算法思想：通过一系列的“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径为引用链，如果一个对象到每个GC Roots都不存在引用链，也即是说从GC Roots到这个对象不可达，那么就说明这个对象是死亡的，可以被GC回收的对象。&lt;/p&gt;

&lt;p&gt;在Java语言中，可以被当做GC Roots的对象有：&lt;/p&gt;

&lt;p&gt;1）虚拟机栈的本地变量表中的引用对象&lt;/p&gt;

&lt;p&gt;2）本地方法栈中引用的对象&lt;/p&gt;

&lt;p&gt;3）方法区中类静态属性引用对象&lt;/p&gt;

&lt;p&gt;4）方法区中常量引用对象&lt;/p&gt;

&lt;h3 id=&quot;23-引用的分类&quot;&gt;&lt;strong&gt;2.3 引用的分类&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在Java1.2之前，对象只有被引用和未被引用两种状态，对象在未被引用的情况下就会在下一次触发GC的时候被GC回收，但我们有些对象当前可能没有被引用，但它可能经常被引用，那么在这个时刻由于它没有被引用则被GC回收了，在下次被重新引用的时候又需要加载进来，多次这样的操作后效率肯定是不高的，那么为了避免这种情况，在Java1.2之后，我们将引用分为4种。&lt;/p&gt;

&lt;h4 id=&quot;231-强引用&quot;&gt;&lt;strong&gt;2.3.1 强引用&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这是普遍存在的一种引用，比如“Object obj = new Object()”，只要强引用存在，GC就不会回收这类引用的对象。&lt;/p&gt;

&lt;h4 id=&quot;232-软引用-softreference&quot;&gt;&lt;strong&gt;2.3.2 软引用 SoftReference&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这是一种有用但非必需的对象，只有当内存不够用的时候，在抛出内存溢出之前才会将它列入GC回收的范围中（也就是说如果内存够用，这种引用的对象不会被列入GC回收的范围），只有在GC回收掉这些引用对象后内存还是不够用的情况下才会抛出内存溢出异常。&lt;/p&gt;

&lt;h4 id=&quot;233-弱引用-weakreference&quot;&gt;&lt;strong&gt;2.3.3 弱引用 WeakReference&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;弱引用关联的对象只能生存到下一次GC之前，当GC工作时，不管内存是否够用都会回收掉这部分对象&lt;/p&gt;

&lt;h4 id=&quot;234-虚引用-phantomreference&quot;&gt;&lt;strong&gt;2.3.4 虚引用 PhantomReference&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这是最弱的一种引用关系，我们无法通过虚引用得到一个对象实例，为一个对象设置虚引用关联的唯一目的是在这个对象被GC的时候收到一个系统通知。&lt;/p&gt;

&lt;p&gt;上面讲的是Java堆的对象的回收，现在来讲下&lt;strong&gt;方法区中的回收&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;方法区（永久代）中的回收主要有两部分内容：废弃常量和无用的类。废弃常量指的是没有任何对象引用了这个常量；无用的类必需满足以下三个条件：&lt;/p&gt;

&lt;p&gt;1）这个类的所有实例都被回收&lt;/p&gt;

&lt;p&gt;2）该类的ClassLoader也被回收&lt;/p&gt;

&lt;p&gt;3）该类对应的java.lang.Class对象没有被引用，即无法通过反射来访问这个类的方法&lt;/p&gt;

&lt;h2 id=&quot;3怎样回收&quot;&gt;&lt;strong&gt;3、怎样回收&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;死磕JVM-垃圾收集器机制_&quot; 图片2=&quot;&quot; src=&quot;http://img.mukewang.com/5922a7d80001891c14420992.png&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/22/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%BA%E5%88%B6.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/22/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%BA%E5%88%B6.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>GC</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JVM-如何构造JVM内存溢出和栈溢出</title>
        <description>&lt;p&gt;为什么要写这个题目？我记得我在面试阿里的时候面试官问了我这个问题，当时没能答得很好，只说了些概念的东西，很是心虚，于是下定决心要把这个问题搞懂，现在终于把这个问题怼清楚了，分享给大家，希望你们以后面试问到这种问题能有所准备。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java虚拟机中描述了两种异常：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常；&lt;/p&gt;

&lt;p&gt;2、如果在虚拟机中无法申请到足够多的内存空间，将抛出OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;我们都知道Java虚拟机各个内存区域（除了程序计数器）都有发生内存溢出的可能，但到底什么样的操作或程序才会导致内存溢出或栈溢出的异常呢？&lt;/p&gt;

&lt;p&gt;我们分不同的内存区域来解释这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、对于Java堆内存区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java堆中只会产生OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;先搞清楚Java堆内存放的是什么，还不清楚的可以回顾下这篇文章&lt;a href=&quot;https://zhoum1118.github.io/java/2017/05/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html&quot;&gt;《死磕JVM-Java内存模型》&lt;/a&gt;，从这篇文章里我们知道Java堆内存存放的是对象实例，所以原理上只要我们不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，也就是说当Eden区满的时候，GC被触发时，让GC误以为内存中的对象还存活着，那么在对象数量达到最大堆容量限制的时候就会产生内存溢出的异常。如下代码就会产生内存溢出的异常：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;堆溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; args&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; list &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               list&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;OOMError&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Exception in thread “main” java.lang.OutOfMemoryError: Java heap space&lt;/p&gt;

  &lt;p&gt;at java.util.Arrays.copyOf(Arrays.java:3210)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.Arrays.copyOf(Arrays.java:3181)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.grow(ArrayList.java:261)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.util.ArrayList.add(ArrayList.java:458)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at com.intelligentler.jvm.堆溢出.main(堆溢出.java:13)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“Java heap space”提示着产生OutOfMemoryError异常的Java虚拟机的内存区域，也就是Java堆内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何解决发生在Java堆内存的OutOfMemoryError异常呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们要分清楚产生OutOfMemoryError异常的原因是内存泄露还是内存溢出，如果内存中的对象确实都必须存活着而不像上面那样不断地创建对象实例却不使用该对象，则是内存溢出，而像上面代码中的情况则是内存泄露。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果是内存泄露&lt;/strong&gt;，我们可以通过一些内存查看工具来查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的路径与GC Roots相关联并导致GC无法自动回收这些泄露对象，掌握了这些信息，我们就能比较准确地定位出泄露代码的位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果不是内存泄露&lt;/strong&gt;，也就是说内存中的对象确实都还必须存活，那么应该检查虚拟机的堆参数，看看是否还可以将机器物理内存调大，同时在代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、对于虚拟机栈和本地方法栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这一部分内存区域，可能产生OutOfMemoryError异常和StackOverflowError异常。&lt;/p&gt;

&lt;p&gt;如果定义大量的本地变量，增大此方法帧中本地变量表的长度或者设置-Xss参数减少栈内存容量，这两种操作都会抛出StackOverflowError异常。&lt;/p&gt;

&lt;p&gt;如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;栈溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; stackLength &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; addStackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          stackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;++;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          addStackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; args&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;throws&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;栈溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; oom &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;栈溢出();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               oom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;addStackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; e&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;stack length:&quot;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; oom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;stackLength&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; e&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;stack length:18388&lt;/p&gt;

  &lt;p&gt;Exception in thread “main” java.lang.StackOverflowError&lt;/p&gt;

  &lt;p&gt;at com.intelligentler.jvm.栈溢出.addStackLength(栈溢出.java:9)&lt;/p&gt;

  &lt;p&gt;at com.intelligentler.jvm.栈溢出.addStackLength(栈溢出.java:9)&lt;/p&gt;

  &lt;p&gt;at com.intelligentler.jvm.栈溢出.addStackLength(栈溢出.java:9)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，如果在单线程的情况下，无论是栈帧太大还是虚拟机栈容量太小，当内存无法再分配的时候，虚拟机抛出的是StackOverflowError异常。&lt;/p&gt;

&lt;p&gt;如果在多线程下，不断地建立线程可能会产生OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、对于方法区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;方法区中只会产生OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;由于运行时常量池是方法区的一部分，我们可以通过String.intern()方法来构建一个运行时常量池的OutOfMemoryError异常。&lt;/p&gt;

&lt;p&gt;String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含了一个等于该String对象的字符串，则返回这个String对象，否则，将此String对象包含的字符串添加到常量池中，并返回这个字符串的String对象的引用。如下面代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;方法区溢出&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; main&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; args&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; list &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;&amp;gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; i &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
               list&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;++).&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;());&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Exception in thread “main” java.lang.OutOfMemoryError: PermGen space&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;at java.lang.String.intern(Native Method)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PermGen space的全称是Permanent Generation space，是指内存的永久保存区域，也就是说运行时常量池属于方法区（也就是虚拟机永久代）中的一部分。&lt;/p&gt;

&lt;p&gt;另外，方法区是存放Class的相关信息的，运行时如果有大量的类来填满方法区，就会产生OutOfMemoryError异常。&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/19/%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E6%A0%88%E6%BA%A2%E5%87%BA.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/19/%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E6%A0%88%E6%BA%A2%E5%87%BA.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>溢出</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JavaScript-垃圾收集机制</title>
        <description>&lt;p&gt;JavaScript和Java一样具有自动垃圾收集机制。JavaScript的垃圾收集你机制的原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;标记清除：&lt;/strong&gt;这是最常用的垃圾收集方式。原理是：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记—&amp;gt;然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记—&amp;gt;在此之后再被加上标记的变量将被视为准备删除的变量—&amp;gt;最后，垃圾收集器完成内存清除工作，销毁那些带标记的变量并回收它们所占用的内存空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引用计数：&lt;/strong&gt;这是一种不太常见的垃圾收集方式，IE用的就是这种。引用计数是指追踪记录每个值被引用的次数，原理是：当声明一个变量并将一个引用类型值赋给该变量时，则这个值得引用次数初始化为1—&amp;gt;如果同一个值又被赋值给另一个变量，则该值的引用次数加1—&amp;gt;相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值得引用次数减1—&amp;gt;当这个值得引用次数变为0时，说明无需再访问这个变量，可以被垃圾回收机制回收。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/591d135e0001701703930115.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但引用计数存在循环引用的风险，循环引用指的是对象A包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。比如：&lt;/p&gt;

&lt;p&gt;这里例子中，objectA和objectB通过各自的属性相互引用，也就是说，两个对象的引用次数都是2，尽管函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远都不为0。&lt;/p&gt;

&lt;p&gt;IE因为采用了引用计数的垃圾收集而性能低下。&lt;/p&gt;

&lt;p&gt;当然，我们也可以通过解除变量的引用（解除引用）来消除循环引用现象，比如：objectA = null;和objectB = null。&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/javascript/2017/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.html</link>
        <guid isPermaLink="true">http://localhost:4000/javascript/2017/05/18/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.html</guid>
        
        <category>JavaScript</category>
        
        <category>垃圾收集</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>死磕JVM-Java虚拟机对象</title>
        <description>&lt;p&gt;上篇文章我们了解了Java虚拟机的内存模型，也知道不同区域的内存都存储的是什么，现在我们进一步来探究内存上存储的数据是怎么创建的，内存大小又是怎么分配的，数据创建成功后怎么被访问的。我们以Java虚拟机中最大的内存块Java堆为例子来探究上面的三个问题。&lt;/p&gt;

&lt;h2 id=&quot;java堆上对象的创建&quot;&gt;&lt;strong&gt;Java堆上对象的创建&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Java虚拟机遇到一条new指令后，首先会去检查要创建的对象能否在常量池中定位到其对应类的符号引用，并且检查这个引用代表的类是否已经被加载、解析和初始化过，如果没有则先进行类加载过程。&lt;/p&gt;

&lt;p&gt;然后就是为这个对象分配内存，最后执行init方法，这样一个可用的对象创建完毕。&lt;/p&gt;
&lt;h2 id=&quot;java堆对象的内存分配&quot;&gt;&lt;strong&gt;Java堆对象的内存分配&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在类加载检查通过之后，虚拟机就会为新生对象分配内存，分配方式因取决于Java堆中内存是否规整而分为“指针碰撞”和“空闲列表”。在Java堆中的内存是规整的情况下，内存分配方式采用“指针碰撞”，反之采用“空闲列表”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;假设Java堆中的内存是绝对规整的&lt;/strong&gt;，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存的方式就是将这个指针往指向空闲空间那边挪动一段与对象大小相等的距离。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;假设Java堆中的内存不是规整的&lt;/strong&gt;，已使用的内存和空闲的内存相互交错，这样就无法进行简单地指针碰撞了，这时候虚拟机会维护一张列表，列表中记录哪些内存块是可用的，在分配内存的时候就从列表中找到一块足够大的空间划分给对象实例，同时更新列表上的记录，这种内存分配的方式叫做“空闲列表”。&lt;/p&gt;

&lt;p&gt;由此我们知道Java堆对象的内存分配策略是由Java堆内存是否规整来决定的，那么Java堆内存是否规整则由GC是否带有压缩整理功能决定的，所以一般在使用Serial、ParNew等带有压缩整理过程的收集器时，系统采用的是“指针碰撞”的分配策略，在使用CMS这种基于Mark-Sweep算法的收集器时，采用的是“空闲列表”的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由于Java堆是线程共享的，那么内存的分配在线程并发的情况下如何保证线程安全呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管采用哪种内存分配策略，在多线程下进行Java堆内存分配的时候，可能存在正在给A对象分配内存，但指针还没来得及修改而对象B又使用了原来的指针来分配内存的这种情况。&lt;/p&gt;

&lt;p&gt;有两种解决方案：第一是对分配内存空间的动作进行同步处理以保证操作的原子性，也就是说同一时刻只有一个线程能进行分配内存的操作；第二是把内存分配的操作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）,线程在自己的TLAB中分配内存，只有在TLAB用完了，在分配新的TLAB时才需要同步锁定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;讲完了Java堆对象的内存分配策略，那存储的对象到底存储的是什么呢？对象中都包含哪些内容呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对象在内存中主要存储这三个信息：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。&lt;/p&gt;

&lt;p&gt;对象头，存储对象自身的运行时数据：哈希码，GC分代年龄，锁状态标志等。&lt;/p&gt;

&lt;p&gt;实例数据，存储对象真正有效的信息。&lt;/p&gt;

&lt;p&gt;对齐填充，起到占位符的作用，当实例数据部分没有对齐时，就需要对齐填充来补全。&lt;/p&gt;

&lt;h2 id=&quot;java堆对象的访问定位&quot;&gt;&lt;strong&gt;Java堆对象的访问定位&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对象创建并分配好了内存，那么接下来就可以访问对象了，Java程序是通过栈中的reference数据来操作堆上的具体对象，虚拟机提供了两种机制来访问堆中的实例对象：句柄和直接指针。
使用句柄：Java堆中会划分一块区域作为句柄池，Java栈中的本地变量表中的reference数据存储的就是对象的句柄地址，而句柄中则包含的是到对象实例数据的指针和对象类型数据的指针。
&lt;img title=&quot;死磕JVM-Java虚拟机对象_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/591d078d0001d19915940584.png&quot; style=&quot;width:100%&quot; alt=&quot;图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接指针：reference数据存储是的对象的实例数据的引用地址和到对象类型数据的指针。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕JVM-Java虚拟机对象_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/591d079d0001210016240586.png&quot; style=&quot;width:100%&quot; alt=&quot;图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用句柄的好处是Java栈中的本地变量表中的reference数据是相对稳定的，不需要经常变动，比如在执行GC操作时移动对象，这个时候需要改变对象在堆中的地址，在句柄机制中，只需要改动句柄池中的实例数据的指针，而不需要修改reference数据。但缺点是增加了一次指针定位的开销，对于对象访问比较频繁的时候，这种开销累计起来也是很大的，所以对于HotSpot而言，使用的是直接指针的方式。&lt;/p&gt;
</description>
        <pubDate>Thu, 18 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/18/Java%E5%A0%86%E4%B8%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/18/Java%E5%A0%86%E4%B8%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>虚拟机对象</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JVM-Java内存模型</title>
        <description>&lt;p&gt;Java虚拟机是Java工程师必学的进阶功课，这段时间开始死磕JVM。今天把JVM的基础知识点Java的内存模型怼清楚，废话不多说，干货走起！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/591a5ed500016f8704170268.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;程序计数器&quot;&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么&lt;/strong&gt;：程序计数器是很小的一块内存空间，它是当前线程所执行的字节码的行号指示器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有什么用：&lt;/strong&gt;解释器通过这个计数器来选取下一条需要执行的字节码指令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;如果线程执行的是Java方法，存储的是正在执行的虚拟机字节码指令的地址；如果是native方法，计数器值为空（undefined）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程私有的：&lt;/strong&gt;多线程是线程轮流切换并分配处理器执行时间片的方式来实现的，在任何确定的时刻，一个处理器（对于多核处理器来说就是一个内核）都只会执行一条线程，所以，为了线程在切换后能恢复到正确的执行位置，每个线程应该独立拥有一个程序计数器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;唯一一个无内存溢出异常的区域。&lt;/p&gt;
&lt;h2 id=&quot;java虚拟机栈&quot;&gt;&lt;strong&gt;Java虚拟机栈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;虚拟机栈是Java方法的内存模型，每一个Java方法从调用到执行完成就对应着一个栈帧在虚拟机栈中的入栈和出栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;每个方法的执行就会创建一个栈帧，这个栈帧会存储这个Java方法的局部变量表，操作数栈，动态链接，方法出口等信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程私有的：&lt;/strong&gt;每个线程所执行的方法可能是不一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;如果线程请求的栈深度&amp;gt;虚拟机允许的深度，抛出栈溢出异常；如果扩展时无法申请到足够的内存，抛出内存溢出异常。&lt;/p&gt;
&lt;h2 id=&quot;本地方法栈&quot;&gt;&lt;strong&gt;本地方法栈&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;本地方法栈的作用和虚拟机栈非常相似，只不过本地方法栈是native方法的内存模型，每一个native方法从调用到执行完成就对应着一个栈帧在本地方法栈中的入栈和出栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;同虚拟机栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程私有的：&lt;/strong&gt;同虚拟机栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;同虚拟机栈。&lt;/p&gt;
&lt;h2 id=&quot;java堆&quot;&gt;&lt;strong&gt;Java堆&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;Java堆是Java虚拟机管理的内存中最大的一块，Java堆是在虚拟机启动的时候创建的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;存放对象实例，几乎所有的对象实例都在这个内存区域分配内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程共享的：&lt;/strong&gt;所有的线程都可以访问不同的对象。其实从内存分配的角度来看，线程共享的Java堆可能其实是多个线程私有的分配缓冲区，不同的线程将各自的对象实例放在看似共享的Java堆的各自的缓冲区上，这样划分可以更好的回收内存，也可以更好点分配内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;Java堆可以处于物理上不连续的内存空间上，但逻辑上一定是连续的，在堆中没有内存可以完成对象实例的分配，且无法再扩展时，会抛出内存溢出异常。&lt;/p&gt;
&lt;h2 id=&quot;方法区&quot;&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;和堆一样，是各个线程共享的内存区域。很多人把方法区称为永久代，但是本质上这两个不等价，Java虚拟机将GC分代收集扩展至方法区，使用永久代来实现方法区，这样GC收集器就能像管理Java堆一样管理方法区而不需要再写一套GC收集来管理方法区。当然在方法区里也可以设置不进行GC收集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存储什么内容：&lt;/strong&gt;已被虚拟机加载的类信息，类常量，类的静态变量，即时编译器编译后的代码等。运行时常量池也是方法区的一部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么是线程共享的：&lt;/strong&gt;各个线程都可以访问虚拟机加载的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;内存溢出异常。&lt;/p&gt;
&lt;h2 id=&quot;直接内存&quot;&gt;&lt;strong&gt;直接内存&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是什么：&lt;/strong&gt;直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机定义的内存区域，但也经常被使用。JDK1.4加入了NIO类，一种基于通道与缓冲区的新I/O方式，NIO可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为直接内存的引用来操作直接内存，这样可以避免在Java堆和native堆来回复制数据，从而提高了性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会出现什么异常情况：&lt;/strong&gt;受机器总内存的影响，会出现内存溢出异常。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</guid>
        
        <category>java</category>
        
        <category>JVM</category>
        
        <category>内存模型</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JavaScript-函数按值传递参数</title>
        <description>&lt;p&gt;早起打卡，今天死磕函数按值传递参数，干货走起……&lt;/p&gt;

&lt;p&gt;基本类型的变量传递是将值A复制一份给被传递的变量B，两个变量值得变化是互不干扰的；而引用类型的变量传递是将引用类型变量A的引用传递给被传递的变量B，这个B的变化会反映到A上。例如：&lt;/p&gt;

&lt;p&gt;例1：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; addTen&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     num &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; num&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; count &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; result &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; addTen&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//20&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//30&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;javaScript&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; language &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//javaScript&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两种函数的值传递是比较好理解的，在例1中，num其实是addTen的局部变量，在调用addTen函数的时候，count将值复制给了局部变量num，虽然函数内部num的值加了10，但是这一变化不会影响给函数外部的count变量。复制前后栈的变化图如下：
&lt;img title=&quot;死磕JavaScript-函数按值传递参数_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59165ced00011b7f19201338.jpg&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;
在例2中你可能有所疑惑，因为这看起来就像是引用传递啊，不像是标题所说的函数按值传递，这里language的引用复制传递给了obj局部变量，所以是引用传递呀。那我们来看下一个例子：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;javaScript&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
     obj&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;new JavaScript&quot;&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; language &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
setName&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//javaScript&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果说language是按引用传递的，那么language就会自动被修改为指向其name属性值为“new JavaScript”的新对象，但结果确实“javaScript”，我们看下复制前后的栈和堆的变化图就能更清楚了。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;死磕JavaScript-函数按值传递参数_&quot; 图片1=&quot;&quot; src=&quot;http://img.mukewang.com/59165d240001d2e019201756.jpg&quot; alt=&quot;图片描述&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这下应该能明白了，也就是说这里的函数按值传递中的“值”指的是栈中的值，所以对于引用类型，是将栈中的language的值复制到obj中，也就是说这两个值对应的堆地址是一样的，其在堆中对应的对象是一样的，对obj中的改变对反映到language中，但如果改变了obj的堆地址那么obj和language就没什么关系了。&lt;/p&gt;

</description>
        <pubDate>Sun, 14 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/javascript/2017/05/14/%E5%87%BD%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.html</link>
        <guid isPermaLink="true">http://localhost:4000/javascript/2017/05/14/%E5%87%BD%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.html</guid>
        
        <category>JavaScript</category>
        
        <category>函数</category>
        
        <category>传递参数</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>浅谈Java集合Collection</title>
        <description>&lt;p&gt;一直想找个时间系统的整理下Java的集合类，毕竟Collection包含了很多我们在实际项目中要用到的数据结构，比如列表、set、队列等，下面我们直接来看看Java集合类中各大数据结构。&lt;/p&gt;

&lt;p&gt;Collection部分层次结构如下所示：&lt;/p&gt;

&lt;p&gt;Collection &lt;br /&gt;
├List &lt;br /&gt;
│├LinkedList &lt;br /&gt;
│├ArrayList &lt;br /&gt;
│└Vector &lt;br /&gt;
│　└Stack &lt;br /&gt;
├Set &lt;br /&gt;
│├HashSet &lt;br /&gt;
│├TreeSet  &lt;br /&gt;
├Queue&lt;br /&gt;
│├BlockingQueue &lt;br /&gt;
│├ArrayDeque &lt;br /&gt;
│└PriorityQueue&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、Collection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;子接口：Set，List，Queue&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取该集合的大小
int size();
//判空
boolean isEmpty();
//判断集合是否包含某元素
boolean contains(Object o);
//获取集合的迭代器，迭代器的具体实现在子类中用内部类实现
Iterator&amp;lt;E&amp;gt; iterator();
//返回该集合的元素数组
Object[] toArray();
//添加元素
boolean add(E e);
//删除指定元素值的元素
boolean remove(Object o);
//判断集合是否包含指定集合中所有的元素
boolean containsAll(Collection&amp;lt;?&amp;gt; c);
//向当前集合添加指定集合中所有的元素
boolean addAll(Collection&amp;lt;? extends E&amp;gt; c);
//在当前集合中移除指定集合中所有的元素
boolean removeAll(Collection&amp;lt;?&amp;gt; c);
//保留指定集合中的元素，删除当前集合中不在指定集合中的元素
boolean retainAll(Collection&amp;lt;?&amp;gt; c);
//清空集合
void clear();
//Comparison and hashing
boolean equals(Object o);
int hashCode(); 还有一些复写Iterable接口的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;二、List&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实现类包括：LinkedList,Vector,ArrayList。&lt;/p&gt;

&lt;p&gt;继承Collection，可以按索引的顺序访问，元素顺序均是按添加的先后进行排列的，允许重复的元素,允许多个null元素。&lt;/p&gt;

&lt;p&gt;除了包含Collection中的方法，还有一些自己的方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取指定索引的元素
E get(int index);
//替代指定索引位置的元素
E set(int index, E element);
//添加指定索引位置的元素
void add(int index, E element);
//移除指定索引位置的元素
E remove(int index);
//获取指定元素在集合中第一次出现的索引值
int indexOf(Object o);
//获取指定元素在集合中最后一次出现的索引值
int lastIndexOf(Object o);
//获取ListIterator迭代器，迭代器的具体实现在子类中用内部类实现
ListIterator&amp;lt;E&amp;gt; listIterator();
//获取集合中从fromIndex到toIndex的值
List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ListIterator&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;List除了具备Collection接口的iterator方法外，还提供了listIterator，listIterator相对iterator，允许添加、设定元素，前后向遍历。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public interface ListIterator&amp;lt;E&amp;gt; extends Iterator&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean hasNext();
E next();
boolean hasPrevious();
E previous();
int nextIndex();
int previousIndex();
void remove();
void set(E e);
void add(E e);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.1 ArrayList&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ArrayList依赖于数组实现的，初始长度为10的Object[]，并且可随需要而增加的动态数组。当元素超过10，采用ensureCapacity方法来扩容，ArrayList底层会新生成一个数组，长度为原来的1.5倍+1, 也就是自动增长了差不多是原来的一半，然后将原数组内容复制到新数组中，并且后续增加的内容会放到新数组中。&lt;/p&gt;

&lt;p&gt;ArrayList对随机访问性能很好，但进行大量插入，删除操作，性能很差，因为操作之后后续元素需要移动。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
        implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final int DEFAULT_CAPACITY = 10;
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ArrayList(int initialCapacity) {}
public ArrayList() {}
public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;扩容方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void ensureCapacity(int minCapacity) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.2 Vector&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;特点与ArrayList相同， 不同的是Vector操作元素的方法是同步（对集合操作的方法都用synchronized关键字）的，同一时刻只能有一个线程访问，由于Vector是线程同步的，那么性能上要比ArrayList要低。Vector也是依赖数组实现的，在需要对Vector扩容时，自动增长为原来数组长度的一倍。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class Vector&amp;lt;E&amp;gt;
    extends AbstractList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;**构造方法  **&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//默认初始容量为10
public Vector()  
//默认增量为0
public Vector(int initialCapacity)
public Vector(int initialCapacity,int capacityIncrement)  
        第一个参数是初始容量,第二个参数是当Vector满时的增量  
public Vector(Collection&amp;lt;? extends E&amp;gt; c) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.2.1 Stack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Stack类继承了Vector，实现了一个后进先出的堆栈，Stack提供了5个额外的方法实现栈的操作。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public
class Stack&amp;lt;E&amp;gt; extends Vector&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Stack() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;实现栈的方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public E push(E item) {}
//调用了peek操作，获取栈顶元素，并删除栈顶元素
public synchronized E pop() {}
//获取栈顶元素，不删除栈顶元素
public synchronized E peek() {}
public boolean empty() {}
public synchronized int search(Object o) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.3 LinkedList&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LinkedList功能与ArrayList，Vector相同，但内部是依赖双向链表实现的，也就是说每个结点都存放着指向前驱结点和后驱结点的引用，因此有很好的插入和删除性能,但随机访问元素的性能很差。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class LinkedList&amp;lt;E&amp;gt;
    extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable
{}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public LinkedList() {}
public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;LinkedList类的元素表示：Node内部类&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static class Node&amp;lt;E&amp;gt; {
    E item;
    Node&amp;lt;E&amp;gt; next;
    Node&amp;lt;E&amp;gt; prev;

    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;正序遍历链表&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void printList(List link) {  
    // 得到链表的迭代器,位置指向链头  
    ListIterator li = link.listIterator();  
    // 判断迭代器中是否有下一个元素  
    while (li.hasNext()) {  
        // 返回下个元素  
        System.out.println(li.next() + &quot; &quot;);  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;逆序遍历链表&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void printReversedList(List link) {  
    // 得到链表的迭代器,位置指向link.size()结尾  
    ListIterator li = link.listIterator(link.size());  
    // 判断迭代器中是否有前一个元素  
    while (li.hasPrevious()) {  
        // 返回前一个元素  
        System.out.println(li.previous() + &quot; &quot;);  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在链表中任意位置插入元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;链表是一个有序集合，调用LinkedList.add方法将对象插入到链表的尾部，如何添加元素到链表中的任意位置呢？这种操作可以交由迭代器负责。ListIterator的add即可实现。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void addElement(){
	List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;String&amp;gt;();
	list.add(&quot;aaa&quot;);
	list.add(&quot;bbb&quot;);
	list.add(&quot;ccc&quot;);
	System.out.println(list);//[aaa, bbb, ccc]
	ListIterator&amp;lt;String&amp;gt; iterator = list.listIterator();
	iterator.next();//跳过第一个元素
	iterator.add(&quot;111&quot;);//在第二个位置插入元素111
	System.out.println(list);//[aaa, 111, bbb, ccc]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;少用list.get(i)，用list.listIterator(i)代替&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LinkedList提供了一个用来访问某个特定元素的get方法，但这种方式的效率是非常低的，在代码中应该尽量少用这种方式，因为链表中每次查找一个元素都要从链表的头部重新开始搜索，如果索引值i大于size()/2则从列表尾端开始搜索元素。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}

Node&amp;lt;E&amp;gt; node(int index) {
    // assert isElementIndex(index);

    if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {// &amp;gt;&amp;gt; 1 相当于除以2
        Node&amp;lt;E&amp;gt; x = first;
        for (int i = 0; i &amp;lt; index; i++)
            x = x.next;
        return x;
    } else {
        Node&amp;lt;E&amp;gt; x = last;
        for (int i = size - 1; i &amp;gt; index; i--)
            x = x.prev;
        return x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还是之前的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(list.get(2));//bbb
ListIterator&amp;lt;String&amp;gt; iterator2 = list.listIterator(2);
System.out.println(iterator2.next());//bbb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、Set&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不包含重复元素，最多包含一个null，元素没有顺序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public interface Set&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1 HashSet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实现了Set接口，底层用hashMap来实现，hashSet的大部分方法也都是调用hashMap来实现的。散列表是用链表数组来实现的，每个列表称之为桶，当桶被占满的时候，就会出现散列冲突。散列表是无序的(hashMap和hashSet都是)。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class HashSet&amp;lt;E&amp;gt;
    extends AbstractSet&amp;lt;E&amp;gt;
    implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable{}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public HashSet() {
    map = new HashMap&amp;lt;&amp;gt;();
}
public HashSet(Collection&amp;lt;? extends E&amp;gt; c) {
    map = new HashMap&amp;lt;&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);
}
public HashSet(int initialCapacity) {
    map = new HashMap&amp;lt;&amp;gt;(initialCapacity);
}
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;HashSet保证了当前集合对于某一元素的唯一存在性，集合中是否存在一个对象是通过equals()和hashCode()协同判断。&lt;/p&gt;

&lt;p&gt;HashSet的add()方法详解:&lt;/p&gt;

&lt;p&gt;判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致&lt;br /&gt;
如果不一致,直接加进去&lt;br /&gt;
如果一致,再进行equals()比较&lt;br /&gt;
    如果equals()返回true,对象已经存在不增加进去&lt;br /&gt;
    如果equals()返回false,把对象增加进去&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 TreeSet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;树集合HashSet散列集很像，但树集是有序集合。在树集中可以任意插入元素到集合中，但对集合进行遍历的时候，每个值会自动地按照排序后的顺序呈现。底层实现是采用红黑树来存储元素。&lt;/p&gt;

&lt;p&gt;添加元素的效率：hashMap &amp;gt; treeSet &amp;gt; linkedList &amp;gt; arrayList&lt;/p&gt;

&lt;p&gt;treeSet中的元素如何排序的呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;treeSet中的元素实现Comparable接口&lt;/li&gt;
  &lt;li&gt;将Comparator对象传递给TreeSet构造器实现集合中元素的排序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;treeSet中的元素实现Comparable接口&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Comparable&amp;lt;T&amp;gt; {
    public int compareTo(T o);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如简单的Integer&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public int compareTo(Integer anotherInteger) {
   return compare(this.value, anotherInteger.value);
}
public static int compare(int x, int y) {
   return (x &amp;lt; y) ? -1 : ((x == y) ? 0 : 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果集合中存放的是某些自定义的对象，那么需要让你实现Comparable接口，并重写compareTo方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将Comparator对象传递给TreeSet构造器实现集合中元素的排序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用Comparable接口定义排列排序有一定的局限性，如果需要对某一特定的类的不同属性进行排序，Comparable就不能很好的满足这一需求，这个时候我们可以通过将Comparator对象传递给TreeSet构造器实现集合中元素的排序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Comparator&amp;lt;T&amp;gt; {
	int compare(T o1, T o2);
}

SortedSet&amp;lt;Item&amp;gt; sortByDescription = new TreeSet&amp;lt;&amp;gt;(new Comparator&amp;lt;Item&amp;gt;(){
	public int compare(Item a, Item b){
		String descrA = a.getDescription;
		String descrB = b.getDescription;
		return descrA.compareTo(descrB);
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、Queue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Queue接口与List、Set同一级别，都是继承了Collection接口。Queue不允许包含NULL元素。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public interface Queue&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队列方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//增加一个元素，队列满则抛出IIIegaISlabEepeplian异常
boolean add(E e);
//添加一个元素，队列满则返回false
boolean offer(E e);
//移除并返回队列头部的元素，队列空则抛出一个NoSuchElementException异常
E remove();
//移除并返问队列头部的元素，队列空则返回null
E poll();
//返问但不移除队列头部的元素，队列空则抛出一个NoSuchElementException异常
E element();
//返问但不移除队列头部的元素，队列空则返回null
E peek();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.1 BlockingQueue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用阻塞队列两个显著的好处就是：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public interface BlockingQueue&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt; {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阻塞队列的方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//增加一个元素，队列满则阻塞当前线程
void put(E e) throws InterruptedException;
//移除并返问队列头部的元素，队列空则阻塞当前线程
E take() throws InterruptedException;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.2 ArrayDeque&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java SE6中引入了Deque接口，提供了双端队列一系列实现。ArrayDeque中用初始容量16的数组或给定初始容量来构造一个无限双端队列。值得注意的是LinkedList也是Deque的一个实现类，也可以用来构造双端队列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class ArrayDeque&amp;lt;E&amp;gt; extends AbstractCollection&amp;lt;E&amp;gt;
                           implements Deque&amp;lt;E&amp;gt;, Cloneable, Serializable
{}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ArrayDeque() {
    elements = new Object[16];
}
public ArrayDeque(int numElements) {
    allocateElements(numElements);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.3 PriorityQueue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;优先队列，队列中的元素可以按照任意的顺序输入，但却可以按照指定的顺序进行检索（TreeSet），优先队列使用了堆数据结构，堆是自我调整的二叉树，对树进行一系列的添加删除等操作，让最小（大）的元素移动到根，而不必浪费时间对元素进行排序。&lt;/p&gt;

&lt;p&gt;和TreeSet一样，优先队列可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供比较器（Comparator）的对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public class PriorityQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt;
    implements java.io.Serializable {}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//优先队列默认初始值大小为11
private static final int DEFAULT_INITIAL_CAPACITY = 11;

public PriorityQueue() {
    this(DEFAULT_INITIAL_CAPACITY, null);
}
public PriorityQueue(int initialCapacity) {
    this(initialCapacity, null);
}
public PriorityQueue(Comparator&amp;lt;? super E&amp;gt; comparator) {
    this(DEFAULT_INITIAL_CAPACITY, comparator);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;五、Collection与Collections的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。&lt;/p&gt;

&lt;p&gt;java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，因为内部的构造函数被私有化了就像一个工具类，服务于Java的Collection框架。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;private Collections() {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java - Collection：http://blog.csdn.net/itlwc/article/details/10148321&lt;/p&gt;

&lt;p&gt;java中queue的使用：http://www.cnblogs.com/end/archive/2012/10/25/2738493.html&lt;/p&gt;
</description>
        <pubDate>Sat, 13 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/13/%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88Collection.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/13/%E6%B5%85%E8%B0%88Java%E9%9B%86%E5%90%88Collection.html</guid>
        
        <category>Collection</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>死磕JavaScript-松散类型、js变量存储模型、变量提升</title>
        <description>&lt;p&gt;好久没来慕课网学习了，上研究生之后，发现突然又变回学生后对自己的要求也松很多，开始到处旅游，做些没计划的事情，也很少写技术博客了，最近静下心来开始研究底层的东西，以后就在这写了，希望能死磕自己，坚持下去。好了，干货走起……&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;什么是松散类型&lt;/li&gt;
  &lt;li&gt;JavaScript两种变量类型的内存模型&lt;/li&gt;
  &lt;li&gt;预加载&lt;/li&gt;
  &lt;li&gt;变量提升&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;javascript里的变量和其他语言有很大的不同，javascript的变量是一个松散的类型，松散类型变量的特点是变量定义时候不需要指定变量的类型，变量在运行时候可以随便改变数据的类型，但是这种特性并不代表javascript变量没有类型，当变量类型被确定后javascript的变量也是有类型的。&lt;/p&gt;

&lt;p&gt;但是在现实中，很多程序员把javascript松散类型理解为了javascript变量是可以随意定义即你可以不用var定义，也可以使用var定义，其实在javascript语言里变量定义没有使用var，变量必须有赋值操作，只有赋值操作的变量是赋予给window，这其实是javascript语言设计者提升javascript安全性的一个做法。&lt;/p&gt;

&lt;p&gt;此外javascript语言的松散类型的特点以及运行时候随时更改变量类型的特点，很多程序员会认为javascript变量的定义是在运行期进行的，更有甚者有些人认为javascript代码只有运行期，其实这种理解是错误的，javascript代码在运行前还有一个过程就是：预加载，预加载的目的是要事先构造运行环境例如全局环境，函数运行环境，还要构造作用域链，而环境和作用域的构造的核心内容就是指定好变量属于哪个范畴，因此在javascript语言里变量的定义是在预加载完成而非在运行时期。&lt;/p&gt;

&lt;p&gt;讲一个例子来讲解：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; a &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; test&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
    console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//undefined&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; a &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;lit&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
    console&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;com&quot;&gt;//2&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
test&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个令人诧异的结果，为什么第一个弹出框显示的是undefined，而不是1呢？这种疑惑的原理我描述如下：&lt;/p&gt;

&lt;p&gt;一个页面里直接定义在script标签下的变量是全局变量即属于window对象的变量，按照javascript作用域链的原理，当一个变量在当前作用域下找不到该变量的定义，那么javascript引擎就会沿着作用域链往上找直到在全局作用域里查找，按上面的代码所示，虽然函数内部重新定义了变量的值，但是内部定义之前函数使用了该变量，那么按照作用域链的原理在函数内部变量定义之前使用该变量，javascript引擎应该会在全局作用域里找到变量定义，而实际情况却是变量未定义，这到底是怎么回事呢？&lt;/p&gt;

&lt;p&gt;这里我要先讲一个知识点，就是&lt;strong&gt;JavaScript的变量存储模型&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;javascript语言和java语言一样变量是分为两种类型：基本数据类型和引用类型。基本类型是指：Undefined、Null、Boolean、Number和String；而引用类型是指对象，所以javascript的对象指的是引用类型。但是实际开发里如果我们对基本类型和引用类型的区别不是很清晰，就会碰到我们很多不能理解的问题，下面我们来看看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; str &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Sharpxiajun&lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;;
 var num = 1;
 var xxx;
 console.log(str);//运行结果：sharpxiajun
 console.log(num);//运行结果：1
 console.log(xxx);//运行结果：undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们使用引用类型时候，结果就和上面完全不同了，大家请看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; obj1 &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kwd&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;
obj1&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;name &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt; &lt;/span&gt;&lt;span class=&quot;str&quot;&gt;&quot;obj1 name”;
console.log(obj1.name);// 运行结果：obj1 name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Javascript里的基本变量是存放在栈区的（栈区指内存里的栈内存），它的存储结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.mukewang.com/591552cf0001746703950149.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;javascript里引用变量的存储就比基本类型存储要复杂多，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，如下图所示：
&lt;img src=&quot;http://img.mukewang.com/591552f20001700e05650292.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;理解基本类型变量和引用类型变量的存储结构后，结合上面开始讲的预加载的知识点，我们就能分析出开始那个例子的深层原因了。&lt;/p&gt;

&lt;p&gt;引子里的代码在函数的局部作用域下变量a被重新定义了，在预加载时候a的作用域范围也就被框定了，a变量不再属于全局变量，而是属于函数作用域，只不过赋值操作是在运行期执行（这就是为什么javascript语言在运行时候会改变变量的类型，因为赋值操作是在运行期进行的），所以第一次使用a变量时候，a变量在局部作用域里没有被赋值，只有栈区的标示名称，因此结果就是undefined了。（这也就是js里的变量提升的原理）&lt;/p&gt;

&lt;p&gt;不过赋值操作也不是完全不对预加载产生影响，预加载时候javascript引擎会扫描所有代码，但不会运行它，当预加载扫描到了赋值操作，但是赋值操作的变量有没有被var定义，那么该变量就会被赋予全局变量即window对象。&lt;/p&gt;
</description>
        <pubDate>Fri, 12 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/javascript/2017/05/12/%E6%9D%BE%E6%95%A3%E7%B1%BB%E5%9E%8B-js%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html</link>
        <guid isPermaLink="true">http://localhost:4000/javascript/2017/05/12/%E6%9D%BE%E6%95%A3%E7%B1%BB%E5%9E%8B-js%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html</guid>
        
        <category>JavaScript</category>
        
        <category>松散类型</category>
        
        <category>变量存储模型</category>
        
        <category>变量提升</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Java知识点大扫盲</title>
        <description>&lt;p&gt;在Java的学习过程中，多多少少会遗漏掉一些基本的知识点，而这些基本的知识点往往是奠定Java基础很重要的部分，里面的很多知识点我们编程中往往用不到，但理解它们能帮助我们更好地掌握Java，本文是一个长期贴，会不定时更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、函数的形参到底获取的是实参的值还是实参的引用地址？&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main17{     
     String str = &quot;start&quot;;
     char ch[] = {'a','b','c'};
     Integer a = 1;
     float f = 1.0f;
     double d = 1.0;     
     public void change(String str,char[] ch){
          str = &quot;end&quot;;
          ch[0] = 'e';
     }     
     public void change(Integer a){
          a = 2;
     }     
     public void change(float f){
          f = 2.0f;
     }
     public void change(double d){
          d = 2.0;
     }     
     public static void main(String[] args) {
          Main17 m17 = new Main17();
          m17.change(m17.str, m17.ch);
          System.out.print(m17.str + &quot; and &quot;);
          System.out.println(m17.ch);
          m17.change(m17.a);
          System.out.println(m17.a);
          m17.change(m17.f);
          System.out.println(m17.f);
          m17.change(m17.d);
          System.out.println(m17.d);
     }
}
result：
start and ebc
1
1.0
1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以发现String，float，double，这些值changea后都没变，但是char的值改变了，也就是说String，float，double给形参传入的是实参的值，因为这些类都是final类（还有：Integer，Long，Short）；而char给形参传入的是实参的引用地址，所以change中改变了char的值会反映到类的全局变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Java中&amp;amp;&amp;amp;和&amp;amp;以及||和|的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;amp;&amp;amp;和&amp;amp;都是表示与，区别是&amp;amp;&amp;amp;只要第一个条件为false，后面条件就不再判断。而&amp;amp;要对所有的条件都进行判断。&lt;/p&gt;

&lt;p&gt;但是||和|都是表示“或”，区别是||只要第一个条件为true，后面的条件就不再判断，而|要对所有的条件进行判断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、==与equals&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String s = &quot;hello&quot;；
String t = “hello”；
char c [] = {'h','e','l','l','o'}；

s == t //true
s.equals(c)//false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先==与equals是有明显区别的。&lt;/p&gt;

&lt;p&gt;==强调栈中的比较，可以理解为地址比较&lt;/p&gt;

&lt;p&gt;equals强调对象的内容比较&lt;/p&gt;

&lt;p&gt;String s=“hello”；会在栈中生成hello字符串，并存入字符串常量池中。&lt;/p&gt;

&lt;p&gt;String t=“hello” ；创建时，会在字符串常量池中寻找，当找到需要的hello时，不进行字符串的创建，引用已有的。 所以，s==t返回true，s.equals(t)也是true。&lt;/p&gt;

&lt;p&gt;char c[]={‘h’,’e’,’l’,’l’,’o’}; c==s这个是不存在的，==两边类型不同，t.equals(c)这个语句在anObject instanceof String这步判断不会通过，也就是cha[] 压根不能与String相比较，类型不是相同的。返回false。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、静态成员变量或静态代码块&amp;gt;mian方法&amp;gt;非静态成员变量或非静态代码块&amp;gt;构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;静态方法或静态块会比构造方法（包括父类的构造函数）先加载，且只加载一次。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test{
     public Test(){
          System.out.println(&quot;I'm 构造器&quot;);
     }
     static{
          System.out.println(&quot;I'm static&quot;);
     }
}
result：
I'm static
I'm 构造器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、String的replaceAll方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) 
	+ &quot;MyClass.class&quot;;
System.out.println(classFile);
result：
/////////MyClass.class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于replaceAll方法的第一个参数是一个正则表达式，而”.”在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/”。如果想替换的只是”.”，那么要写成”\.”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、try-catch-finally&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int func (){
    try{
        return 1;
    }catch (Exception e){
        return 2;
    }finally{
        return 3;
    }
}
result：
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Try catch finally获取异常错误的结构，try中没有异常时，但是有return等跳转语句，这样会引发程序控制流离开当前的try，即在return语句执行之后返回之前去完成finally中资源的释放。 由于代码中的finally中有return语句，将try中的return语句覆盖，程序直接跳出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、匿名内部类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;匿名内部类也就是没有名字的内部类。&lt;/p&gt;

&lt;p&gt;正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写
但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。&lt;/p&gt;

&lt;p&gt;实例1:不使用匿名内部类来实现抽象方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Person {
    public abstract void eat();
}
class Child extends Person {
    public void eat() {
        System.out.println(&quot;eat something&quot;);
    }
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}
运行结果：eat something
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用。&lt;/p&gt;

&lt;p&gt;但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？&lt;/p&gt;

&lt;p&gt;这个时候就引入了匿名内部类。&lt;/p&gt;

&lt;p&gt;实例2：匿名内部类的基本实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Person {
    public abstract void eat();
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}
运行结果：eat something
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，我们直接将抽象类Person中的方法在大括号中实现了。&lt;/p&gt;

&lt;p&gt;这样便可以省略一个类的书写。&lt;/p&gt;

&lt;p&gt;并且，匿名内部类还能用于接口上。&lt;/p&gt;

&lt;p&gt;实例3：在接口上使用匿名内部类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Person {
    public void eat();
}
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}
运行结果：eat something
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现。&lt;/p&gt;

&lt;p&gt;最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口。&lt;/p&gt;

&lt;p&gt;实例4：Thread类的匿名内部类实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i &amp;lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        t.start();
    }
}
运行结果：1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实例5：Runnable接口的匿名内部类实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i &amp;lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}
运行结果：1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;8、Integer等的比较&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer i01 = 59;
int i02 = 59;
Integer i03 = Integer.valueOf(59);
Integer i04 = new Integer(59);

i01 == i02//true
i01 == i03//true
i02 == i03//true
i01 == i04//false
i02 == i04//true
i03 == i04//false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.valueOf(59)&lt;/code&gt;会从Integer中的私有静态类IntegerCache中获取Integer对象，所以与i01和i02对比都为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;new Integer(59)&lt;/code&gt;是新创建Integer对象，新分配了内存，所以与i01和i03对比都为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;。int和Integer(只要值相等，无论new否)比，都为true，因为会把Integer自动拆箱为int再去比，所以i02与i04对比为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Byte,Short,Integer,Long,Character这5种整型的包装类在对应值小于等于127并且大于等于-128时会使用常量池，因为他们至占用一个字节(-128~127);超出这个范围将会返回一个新的包装类对象。&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];
}

public static Long valueOf(long l) {
    final int offset = 128;
    if (l &amp;gt;= -128 &amp;amp;&amp;amp; l &amp;lt;= 127) { // will cache
        return LongCache.cache[(int)l + offset];
    }
    return new Long(l);
}

public static Short valueOf(short s) {
    final int offset = 128;
    int sAsInt = s;
    if (sAsInt &amp;gt;= -128 &amp;amp;&amp;amp; sAsInt &amp;lt;= 127) { // must cache
        return ShortCache.cache[sAsInt + offset];
    }
    return new Short(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {

    Integer a = 127;
    Integer b = 127;

    Integer c = 128;
    Integer d = 128;

    System.out.println(a == b);//true
    System.out.println(c == d);//false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;9、Spring的事务传播特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PROPAGATION_required–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;/p&gt;

&lt;p&gt;PROPAGATION_supports–支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;/p&gt;

&lt;p&gt;PROPAGATION_mandatory–支持当前事务，如果当前没有事务，就抛出异常。&lt;/p&gt;

&lt;p&gt;PROPAGATION_requires _new–新建事务，如果当前存在事务，把当前事务挂起。&lt;/p&gt;

&lt;p&gt;PROPAGATION_not _supported–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/p&gt;

&lt;p&gt;PROPAGATION_never–以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10、i++与++i&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Inc {
    public static void main(String[] args) {
       Inc inc = new Inc();
       int i = 0;
       inc.fermin(i); //查看知识点1
       i= i ++;
       System.out.println(i);  //0，这个结果是不是很意外
    }
    void fermin(int i){
       i++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Java使用了中间缓存变量机制：&lt;/p&gt;

&lt;p&gt;i=i++;等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;temp=i； (等号右边的i)
i=i+1;      (等号右边的i)
i=temp;   (等号左边的i)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而i=++i;则等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i=i+1;
temp=i;
i=temp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但如果把“i= i ++; ”改为“i++”，结果会是1。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Spike
{
    public static void main(String[] args)
    {
        Counter a = new Counter();
        System.out.println(a.increment());
        System.out.println(a.anotherIncrement());
        Counter b = new Counter();
        System.out.println(b.increment());
    }
}
class Counter
{
    private static int count = 0;
    public int increment()
    {
        return count++;
    }
    public int anotherIncrement()
    {
        return ++count;
    }
}
result：
0 2 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;increment()方法返回当前count值，然后count增加1&lt;/p&gt;

&lt;p&gt;antoherIncrement()方法让count增加1，然后返回count值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11、null&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main17{
  private static void testMethod(){
        System.out.println(&quot;testMethod&quot;);
   }
    public static void main(String args[]) {
      ((Main17)null).testMethod();
    }
}
result：
testMethod
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Java中，null是一个关键字，不是对象，也不是Objcet的实例，它用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。&lt;/p&gt;

&lt;p&gt;比如：int a = null;是错误的。Ojbect o = null是正确的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12、类方法、类变量和实例方法、实例变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用static修饰的方法和变量是类方法、类变量，可以直接用类名.的方法来调用；&lt;/p&gt;

&lt;p&gt;没有用static修饰的方法和变量就属于实例方法、实例变量，必须实例化类之后用实例化对象才能调用。在类方法中调用实例变量会报错，在实例方法中调用实例变量则没有问题。&lt;/p&gt;

&lt;p&gt;由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;类方法中不能引用对象变量；&lt;/li&gt;
  &lt;li&gt;类方法中不能调用类的对象方法；&lt;/li&gt;
  &lt;li&gt;在类方法中不能使用super、this关键字。&lt;/li&gt;
  &lt;li&gt;类方法不能被覆盖。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果违反这些限制，就会导致程序编译错误。&lt;/p&gt;

&lt;p&gt;与类方法相比，对象方法几乎没有什么限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象方法中可以引用对象变量，也可以引用类变量；&lt;/li&gt;
  &lt;li&gt;对象方法中可以调用类方法；&lt;/li&gt;
  &lt;li&gt;对象方法中可以使用super、this关键字。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;13、Collection与Collections的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。&lt;/p&gt;

&lt;p&gt;Collection &lt;br /&gt;
├List &lt;br /&gt;
│├LinkedList &lt;br /&gt;
│├ArrayList &lt;br /&gt;
│└Vector &lt;br /&gt;
│　└Stack &lt;br /&gt;
└Set&lt;br /&gt;
│　└HashSet&lt;/p&gt;

&lt;p&gt;└Queue&lt;/p&gt;

&lt;p&gt;java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，因为内部的构造函数被私有化了就像一个工具类，服务于Java的Collection框架。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14、super()与this()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。&lt;/p&gt;

&lt;p&gt;2）super()和this()类似,区别是，super从子类中调用父类的构造方法，this()在同一类内调用其它方法。&lt;/p&gt;

&lt;p&gt;3）super()和this()均需放在构造方法内第一行，既然两个都要放在第一行，那么两个就不可能同时存在一个构造函数里。&lt;/p&gt;

&lt;p&gt;4）尽管可以用this调用一个构造器，但却不能调用两个。&lt;/p&gt;

&lt;p&gt;5）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。&lt;/p&gt;

&lt;p&gt;6）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main17{
    public Main17(){
        super();
        System.out.println(&quot;1&quot;);
    }
    public Main17(int a){
        this();
        System.out.println(a);
    }
    public Main17(int a, String s){
        this(a);
        System.out.println(s+a);
    }
    public static void main(String[] args) {
        Main17 main17 = new Main17(2,&quot;end:&quot;);
    }
}
result：
1
2
end:2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;15、Java中的float与double精度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;float的精度最多8位，double的精度最多17位。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
		
		double a = 1.0;
		double b = 1.0;
		System.out.println(a == b);//这样的代码是拿不到offer的
		double t = 30.000000000000000;
		double c = 30.000000000000003;//double最多17位
		double d = 30.0000000000000003;
		System.out.println(t == c);//false
		System.out.println(t == d);//true
		System.out.println(Double.compare(t, d));//0 数学上相等
		System.out.println(c &amp;lt;= 30);//false
		System.out.println(d &amp;lt;= 30);//true  d总位数超过了17，则会将小数点多余的3去掉即等于30.000000000000000
		
		float e = 4.0000003f;//float最多8位
		float f = 4.00000003f;
		System.out.println(e &amp;lt;= 4);//false
		System.out.println(f &amp;lt;= 4);//true f总位数超过了8，则会将小数点多余的3去掉即等于4.0000000
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 11 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2017/05/11/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E6%89%AB%E7%9B%B2.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2017/05/11/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E6%89%AB%E7%9B%B2.html</guid>
        
        <category>java</category>
        
        <category>知识点</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>《清醒思考的艺术：你最好让别人去犯的52种思维错误》读书笔记</title>
        <description>&lt;p&gt;这段时间在看产品的书，有PM大牛推荐了这本书《清醒思考的艺术：你最好让别人去犯的52种思维错误》，在做产品的时候如果能避免这些思维错误，在生活中刻意的去训练这些思维艺术，我想那么看待问题可能会多一些视角，解决问题也就多了一种方式。下面是我认为比较常见的思维错误，记录下来以便以后多看看，同时也分享给大家。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、幸存偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于生活中我们更容易看到媒体上的成功案例，而看不到背后千千万万的失败，你会系统性的高估成功的希望。我们应该多看看曾经大有希望如今却葬身商场的项目，虽然会有点打击，却对你有好处。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、是原因还是结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;女模特为化妆品做广告，不是你买了这款化妆品就能变得向女模特一样漂亮（结果），而是之所以选这个女模特来做广告是因为她天生丽质才被选出来拍化妆品广告（原因）；游泳健身教练身材健硕，并不是你去游泳健身就能练就同样的身材（结果），而是那些教练本身身材就健硕所以才来做游泳健身教练（原因）。&lt;/p&gt;

&lt;p&gt;在现实生活中，我们往往把一件事的结果当做这件事发生的原因，这样的思维误差对洞悉产品是不是好产品来说是致命的。&lt;/p&gt;

&lt;p&gt;当别人说这样做能把产品做好，请你认真思考，这样做的举措是产品好的原因还是结果。如果是原因，那么你应该毫不犹豫的采纳，但如果是结果，请洞悉其原因。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、过度自信效应&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个人对自己的预估都会比实际偏高，连悲观的人也是。而且男人一般比女人要更高估自己。
所以，对所有的预测都持怀疑态度，尤其是当这些预测是由那些所谓的专家作出的。在筹划一件事情的时候从悲观的角度出发，作最坏的打算。这样才能更现实的判断当前的形势。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、从众心理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是人类进化过程中的一个性格弱点，我们会自然地觉得大家都选择的就不会太差。但在做决定的时候请记住英国作家毛姆的话：就算有5000万个人声称某件蠢事是对的，这件蠢事也不对因此成为明智之举。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、沉没成本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们对一件事情付出的越多就越难放弃。就人性来说，沉没成本越大，继续做某事的理由就越多。做某件事情往往有很多好的、合理的理由支持你继续走下去，但如果只是因为舍不得已经付出的沉没成本就不是好理由了。理性的决定意味着忽视沉没成本。你已经投资了什么不重要，重要的是现在的形势以及你对未来的评估。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、互惠偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;互惠这一理念在人类脑海里已经存活了一亿多年了。如果一个人对我好，那我会在另一个方面也对他好，不然心有愧欠。上世纪克里希那教徒在火车站免费给行人送鲜花，当行人在下一个路口扔进垃圾桶里的时候克里希那教徒再上前请求募捐，这样行人往往出于愧欠而募捐。所以下次在遇到免费的好事，那么最好是拒绝，别让自己陷互惠偏误的魔咒之中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、确认偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;人们更容易相信自己愿意相信的东西，而自动忽略那些对自身信念进行攻击的事情，比如听一个人讲话，看一本书，你往往会更愿意相信或更容易接受那些你早就认可的东西，而自动排斥那些你不认可的东西，所以以后接触别人的时候要尽可能去聆听所有，思考所有，别错过那些会让你变得更美好的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、权威偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;人们面对问题时会倾向于臣服权威（这个其实看那个一听领导人讲话就哭的某国就很形象了，哈哈）。面对权威人们会将独立思考调低一级，非理性地对待问题。
所以面对权威请尝试挑战，辩证地看待权威，这样会更加自由。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、对比效应&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可能会愿意多走10分钟的路去买便宜10块钱的水果，但你却不愿意多走10分钟的路去买原价989现价979的西服。一种从100块钱降价到70块钱的产品会显得比一直卖70块钱的产品更便宜。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10、现成偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们会依据现成的例子来想象世界，这是思维错误的常见之一，外界现实中的某种东西不会因为我们容易想到而出现得更频繁。&lt;/p&gt;

&lt;p&gt;所以，在产品定位和市场分析的时候，产品经理不应该只参考某一类人的反馈，而应该多与跟自己想法不同的人交流，打破固有思维。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11、确认偏误的变体－“在好转前会先恶化”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果有人告诉你某件事“在好转前会先恶化”，那你会发现接下来无论发生的事你都会感谢这个人：如果事情却是继续恶化，就证明他的预测是正确的；如果事情变化，那你也会把好转归功于这个人。所以当有人告诉你事情“在好转前会先恶化”，那么你应该小心。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12、故事偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有两则故事：一、国王死了，然后王后也死了。二、国王死了，随后王后伤心死去。毋庸置疑，这第两则故事会让听者印象更加深刻。&lt;/p&gt;

&lt;p&gt;所以做一个有故事的产品比一个没有故事的产品要更容易成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13、事后诸葛亮偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们对马云创造的阿里帝国赞叹不已，觉得马云的成功是必然的，但在马云刚开始创业的时候却没人愿意相信他能成功。我们总是对已经成功或失败的事情表现的很睿智，分析的头头是道，这是一种常见的思维误差。不要忽略世界的不可预见性。&lt;/p&gt;

&lt;p&gt;所以，在分析成功或失败产品的原因时，保持一份谦逊，你没有你想象中那么有预见性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14、控制错觉&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当你想得到一个大的数字的时候，你会用力掷色子；当你想得到一个小数字的时候，你会尽可能掷得温柔。但理性的人知道，掷色子得到的点数的概率是一样的，但人们会有控制错觉，错误的认为自己能控制某件事情的走向。&lt;/p&gt;

&lt;p&gt;那么在产品设计上可以使用“安慰按钮”，比如淘宝上的催单按钮，让用户觉得他能控制一些东西，把用户体验做的更好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15、激励误差&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;鼠灾，法国政府颁发法令：人们每交出一只死老鼠就能得到一定的报酬。然而人们不是去杀老鼠，反而大量养殖老鼠。&lt;/p&gt;

&lt;p&gt;这说明：一、一旦有激励或改变激励的方式，人们会迅速而剧烈的改变自己的行为；二、人们只是对激励（得到一定的报酬）做出反应，而不是对激励背后的目的（杀死老鼠）做出反应。
所以，在设计产品激励时，应该注意这种激励误差，将激励和目的结合起来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16、回归均值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一件事情发展到最差或最好的时候，会倾向于回归平均水平。&lt;/p&gt;

&lt;p&gt;所以，当你做了一系列举措之后，产品的表现变好或变差，别着急定义这些举措，想想回归均值。&lt;/p&gt;

&lt;p&gt;但请注意概率事件：将一枚硬币连抛50次都是人头朝上，如果要你用100块钱来堵下一次会是人头还是数字，大部分人会压数字，虽然人头同样是可能的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17、选择悖论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选择范围太大会导致无所适从，做出更差的决定同时也更可能导致不满。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18、讨喜偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某人越讨喜，我们就越倾向于从这个人那儿买东西或者帮助他。&lt;/p&gt;

&lt;p&gt;我们会觉得一个人讨喜，如果他：1、外表有吸引力；2、在出身、个性和兴趣上与我们相似；3、他觉得我们讨人喜欢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19、规避损失&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;损失要比同等的收益对我们的影响更大。&lt;/p&gt;

&lt;p&gt;“请每年接受体检，这样你可以及时发现可能的癌症。”，“如果你不每年接受体检，那么你在冒可能的癌症和不能及时得到治疗的风险”，第二句远比第一句要来的有效果。&lt;/p&gt;

&lt;p&gt;所以告诉别人如果不这么做的损失比告诉别人这么做能得到的收益更加能说服别人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20、关联谬误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;克劳斯致力研究第三世界课题，在西非红十字会工作了两年，以下哪种可能性最大：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;克劳斯在一家银行工作；&lt;/li&gt;
  &lt;li&gt;克劳斯在一家银行工作，在那里负责第三世界基金会。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很多人会选择2，但理性思考下，即是银行家又在其中的第三世界基金会工作只是银行工作人员的一小部分，所以1的可能性相比最大。关联谬误的思维陷阱会让我们更相信“和谐的”或“可信的”故事，如果将克劳斯的故事描绘的更感人，那么我们犯这一思维错误的危险就越大。&lt;/p&gt;

&lt;p&gt;诺贝尔获奖者卡尼曼认为思维分为两种：一种是直觉、机械、直接的思维；另一种是有意识、理性、缓慢、有逻辑的思维。但往往在有意识的思维开始之前，直觉思维就已经给出了结论。
就比如911事件发生后，聪明的保险公司推出“恐怖主义保险”，尽管其他类的保险显然已经包括了受到恐怖袭击的情况，而去美国的人买保险还是更倾向买“恐怖主义保险”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21、框架效应&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;99%无脂的和1%有脂的肉，大部分人会选择99%无脂的，尽管这两种肉是一样的。同一种意思用不同的方式表达出来，听者产生的反应就大不一样。&lt;/p&gt;

&lt;p&gt;美化是框架效应特别喜欢采用的方式：股价下跌称为“回调”；问题不再是“问题”，而是“机会”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22、行动偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;人们在&lt;strong&gt;遇到新情形或不明情形时&lt;/strong&gt;，会产生行动偏误，也就是人们会更倾向于做点什么而不是停下来思考。&lt;/p&gt;

&lt;p&gt;比如，点球的时候，球有1/3的概率射向球门中央，有1/3的概率射向球门左边，有1/3的概率射向球门右边，但守门员往往会扑左边或者右边，而很少待在中间－尽管有1/3的球会射向那里。这种行动偏误是人性潜在的一种偏误，想象下我们的祖先在森林边缘出现一个看上去像是一支剑齿虎的影子，他们不会像罗丹的“思想者”那样坐到一块石头上去进行分类思考，这到底是一只剑齿虎还是一只猫，他们会拔腿就跑。&lt;/p&gt;

&lt;p&gt;所以，我们在不明情况下会产生做点什么的冲动，随便什么（管它有没有帮助），因为这样我们会好受一点，即使事情没有什么好转。但理性地来说，如果情况不明，不要采取任何行动，直到你能更好地分析形势。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23、不作为偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种偏误总是出现在&lt;strong&gt;无论放弃还是行动都会带来损害的地方&lt;/strong&gt;，在这种情况下大多数人都会选择放弃，因为这样引起的损害主观看来更无害。不作为偏误大多出现在：今天的行为可以防止未来的损害，但防止损害对我们的激励并不强。&lt;/p&gt;

&lt;p&gt;比如：公司管理层会认为不研发新产品不如研发错误产品严重，尽管两者都会使公司破产；不申报收入不比伪造纳税资料严重。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24、联想偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一朝被蛇咬，十年怕井绳。被蛇咬后，看到井绳就能联想到蛇。&lt;/p&gt;

&lt;p&gt;开到蓝色的易拉罐就会联系到百事可乐，看到红色色调的网站就会想是京东或天猫。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25、及时行乐偏误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你宁愿在一年后得到100万还是在一年零一个月之后得到110万呢？大部分人会选择后者，因为一年都等了，再等一个月也无所谓；但你宁愿今天得到100万还是在一个月后的到110万呢？大部分人会选择前者。这种现象科学里称为双曲贴现：一个决定离现在越近，我们的“情感利息”就越多。&lt;/p&gt;

&lt;p&gt;随着年纪的增长，建立的自我控制越多，我们就越容易成功地延迟满足，但人性里及时行乐的诱惑依旧不可小觑。&lt;/p&gt;

</description>
        <pubDate>Sat, 17 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/life/2016/12/17/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF-%E4%BD%A0%E6%9C%80%E5%A5%BD%E8%AE%A9%E5%88%AB%E4%BA%BA%E5%8E%BB%E7%8A%AF%E7%9A%8452%E7%A7%8D%E6%80%9D%E7%BB%B4%E9%94%99%E8%AF%AF-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2016/12/17/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF-%E4%BD%A0%E6%9C%80%E5%A5%BD%E8%AE%A9%E5%88%AB%E4%BA%BA%E5%8E%BB%E7%8A%AF%E7%9A%8452%E7%A7%8D%E6%80%9D%E7%BB%B4%E9%94%99%E8%AF%AF-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</guid>
        
        <category>清醒思考</category>
        
        <category>思维错误</category>
        
        <category>读书笔记</category>
        
        
        <category>Life</category>
        
      </item>
    
      <item>
        <title>《大数据时代》读书笔记（二）</title>
        <description>&lt;p&gt;大数据时代给许多公司创造了新的竞争力和商业价值。Viktor认为一切皆可“量化”，大数据发展的核心动力来源于人类测量、记录和分析世界的渴望。&lt;/p&gt;

&lt;p&gt;当文字变成数据，文字则不仅可以被人所阅读，机器也可以用之分析。“谷歌翻译”是一个里程碑式的大数据胜利，谷歌拥有大量的搜索记录和数据化的书籍信息，并利用这些数字化的文字来改进它的机器翻译服务，“谷歌翻译”成为谷歌的标志性产品，不仅精确而且包含多样的语言翻译。同样拥有大量数据化书籍的亚马逊却只是把眼光聚集在阅读的书籍的内容上，而不是分析数据化文本上。亚马逊深谙数字化内容的意义，但谷歌触及了数字化内容的价值，两种不同的对大数据的态度决定了两种不同的发展战略。但这任然不可否定亚马逊是一家伟大的大数据公司，它通过对大量顾客的购买数据进行分析，为每个用户提供个性化的购买清单，这种营销策略为亚马逊节省了大量人力成本并且提高了效率。当方位变成数据，我们的出行变得更加便捷。地图导航软件利用大量的地理位置数据为我们的出行提供最佳路径。当社交变成数据，我们就可以轻松预测到人在未来几天的情感甚至行为。通过对事物的数据化，我们可以从一个人在驾驶座上的坐姿来判断他是不是车的主人，可以通过以往飞机销售价格数据来预测未来的机票价格走势，可以通过收集用户在网页上鼠标停顿的位置和时间来判断广告位的安置。大数据时代，数据让我们的生活变得更加便捷和智能。&lt;/p&gt;

&lt;p&gt;接下来，我们应该开始思考在大数据时代，我们处于什么位置？如果想要在大数据时代有所发展，Viktor提出三种角色定位：数据、技术与思维。拥有海量数据，具备数据分析技术，培养数据战略思维。其中技术和思维在大数据时代早期是最有价值的，但最终大部分的价值在于数据本身。&lt;/p&gt;

&lt;p&gt;当然，大数据时代，一些互联网公司利用社交平台、各种APP终端疯狂地收揽我们的个人数据，其中有些私人数据我们不希望与他人共享，那么这其中的风险和责任我们又该如何定义？我还清楚记得淘宝数据泄露事件给大众带来的冲击，我们把我们的账号，密码，银行卡号，身份证号等一系列私密数据交由数据使用者“淘宝”，那么在我们的数据或通过分析数据得出来的预测信息被错误或过度使用和泄露时，数据使用者就应该承担责任，同样中国政府也应该尽快健全法律法规来规范大数据市场，保障数据的安全性。&lt;/p&gt;

&lt;p&gt;作为“不总结就会死”的深度患者，我习惯在看完一本书后，根据自己的理解写下读书笔记，为共享，更为自己以后可以回过头翻阅。读书的目的只有一个，追求思想之自由。我希望人生中我所经历的是所谓的正确还是错误，是“是”抑或是“非”，都能让自己有能力来评判。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/life/2016/10/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2016/10/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C.html</guid>
        
        <category>大数据时代</category>
        
        <category>读书笔记</category>
        
        
        <category>Life</category>
        
      </item>
    
      <item>
        <title>《大数据时代》读书笔记（一）</title>
        <description>&lt;p&gt;抱着对大数据无比敬仰的态度与渴望求知的姿态，终于将这本《大数据时代》拜读完。虽然品读完后收获颇丰，但到真要提笔写读书笔记的时候却不知如何说起，真心担忧我对这本书的理解和对大数据的认知无法真切地表达Viktor对大数据时代的研究，所以索性就写写自己对大数据的思考。&lt;/p&gt;

&lt;p&gt;维克托•迈尔-舍恩伯格，大数据时代的预言家，开大数据系统研究之先河，是位孜孜不倦的数据科学家。他的著作《大数据时代》分别从大数据的概念与特征，价值与角色定位，风险与掌控三个方面讲述了大数据是如何成为生活、工作与思维的大变革。&lt;/p&gt;

&lt;p&gt;我们过去在小数据时代，对数据的分析往往是基于随机抽样，通过对研究对象的随机采样进行分析，来预测研究对象的发展规律或判断研究对象的某些对人类有价值的特征，但这种预测或判断往往苍白无力，随着时间的推移而不断被推翻，因为随机抽样本身就无法做到真正的“随机”，里面无时无刻都包含着人的主观意识。而如今，在计算机存储与分布式计算能力愈加发达，我们已经步入大数据时代，我们开始变得有能力去收集、存储和分析所有的数据。无论是结构化数据还是越来越多的非结构化数据，我们都有能力将一切量化，并变成我们可用的数据。所以在大数据时代，我们不再追求随机样本，而开始分析全部数据，所以我理解的大数据的“大”就不在于其规模，而在于所得到的数据是不是研究对象的“全部”。&lt;/p&gt;

&lt;p&gt;毋庸置疑，在分析全部数据时，我们就必然不再（也无法）强调分析的精确性，开始转而包容数据的混杂性。这在小数据时代简直是无法忍受的，小数据时代追求数据绝对的正确，这样基于数据之上的研究才可能具有可信度。但在大数据时代，我们要求全部数据，那么其中就难以避免错误的数据也会混进数据库，而且我们也没有必要避免，因为错误的数据的不良影响会随着数据量变大而慢慢变小，更重要的是，错误的数据也会带来一个全新的亮点。举个例子，在百度搜索中，我们有时会输入错误的词条却依旧能得到这样一条提醒“您要搜索的是不是***”，这就是因为百度搜索引擎中，收集了全部的数据（当然也就包括这些错误的搜索词条），搜索算法对全部数据进行分析，寻找到错误词条的搜索与某一类结果具有相关性，然后以相关性高低排序给用户返回用户本来想要得到的结果。正确与错误的数据往往没有明确的界定，根本在于从不同的的角度来理解事物之间的相关性。&lt;/p&gt;

&lt;p&gt;在转变思维的最后一点，Viktor指出大数据时代追求的不是因果关系而是相关关系，知道“是什么”就够了，没必要知道“为什么”。但这一点我实在不敢苟同，我认为在中国，因果关系与相关关系同样重要，我们不仅要知道“是什么”更想知道“为什么”。相关性能让我们找到新的价值，而因果关系能让这种价值更容易被大众接受，毕竟我们的思维认知会倾向于去探索一个事物的因果由来，如果我们不知道一个事物发展的原因，我们会倾向于怀疑或保留意见。而从商业的角度讲，顾客的质疑态度对产品是致命的。&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/life/2016/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2016/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80.html</guid>
        
        <category>大数据时代</category>
        
        <category>读书笔记</category>
        
        
        <category>Life</category>
        
      </item>
    
  </channel>
</rss>
