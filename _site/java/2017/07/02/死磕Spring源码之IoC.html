<!DOCTYPE html>
<html lang="en">

	
	    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
    <meta content="死磕Spring源码-IoC容器" name="description">
  
  
    <meta name="keywords" content="java,Spring,源码,IoC">
  
  <meta name="author" content="周明">

  <title>
    
        周明的技术博客|死磕Spring源码-IoC容器
    
  </title>
  <!-- favicon -->
  <link rel="shortcut icon" href="/static/assets/img/favicon.ico">

  <!-- Main CSS -->
  <link href="/static/assets/app-20170521.min.css" rel="stylesheet">

  <!-- Main Scripts -->
  <script src="/static/assets/app-20170521.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function () {
      var initial = 0;
      var show = true;

      var toggleSearch = function (visible) {
        initial = 0;
        show = !visible;
        var visibility = visible ? 'block' : 'none';

        $("#search-content").val("");
        $(".search-tool").css("display", visibility);
      };

      var shouldToggle = function (time) {
        var gap = time - initial;
        initial = time;
        return gap < 500;
      };

      $(document).keyup(function (e) {
        var now = new Date().getTime();
        if (e.keyCode == 17 && shouldToggle(now)) {
          toggleSearch(show);
        } else if (e.keyCode == 27) {
          toggleSearch(false);
        }
      });

      $("#search-content").keyup(function (e) {
        var now = new Date().getTime();
        if (e.keyCode == 17 && shouldToggle(now)) {
          toggleSearch(show);
        }
      });

      $("#close-btn").click(function () {
        toggleSearch(false);
      });

      $("#search-btn").click(function() {
        toggleSearch(true);
      });

      $.getJSON("/search/cb-search.json")
        .done(function (data) {
          if (data.code == 0) {
            $("#search-content").typeahead({
              source: data.data,
              displayText: function (item) {
                return item.title;
              },
              afterSelect: function (item) {
                window.location.href = item.url;
              }
            });
          }
        });
    });
    $(function(){
        $("pre").css('display','block');
    });
  </script>
</head>

	

<body id="page-top" class="landing-page">

	
	    <div class="search-tool"
      style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px; opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">
    <input type="text" class="form-control search-content" id="search-content" style="position: fixed; top: 60px" placeholder="Search Blog">

    <div style="position: fixed; top: 16px; right: 16px; z-index: 9999;">
        <img src="/search/img/cb-close.png" id="close-btn"/>
    </div>
</div>

<div style="position: fixed; right: 16px; bottom: 20px; z-index: 9999;">
    <img src="/search/img/cb-search.png"  id="search-btn"  title="Double click Ctrl"/>
</div>

<div class="navbar-wrapper">
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">周明的技术博客</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li><a class="page-scroll" href="blog/"></a></li>
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/blog/">Blog</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/java/">Java</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/javascript/">Javascript</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/database/">Database</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/python/">Python</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/linux/">Linux</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/html/">HTML</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/DeepLearning/">DeepLearning</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/life/">Life</a></li>
                        
                    
                        
                        
                        <li>
                        
                        <a class="page-scroll" href="/donate/">Donate</a></li>
                        
                    
                </ul>
            </div>
        </div>
    </nav>
</div>
<div id="inSlider" class="carousel carousel-fade" data-ride="carousel">
    <ol class="carousel-indicators">
        <li data-target="#inSlider" data-slide-to="0" class="active"></li>
        <li data-target="#inSlider" data-slide-to="1"></li>
    </ol>
    <div class="carousel-inner" role="listbox">
        <div class="item active">
            <div class="container">
                <div class="carousel-caption">
                </div>
                <div class="carousel-image wow zoomIn">
                    <!-- <img src="static/img/landing/laptop.png" alt="laptop"/> -->
                </div>
            </div>
            <!-- Set background for slide in css -->
            <div class="header-back one"></div>

        </div>
        <div class="item">
            <div class="container">
                <div class="carousel-caption blank">
                </div>
            </div>
            <!-- Set background for slide in css -->
            <div class="header-back two"></div>
        </div>
    </div>
    <a class="left carousel-control" href="#inSlider" role="button" data-slide="prev">
        <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
        <span class="sr-only">Previous</span>
    </a>
    <a class="right carousel-control" href="#inSlider" role="button" data-slide="next">
        <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
        <span class="sr-only">Next</span>
    </a>
</div>

	

    <div class="wrapper wrapper-content  animated fadeInRight article">
    <div class="row">
        <div class="col-lg-10 col-lg-offset-1">
            <div class="ibox">
                <div class="ibox-content">
                    <div class="pull-right">
                    	
                        	<button class="btn btn-white btn-xs" type="button">Java</button>
                        
                    </div>
                    <div class="text-center article-title">
                    <span class="text-muted"><i class="fa fa-clock-o"></i> 2 Jul 2017</span>
                        <h1>
                            死磕Spring源码-IoC容器
                        </h1>
                    </div>
                    	<p>我们都知道IoC（Inversion of control）是控制反转，控制反转的核心是依赖反转，那到底什么是“依赖反转”，“哪些方面的控制被反转了？”－－依赖对象的获得被反转了。通过依赖注入的方式获取类对象实例而不是传统的在类自身通过新建（new）类对象来获取。所以这种反转是“责任”的反转，传统的这种对对象的管理是由java类自身来管理，而Spring通过IoC容器来管理，这种对对象的依赖关系的管理被反转了，转到IoC容器来了。对象之间的相互依赖关系由IoC容器进行管理，并由IoC容器完成对象的注入。这种做法降低了类之间的耦合度，同时提高了代码的可测试性。</p>

<p>IoC容器主要有两个容器系列：BeanFactory和ApplicationContext。</p>

<p><strong>IoC容器主要的接口设计图：</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片1="" src="http://img.mukewang.com/59744b1b0001c33d17101006.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<p><strong>一、BeanFactory</strong></p>

<p>接口类BeanFactory提供了Spring中所有IOC容器的最基本的功能规范，来看看<strong>BeanFactory的组织结构图</strong>：</p>

<p><img title="死磕Spring源码-IoC源码" 图片2="" src="http://img.mukewang.com/597444f50001bb0106261194.png" style="width:50%" alt="死磕Spring源码-IoC源码" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>public interface BeanFactory {
    //如果我们加了这个转义字符，则得到的是这个IOC容器本身，否则得到的是IOC容器的实例
     String FACTORY_BEAN_PREFIX = “&amp;”;
     Object getBean(String name) throws BeansException;
     &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;
     &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;
     Object getBean(String name, Object... args) throws BeansException;
     &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;
     boolean containsBean(String name);
     boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
     boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
     boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;
     boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;
     Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;
     String[] getAliases(String name);
}
</code></pre>
</div>

<p>所有的IoC容器都需要满足BeanFactory这个基本的接口定义，Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系。对IoC容器来说，BeanDefinition抽象了对Bean的定义的一种数据类型。</p>

<p><strong>BeanDefinition的组织结构如下图：</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片3="" src="http://img.mukewang.com/59744544000144cd06161220.png" style="width:50%" alt="死磕Spring源码-IoC源码" /></p>

<p>BeanFactory是一个接口类，我们来看看一个BeanFactory的具体实现类XmlBeanFactory，从名字上就能看出来这是一个与xml相关的BeanFactory，它是一个可以读取以XML文件方式定义的BeanDefinition的IoC容器。</p>

<p><img title="死磕Spring源码-IoC源码" 图片4="" src="http://img.mukewang.com/597445bc000120d818280524.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class XmlBeanFactory extends DefaultListableBeanFactory {

     private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);

     public XmlBeanFactory(Resource resource) throws BeansException {
          this(resource, null);
     }

     public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
          super(parentBeanFactory);
          this.reader.loadBeanDefinitions(resource);
     }

}
</code></pre>
</div>

<p>在XmlBeanFactory这个IOC容器中，初始化了一个XmlBeanDefinitionReader，用这个XmlBeanDefinitionReader来处理XML中的BeanDefinition对象。</p>

<p><strong>手工创建IOC容器</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class XmlIOCTest {

     public static void main(String[] args) {
//定义BeanDefinition的信息来源，在XmlBeanFactory中作为构造函数的参数传给XmlBeanFactory     
		  ClassPathResource resource = new ClassPathResource("config\\beans.xml”);
//创建一个BeanFactory的IoC容器
          DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
//创建一个加载BeanDefinition的读取器，通过一个回调配置给BeanFactory
          XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
//从信息来源中加载BeanDefinition
          reader.loadBeanDefinitions(resource);
          Admin admin = (Admin)factory.getBean("admin");
          admin.setName("ming.zhou");
          admin.setPassword("123");
          admin.setStatus(1);
          System.out.println(admin);
     }

}
</code></pre>
</div>

<p><strong>输入结果：</strong></p>

<p><code class="highlighter-rouge">Admin{id=null, name='ming.zhou', password='123', status=1}</code></p>

<p>由上我们可以总结IoC容器的初始化过程（refresh()方法来启动）：（源码查看可以通过loadBeanDefinitions逐步查看）
Resource定位过程－－BeanDefinition的载入－－向IoC容器注册BeanDefinition（调用BeanDefinitionRegistry接口来实现，每个bean放在hashMap中存储）</p>

<p><strong>二、ApplicationContext</strong></p>

<p>接口类ApplicationContext是高级形态意义的IOC容器。</p>

<p>IoC容器的初始化是由refresh()方法来启动的，它标志这IoC容器的正式启动，启动过程包含BeanDefinition的Resource定位、载入和注册三个基本过程。</p>

<p><strong>2.1 Resource定位</strong></p>

<p><strong>Resource接口设计图：</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片5="" src="http://img.mukewang.com/597450100001ace507340894.png" style="width:50%" alt="死磕Spring源码-IoC源码" /></p>

<p>FileSystemApplicationContext，支持XML定义的BeanDefinition的ApplicationContext，可指定以文件形式的BeanDefinition的读入，文件放在本地文件系统中。</p>

<p><strong>FileSystemApplicationContext的继承关系图:</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片6="" src="http://img.mukewang.com/597447b90001efaa07380916.png" style="width:50%" alt="死磕Spring源码-IoC源码" /></p>

<p><strong>getResourceByPath()的调用栈：</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片7="" src="http://img.mukewang.com/597447e10001335817380988.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<p>通过查看FileSystemApplicationContext中的getResourceByPath()的方法调用栈可以发现这个<strong>IOC容器资源定位的实现过程：</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片8="" src="http://img.mukewang.com/597447fa0001cf1e17800904.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<p>类AbstractRefreshableApplicationContext对容器初始化源码分析:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
protected final void refreshBeanFactory() throws BeansException {
//如果已经建立了BeanFactory，则销毁并关闭该BeanFactory，保证refresh以后使用的是新建立起来的IoC容器
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        customizeBeanFactory(beanFactory);
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    }
}

@Override
public Resource getResource(String location) {
    Assert.notNull(location, "Location must not be null");

    for (ProtocolResolver protocolResolver : this.protocolResolvers) {
        Resource resource = protocolResolver.resolve(location, this);
        if (resource != null) {
            return resource;
        }
    }

    if (location.startsWith("/")) {
        return getResourceByPath(location);
    }
    //处理带有classpath标识的Resource
    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
    }
    else {
        try {
            // 处理URL标识的Resource
            URL url = new URL(location);
            return new UrlResource(url);
        }
        catch (MalformedURLException ex) {
            // No URL -&gt; resolve as resource path.
            return getResourceByPath(location);
        }
    }
}
</code></pre>
</div>

<p>整个过程起源于FileSystemApplicationContext的构造函数的初始化，通过构造函数中的refresh()方法来启动整个应用，在AbstractRefreshableApplicationContext中的refreshBeanFactory()方法中我们可以看到使用了createBeanFactory构建了一个DefaultListableBeanFactory的IOC容器，同时启动资源载入（AbstractRefreshableApplicationContext中的loadBeanDefinitions()方法是抽象方法，因为载入的方式有很多种，具体的载入操作交由其子类去具体实现，这里的子类就是
XmlWebApplicationContext
）；具体的资源载入在XmlWebApplicationContext的loadBeanDefinitions()中读入BeanDefinition时完成（loadBeanDefinitions方法在方法调用栈中第一次出现是在XmlWebApplicationContext中的），载入的具体实现在XmlWebApplicationContext的基类AbstractBeanDefinitionReader中。</p>

<p><strong>2.2 BeanDefinition的载入与解析</strong></p>

<p><strong>loadBeanDefinitions的调用方法栈:</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片9="" src="http://img.mukewang.com/597449790001262916520684.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<p>有了Resource定位对象后，开始BeanDefinition的载入与解析的工作，按照Spring的Bean定义规则来对这个XML的文档树进行解析了，解析工作是交给BeanDefinitionParserDelegate来完成的。BeanDefinition的载入分为两部分：首先是通过调用XML的解析器得到document对象，但这些document对象并没有按照Spring的Bean规则进行解析；然后在完成通用的XML解析后，才开始按照Spring的Bean规则进行解析。按照Spring的Bean规则进行解析过程是在documentReader中实现的，把Bean的id、name、aliase等属性元素读取出来后设置到生成的BeanDefinitionHolder中去。BeanDefinitionHolder是BeanDefinition的封装类，封装了BeanDefinition，Bean的名字和别名，用它来完成向IoC容器注册。</p>

<p>BeanDefinition的载入与解析过程源码解析如下，有点长，但不难，耐心看下去思路还是很清晰的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
//调用入口
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(new EncodedResource(resource));
}
//载入XML形式的BeanDefinition
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    Assert.notNull(encodedResource, "EncodedResource must not be null");
    if (logger.isInfoEnabled()) {
        logger.info("Loading XML bean definitions from " + encodedResource.getResource());
    }

    Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
    if (currentResources == null) {
        currentResources = new HashSet&lt;EncodedResource&gt;(4);
        this.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    if (!currentResources.add(encodedResource)) {
        throw new BeanDefinitionStoreException(
                "Detected cyclic loading of " + encodedResource + " - check your import definitions!");
    }
    //得到XML文件，并获取IO的InputSource准备进行读取
    try {
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(
                "IOException parsing XML document from " + encodedResource.getResource(), ex);
    }
    finally {
        currentResources.remove(encodedResource);
        if (currentResources.isEmpty()) {
            this.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}
//具体的读取过程
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {
    try {
        //调用XML的解析器得到document对象
        Document doc = doLoadDocument(inputSource, resource);
        //启动对BeanDefinition解析过程
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                "XML document from " + resource + " is invalid", ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                "Parser configuration exception parsing XML from " + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                "IOException parsing XML document from " + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                "Unexpected exception parsing XML document from " + resource, ex);
    }
}
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    //得到BeanDefinitionDocumentReader来对XML的BeanDefinition进行解析
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    int countBefore = getRegistry().getBeanDefinitionCount();
    //调用BeanDefinitionDocumentReader的registerBeanDefinitions完成具体的解析过程
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    return getRegistry().getBeanDefinitionCount() - countBefore;
}
</code></pre>
</div>

<p>BeanDefinitionDocumentReader类的registerBeanDefinitions方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug("Loading bean definitions");
    Element root = doc.getDocumentElement();
    doRegisterBeanDefinitions(root);
}
protected void doRegisterBeanDefinitions(Element root) {
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    if (this.delegate.isDefaultNamespace(root)) {
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isInfoEnabled()) {
                    logger.info("Skipped XML bean definition file due to specified profiles [" + profileSpec +
                            "] not matching: " + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    parseBeanDefinitions(root, this.delegate);
    postProcessXml(root);

    this.delegate = parent;
}
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    //BeanDefinitionHolder是BeanDefinition的封装类，封装了BeanDefinition，Bean的名字和别名，用它来完成向IoC容器注册
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            //向IoC容器注册解析得到的BeanDefinition
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error("Failed to register bean definition with name '" +
                    bdHolder.getBeanName() + "'", ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
//BeanDefinitionParserDelegate类方法，具体的解析过程，把Bean的id、name、aliase等属性元素读取出来后设置到生成的BeanDefinitionHolder中去
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
    //取得&lt;Bean&gt;元素中的id、name、aliase属性的值
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
        beanName = aliases.remove(0);
        if (logger.isDebugEnabled()) {
            logger.debug("No XML 'id' specified - using '" + beanName +
                    "' as bean name and " + aliases + " as aliases");
        }
    }

    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }
    //对Bean元素的详细解析，比如class、parent、init-method、destroy-method等
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    // Register an alias for the plain bean class name, if still possible,
                    // if the generator returned the class name plus a suffix.
                    // This is expected for Spring 1.2/2.0 backwards compatibility.
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &amp;&amp;
                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug("Neither XML 'id' nor 'name' specified - " +
                            "using generated bean name [" + beanName + "]");
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }

    return null;
}
</code></pre>
</div>

<p><strong>载入与解析的方法调用流程图：</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片10="" src="http://img.mukewang.com/59744a180001978917380986.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<p>经过以上的载入过程，我们大致完成了IoC容器的Bean对象的数据准备工作或初始化工作，但现在IoC容器BeanDefinition中还只是存在些静态的配置信息，还不能供IoC容器直接使用，要想让IoC容器发挥作用还需要进行BeanDefinition的注册。</p>

<p><strong>2.3 BeanDefinition的注册</strong></p>

<p>注册过程相对简单，这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的，这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册，通过源码分析，我们可以看到在IoC容器中是持有一个HashMap来装BeanDefinition数据的。</p>

<p><strong>registerBeanDefinition的调用方法栈:</strong></p>

<p><img title="死磕Spring源码-IoC源码" 图片11="" src="http://img.mukewang.com/59744a4700014e0a17340788.png" style="width:100%" alt="死磕Spring源码-IoC源码" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(256);
public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}

@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {

    Assert.hasText(beanName, "Bean name must not be empty");
    Assert.notNull(beanDefinition, "BeanDefinition must not be null");

    if (beanDefinition instanceof AbstractBeanDefinition) {
        try {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    "Validation of bean definition failed", ex);
        }
    }

    BeanDefinition oldBeanDefinition;

    //检查是不是有同名字的BeanDefinition已经在IoC容器中注册了，如果存在且不允许覆盖则抛出异常
    oldBeanDefinition = this.beanDefinitionMap.get(beanName);
    if (oldBeanDefinition != null) {
        if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    "Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName +
                    "': There is already [" + oldBeanDefinition + "] bound.");
        }
        else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {
            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
            if (this.logger.isWarnEnabled()) {
                this.logger.warn("Overriding user-defined bean definition for bean '" + beanName +
                        "' with a framework-generated bean definition: replacing [" +
                        oldBeanDefinition + "] with [" + beanDefinition + "]");
            }
        }
        else if (!beanDefinition.equals(oldBeanDefinition)) {
            if (this.logger.isInfoEnabled()) {
                this.logger.info("Overriding bean definition for bean '" + beanName +
                        "' with a different definition: replacing [" + oldBeanDefinition +
                        "] with [" + beanDefinition + "]");
            }
        }
        else {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug("Overriding bean definition for bean '" + beanName +
                        "' with an equivalent definition: replacing [" + oldBeanDefinition +
                        "] with [" + beanDefinition + "]");
            }
        }
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            //注册过程需要synchronized，保证数据的一致性
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                if (this.manualSingletonNames.contains(beanName)) {
                    Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    this.manualSingletonNames = updatedSingletons;
                }
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            this.manualSingletonNames.remove(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (oldBeanDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}
</code></pre>
</div>

<p>注册过程会检查是不是有同名字的BeanDefinition已经在IoC容器中注册了，如果存在且不允许覆盖则抛出异常，注册过程需要synchronized，保证数据的一致性。</p>

<p>完成了BeanDefinition的注册，IOC容器的初始化过程就结束了，在这个IOC容器中已经有了整个Bean的配置信息。</p>

<p><strong>总结：</strong></p>

<p><strong>IoC的概念</strong></p>

<p><strong>BeanFactory</strong>（提供IoC容器最基本的功能规范），BeanFactory接口的基本方法有哪些？从手工创建IOC容器中可以获悉IoC的建立与初始化过程（四步：资源定位-&gt;创建BeanFactory的IoC容器-&gt;创建一个加载BeanDefinition的读取器，通过一个回调配置给BeanFactory-&gt;从已定位的资源中加载BeanDefinition）</p>

<p><strong>ApplicationContext</strong>（高级形态意义的IOC容器），以FileSystemApplicationContext为例解析ApplicationContext的初始化过程。</p>

<p><strong>资源定位</strong>：Resource getResource(String location)，不同标识对应不同的Resource，classPath-&gt;classPathResource；url-&gt;ServletContextResource；否则调用容器本身的getResourceByPath方法获取Resource</p>

<p><strong>载入与解析资源</strong>：<code class="highlighter-rouge">int loadBeanDefinitions(Resource resource)</code>，input是之前定位好的资源对象Resource，输出是这次加载了多少个BeanDefinition；载入与解析的工作分为两步：</p>

<p>第一：通过调用XML的解析器得到document对象；</p>

<p>第二：</p>

<p>—&gt;将得到的document对象作为输入传入<code class="highlighter-rouge">registerBeanDefinitions(Document doc, Resource resource)</code>方法</p>

<p>—&gt;然后使用BeanDefinitionDocumentReader类来按照Spring的Bean规则解析Document对象，得到Document的Element对象，<code class="highlighter-rouge">Element root = doc.getDocumentElement()</code></p>

<p>—&gt;解析element对象，<code class="highlighter-rouge">BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)</code>，将Element作为输入，在parseBeanDefinitionElement方法中解析，取得<Bean>元素中的id、name、aliase属性的值，对Bean元素的详细解析，比如class、parent、init-method、destroy-method等</Bean></p>

<p>—&gt;最终将解析的数据作为输入，生成BeanDefinitionHolder的实例，<code class="highlighter-rouge">return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</code></p>

<p><strong>资源的注册</strong>：这部分相对载入与解析要更简单一些，将这部分生成的BeanDefinitionHolder作为输入，传入<code class="highlighter-rouge">void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</code></p>

<p>—&gt;从BeanDefinitionHolder对象中获取beanName和BeanDefinition，</p>

<p><code class="highlighter-rouge">String beanName = definitionHolder.getBeanName();
registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())</code></p>

<p>并以beanName和BeanDefinition作为输入去注册Bean，用一个<code class="highlighter-rouge">new ConcurrentHashMap&lt;String, BeanDefinition&gt;(256)</code>的hashMap来维护Bean；同时从BeanDefinitionHolder对象中过去Bean的一些配置属性，并且为Bean设置好这些配置属性：<code class="highlighter-rouge">registry.registerAlias(beanName, alias);</code></p>

<p><strong>参考：</strong></p>

<p>1、Spring 4.3.3源码</p>

<p>2、《Spring 技术内幕（深入解析Spring架构与设计原理）》</p>


                    <hr>
                    <div class="row">
                        <div class="col-md-6">
                                <h5 style="display: inline;">Tags:</h5>
                                
                                    <button class="btn btn-white btn-xs" type="button">java</button>
                                
                                    <button class="btn btn-white btn-xs" type="button">Spring</button>
                                
                                    <button class="btn btn-white btn-xs" type="button">源码</button>
                                
                                    <button class="btn btn-white btn-xs" type="button">IoC</button>
                                
                        </div>
                        <div class="col-md-6">
                            <div class="small text-right">
                                <h5>Stats:</h5>
                                <div>
                                
                                
                                </div>
                            </div>
                        </div>
                    </div>
                    <br>
                    <div class="row">
                        <div class="col-lg-12">
                            <!-- donate -->
                            
                            <div class="text-center">
<a class="btn btn-warning  dim btn-large-dim btn-outline" href="/donate/"><i class="fa fa-smile-o"></i></a>
</div>

                            
                            <br>
                            <!-- share -->
                            <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
<!-- <a class="a2a_dd" href="https://www.addtoany.com/share"></a>
<a class="a2a_button_facebook"></a>
<a class="a2a_button_twitter"></a>
<a class="a2a_button_google_plus"></a>
<a class="a2a_button_linkedin"></a> -->
<a class="a2a_button_email"></a>
<a class="a2a_button_wechat" style="margin-left:2%"></a>
<a class="a2a_button_sina_weibo" style="margin-left:2%"></a>
<!-- <a class="a2a_button_pocket"></a> -->
</div>
<script>
var a2a_config = a2a_config || {};
a2a_config.color_main = "D7E5ED";
a2a_config.color_border = "AECADB";
a2a_config.color_link_text = "333333";
a2a_config.color_link_text_hover = "333333";
</script>
<script async src="https://static.addtoany.com/menu/page.js"></script>

                            <br>
                            <!-- comment -->
                            

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>


	
	    <!-- Google analytics -->


<!-- GrowingIO -->





	

</body>
</html>
